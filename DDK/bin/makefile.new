!IF 0

Copyright (c) 1989-1996  Microsoft Corporation

Module Name:

    makefile.def

Abstract:

    This is the standard makefile for the components of the NT project.
    It includes the following files:

        .\sources.      - developer supplies this file.  It defines the
                          required TARGETNAME, TARGETPATH, TARGETTYPE and
                          SOURCES as well as optional macros that control
                          the behavior of the compiler and linker:

        obj\_objects.mac  - built by BUILD.EXE from .\sources.


Targets:

    all       - Builds all targets in this make file

    clean     - Erase all targets that can be produced by this make
                file, ignoring errors.  Also rebuilds the depend target.

    depend    - Rebuilts source file dependencies, using BUILD.EXE tool


Useful Variables Set:

    CPUTYPE={I386|MPPC|IA64|AMD64|ARM}

Optional Controls Variables (partial list), these are environment variables,
remember they can be set with env=value on the command line as well:

NOTE:  xxx_... is {MSC|386|axp64|alpha|MPPC|ia64|amd64} where MSC_ applies to the C8 compiler
       independent of the cpu type.  Specific cpu_ will take precedence
       over the equivalent MSC_ variable.

EXAMPLE:  To compile with codeview symbols for windbg:

          set NTDEBUG=ntsd
          set NTDEBUGTYPE=windbg
          set MSC_OPTIMIZATION=/Od


    nttest=filename

    umappl=filename

    NT_UP
            Define as 0 in environment to turn on MP.
            If undefined or equal to 1, you get UP.

    xxx_warning_level

    xxx_optimization

    xxx_STDCALL = 1 use _stdcall calling convention
                  0 use _cdecl calling convention

    ntdebug

    browser_info

    xxx_cppflags

    ntcppflags

    NT_INST - set to turn on instrumentation

    BASEDIR - \nt or \ntrel (default \nt)

    PRECOMPILED_CXX=1 - do precompiled headers for CXX instead of C files
                        note: precompiled headers can not be used on both
                        c and cxx files in a single directory.
!ENDIF

# See if the user wants BROWSER_INFO.
!ifdef BROWSER_INFO
USER_ENV_BROWSER_INFO=1
!endif

#
# Select build target and set platform specific variables.
#

!ifdef BUILD_ALLOW_ALL_WARNINGS
BUILD_ALLOW_LINKER_WARNINGS=1
BUILD_ALLOW_COMPILER_WARNINGS=1
BUILD_ALLOW_MIDL_WARNINGS=1
!endif
BUILD_ALLOW_MIDL_WARNINGS=1

!ifndef BUILD_ALLOW_LINKER_WARNINGS
LINKER_WX_SWITCH=/WX
!else
LINKER_WX_SWITCH=
!endif

!ifndef BUILD_ALLOW_COMPILER_WARNINGS
COMPILER_WX_SWITCH=/WX /wd4996
!else
COMPILER_WX_SWITCH=
!endif

!ifndef BUILD_ALLOW_MANAGED_CODE_WARNINGS
MANAGED_WX_SWITCH=/warnaserror+
!else
MANAGED_WX_SWITCH=
!endif

!ifndef BUILD_ALLOW_MIDL_WARNINGS
MIDL_WX_SWITCH=/WX
!else
MIDL_WX_SWITCH=
!endif

!INCLUDE makefile.plt

!ifndef MASTER_VERSION_FILE
!if "$(POCKETPC)" == ""
MASTER_VERSION_FILE = $(SDK_INC_PATH)\ntverp.h
!endif
DEFAULT_VERSION_FILE=1
!endif

#
#  IDL/RDL/TDL build rules.
#

!ifdef IDL_RULES
IDL_OUT_DIR =.
IDL_HDR_OUT_DIR =.
RDL_OUT_DIR =.
RDL_HDR_OUT_DIR =.
!endif

!ifndef LANGUAGE
LANGUAGE=usa
!endif

#
# define a simple macro that can be used for the object subdir in makefile.inc/sources files
#
O = $(_OBJ_DIR)\$(TARGET_DIRECTORY)

#
# Include the developer supplied file that defines the TARGETNAME, TARGETPATH,
# TARGETTYPE and SOURCES macros.  Make sure it defines them.
#

!if defined(USE_CAPK)
# Kernel profiling - icecap api's come from the kernel or from rtl\icecap.c when building the kernel/hal/ntdll
USE_ICECAP4=1
PERFLIBS=
C_DEFINES=$(C_DEFINES) /D_CAPKERN=1
ASM_DEFINES=$(ASM_DEFINES) /D_CAPKERN=1
!endif

!if defined(USE_ICECAP) || defined(USE_ICECAP4) || defined(USE_DLP)
! ifdef USE_ICECAP
PERFFLAGS=-Gh
PERFLIBS=$(SDK_LIB_PATH)\icap.lib
! else
!  ifdef USE_ICECAP4
PERFFLAGS=/fastcap
!  else # USE_DLP
PERFFLAGS=/dlp
!  endif
!  ifndef PERFLIBS
PERFLIBS=$(SDK_LIB_PATH)\icecap.lib
!  endif
! endif
! if $(FREEBUILD)
NTDEBUG=ntsdnodbg
! else
NTDEBUG=ntsd
! endif
NTDEBUGTYPE=windbg
NTBBT=1
!endif

LATEST_WIN32_WIN95_VERSION=0x0400
LATEST_WIN32_WCE_VERSION=0x0300

#
# Set versions correctly for NT4/2000/XP
# Default to XP
#
!if $(_NT_TARGET_VERSION) == 0x600     ## Windows Longhorn ##
LATEST_WIN32_IE_VERSION   =0x0605
LATEST_WIN32_WINNT_VERSION=0x0600
SUBSYSTEM_VERSION_CURRENT =4.10
SUBSYSTEM_VERSION_LATEST  =6.00
LINKER_APP_VERSION=6.0
LINKER_OS_VERSION=6.0
_NTDDI_VERSION=0x06000000

!elseif $(_NT_TARGET_VERSION) == 0x502     ## Windows .NET ##
# Server 2003 gold has _WIN32_IE=0x0602, and Server 2003 SP1 has _WIN32_IE=0x0603
LATEST_WIN32_IE_VERSION   =0x0603
LATEST_WIN32_WINNT_VERSION=0x0502
SUBSYSTEM_VERSION_CURRENT =4.10
SUBSYSTEM_VERSION_LATEST  =5.02
LINKER_APP_VERSION=5.2
LINKER_OS_VERSION=5.2
_NTDDI_VERSION=0x05020000

!elseif $(_NT_TARGET_VERSION) == 0x501     ## Windows XP   ##
# XP gold has _WIN32_IE=0x0600, XP SP1 has _WIN32_IE=0x0601, and XPSP2 has _WIN32_IE=0x0603
LATEST_WIN32_IE_VERSION   =0x0603
LATEST_WIN32_WINNT_VERSION=0x0501
SUBSYSTEM_VERSION_CURRENT=4.10
SUBSYSTEM_VERSION_LATEST  =5.01
LINKER_APP_VERSION=5.1
LINKER_OS_VERSION=5.1
_NTDDI_VERSION=0x05010000

!elseif $(_NT_TARGET_VERSION) == 0x500 ## Windows 2000 ##
LATEST_WIN32_IE_VERSION   =0x0501
LATEST_WIN32_WINNT_VERSION=0x0500
SUBSYSTEM_VERSION_CURRENT=4.10
SUBSYSTEM_VERSION_LATEST  =5.00
LINKER_APP_VERSION=5.0
LINKER_OS_VERSION=5.0
_NTDDI_VERSION=0x05000000

!elseif $(_NT_TARGET_VERSION) == 0x400 ## Windows NT 4 ##
LATEST_WIN32_IE_VERSION   =0x0200
LATEST_WIN32_WINNT_VERSION=0x0400
SUBSYSTEM_VERSION_CURRENT =4.00
SUBSYSTEM_VERSION_LATEST  =4.00
LINKER_APP_VERSION=4.0
LINKER_OS_VERSION=4.0
!else
!message NMAKE : Uxxxx: _NT_TARGET_VERSION value is unknown.  Update Makefile.def to understand the new version.
!endif # _NT_TARGET_VERSION

#
# Set Windows CE/PocketPC variables.
#

!if "$(POCKETPC)" != ""

! if "$(POCKETPC_EMULATION)" != ""
WINCE_IMAGE = -WINDOWSCE:EMULATION
! else
WINCE_IMAGE = -WINDOWSCE
! endif

CVTRES_PLATFORM_FLAGS = $(WINCE_IMAGE)

!endif

XDCMAKE_SOURCE_DIRS = $(O)

#
# Run miscfiles rules during both compile and link phases.  Sources file
# can override by setting this a value other than 0
#

MISCFILES_DURING_LINK=0

!if defined(ASMMETA_AUTOCOPY)
!undef ASMMETA_AUTOCOPY
!endif

!INCLUDE .\sources
SOURCES_USED=$(SOURCES_USED) .\sources

#
# Attempt to include the sources file from the target subdirectory.
#
!IF EXIST(.\$(TARGET_DIRECTORY)\sources)
! INCLUDE .\$(TARGET_DIRECTORY)\sources
SOURCES_USED=$(SOURCES_USED) .\$(TARGET_DIRECTORY)\sources
!ENDIF

!ifdef PASS1_LINK
MAKEDLL=1
!undef NOLINK
!endif

#
# This needs to be set after the URT_VER is read in from the soures
#
!if !defined(BUILD_ALLOW_MANAGED_CODE_WARNINGS) && !defined(MANAGED_VB) && "$(URT_VER)" != "1.0" && "$(URT_VER)" != "1.1"
MANAGED_WX_SWITCH=$(MANAGED_WX_SWITCH) /warnaserror-:618
!endif

#
# Attempt to include the sources file from the parent target subdirectory.
#

!IF EXIST(..\$(TARGET_DIRECTORY)\sources)
! INCLUDE ..\$(TARGET_DIRECTORY)\sources
SOURCES_USED=$(SOURCES_USED) ..\$(TARGET_DIRECTORY)\sources
!ENDIF

# Turn LTCG on for IA64 in lab01_n only.

!if $(IA64) && ( \
       "$(_BUILDBRANCH)" == "lab01_n" \
    || "$(_BUILDBRANCH)" == "Lab01_N" \
    || "$(_BUILDBRANCH)" == "lab01_n-vc" \
    || "$(_BUILDBRANCH_LOWERCASE)" == "lab01_n" \
    || "$(_BUILDBRANCH_LOWERCASE)" == "lab01_n-vc")
LINK_TIME_CODE_GENERATION=1
!endif

# Allow separate LTCG definitions loosely based on SKU.

!if defined(LTCG_SRV) || defined(LTCG_WKS) || defined(LTCG_SRVWKS)
LINK_TIME_CODE_GENERATION=1
!endif

# Avoid publishing ANONYMOUS (CIL) PCH objects to public.

!if defined(LINK_TIME_CODE_GENERATION) && defined(PASS1_PUBLISH) && "$(BUILD_PASS)" != "PASS0" && "$(BUILD_PASS)" != "PASS2" && !defined(NOLIB) && "$(TARGETTYPE)" != "DYNLINK" && "$(TARGETTYPE)" != "EXPORT_DRIVER"
NTNOPCH=1
!endif

# Use LTCG_NTNOPCH to force PCH off for LTCG.
# fatal error C1083: Cannot open compiler intermediate file:
!if defined(LINK_TIME_CODE_GENERATION) && defined(LTCG_NTNOPCH) && !defined(FORCENATIVEOBJECT)
NTNOPCH=1
!endif

# Force native code generation for managed code.
# error D2016 : '/clr' and '/GL' command-line options are incompatible.
!if (defined(MANAGED_CODE) || defined(MANAGED_VB) || defined(MANAGED_CXX))
FORCENATIVEOBJECT=1
!endif

# Allow alternate object directories.

!ifndef BUILD_ALT_DIR
BUILD_ALT_DIR=
! ifdef CHECKED_ALT_DIR
! if !$(FREEBUILD)
BUILD_ALT_DIR=d
!  endif
! endif
!endif

_OBJ_DIR = obj$(BUILD_ALT_DIR)

!IF defined(CMI_MANIFESTS) || defined(CMI_WOW64_MANIFESTS) 
!IF defined(CMI_MANIFESTS)
SOURCE_MANIFEST = $(O)\source_manifest.log
!ENDIF

!IF $(386)
!IF defined(CMI_WOW64_MANIFESTS)
WOW64_SOURCE_MANIFEST = $(O)\wow64_source_manifest.log
!ENDIF
!ENDIF

VERIFY_SOURCES=1

!ifndef MANIFEST_COMPILER_CMD
MANIFEST_COMPILER_CMD=cscript //nologo $(BASEDIR)\tools\ManifestCompiler.vbs $(BASEDIR)\tools\ManifestCompiler.xsl
!endif

!ENDIF

MAKEDIR_RELATIVE_TO_BASEDIR=$(MAKEDIR)
!if exist($(BASEDIR)\makedir_relative_to_basedirmk.inc)
!include $(BASEDIR)\makedir_relative_to_basedirmk.inc
!endif

# Generate strongname signing specifications if needed
SN_SIGN_DIR=strongnamesigning
SN_FILENAME_ROOT=$(MAKEDIR_RELATIVE_TO_BASEDIR:\=-)
SN_FILENAME_ROOT=$(SN_FILENAME_ROOT::=_)
SN_FILENAME_ROOT=$(SN_FILENAME_ROOT: =)
!if defined( SN_SIGN ) && defined( SN_SIGN_TARGET )
!message $(BUILD_ERROR_MSG) Only one of SN_SIGN and SN_SIGN_TARGET should currently be defined
!endif
!if defined( SN_SIGN )
SN_SIGN_SPEC=$(O)\$(SN_FILENAME_ROOT)-sn-req.xml
!endif
!if defined( SN_SIGN_TARGET )
SN_SIGN_SPEC=$(O)\$(SN_FILENAME_ROOT)-sn-targ-req.xml
!endif

#
# set up NO_BINPLACE early so everyone that wants to check this can check it
# Two reasons not to binplace:
# 1) since we're generating binary drops of this source there's no need to
# binplace the files.  The files should be binplaced from the binary_release
# directory.
# 2) there's nowhere to move the files to
#
!if defined(BINARY_PUBLISH) || defined(BINARY_PUBLISH_DIR) || !defined(_NTTREE)
NO_BINPLACE=1
!endif

!if ("$(TARGETTYPE)" == "NOTARGET" || "$(MAKEDLL)" != "" || "$(BUILD_PASS)" == "PASS2" || "$(BUILD_PASS)" == "PASSALL")
ONCE_IN_ANY_PASS=1
!else
ONCE_IN_ANY_PASS=0
!endif

!if defined(PROJECT_BUILDS_MANAGED_CODE)
!message $(BUILD_ERROR_MSG)   Do not define PROJECT_BUILDS_MANAGED_CODE.
!message $(BUILD_ERROR_MSG)   Instead define MANAGED_CODE (for C Sharp)
!message $(BUILD_ERROR_MSG)   or MANAGED_CXX or MANAGED_VB.
!endif
!if defined(MANAGED_CODE) || defined(MANAGED_CXX) || defined(MANAGED_VB)
PROJECT_BUILDS_MANAGED_CODE=1
!else
PROJECT_BUILDS_MANAGED_CODE=0
!endif

!if $(PROJECT_BUILDS_MANAGED_CODE) && !defined(MANAGED_CODE_ENABLED) && "$(BUILD_PRODUCT)" == "NT"
!  if $(ONCE_IN_ANY_PASS)
!    message $(BUILD_ERROR_MSG) Managed code is not enabled for $(_BUILDARCH), use {MANAGED_CODE_ENABLED} in your dirs file.
!  endif
DO_NOTHING_MANAGED_CODE_NOT_ENABLED=1
PROJECT_BUILDS_MANAGED_CODE=0
TARGETTYPE=NOTARGET
SOURCES=
!undef MANAGED_CODE
!undef MANAGED_CXX
!undef MANAGED_VB
!undef TARGETNAME
!undef GENERATE_NT_ASSEMBLY_INFO
!undef USE_ASMMETA
!undef ASSEMBLY_IDENTITY
!undef MANIFESTS
!endif


#
#  Managed code xml doc comments support
#
!if defined(BUILD_MANAGED_XML_DOCS)

!  if defined(MANAGED_CODE) || defined(MANAGED_CXX)
!    ifndef MANAGED_XML_DOCS_FILENAME
MANAGED_XML_DOCS_FILENAME = $(TARGETNAME).xml
!    endif
!    ifdef MANAGED_XML_DOCS_DIR
MANAGED_XML_DOCS_FILENAME = $(MANAGED_XML_DOCS_DIR)\$(MANAGED_XML_DOCS_FILENAME)
!    else
MANAGED_XML_DOCS_FILENAME = $(O)\$(MANAGED_XML_DOCS_FILENAME)
!    endif

USER_CS_FLAGS   = $(USER_CS_FLAGS) /doc:$(MANAGED_XML_DOCS_FILENAME)

#
# disable warning C4638: 'XML document comment: reference to unknown symbol'
#   because the current compiler implementation is buggy and warns spuriously
#
USER_C_FLAGS    = $(USER_C_FLAGS) /doc$(MAKEDIR)\$(O)/ /wd4638

!    if defined(MANAGED_CXX) && "$(BUILD_PASS)" == "PASS2"
XDCMAKE_SOURCE_ARGS=/Fs$(XDCMAKE_SOURCE_DIRS:;=\*.xdc /Fs)\*.xdc

$(MANAGED_XML_DOCS_FILENAME): $(XDCMAKE_SOURCE_DIRS:;=\*.xdc )\*.xdc
	xdcmake $(TARGETNAME) $(XDCMAKE_SOURCE_ARGS) /Fo$(MANAGED_XML_DOCS_FILENAME)

!    endif # MANAGED_CXX and PASS2

#
# Avalon will probably want to do something like (in their sources files):
#
#    # binplace in both sdk\doc\obj and in Avalon
#    MANAGED_XML_DOCS_BINPLACE_DESTS = sdk\doc\obj:Avalon
#
!    ifdef MANAGED_XML_DOCS_BINPLACE_DESTS
PASS2_BINPLACE=$(PASS2_BINPLACE) \
               -:DEST $(MANAGED_XML_DOCS_BINPLACE_DESTS) $(MANAGED_XML_DOCS_FILENAME)
!    endif
!  endif # ifdef MANAGED_CODE || MANAGED_CXX
!endif # defined (BUILD_MANAGED_XML_DOCS)


!if defined(COM_VISIBLE) && "$(COM_VISIBLE)" != "0" && "$(COM_VISIBLE)" != "1"
!message $(BUILD_ERROR_MSG) COM_VISIBLE must be 0 or 1 or not defined.
!endif

!if defined(COM_VISIBLE) && !$(PROJECT_BUILDS_MANAGED_CODE)
!message $(BUILD_ERROR_MSG) COM_VISIBLE can only be defined for managed code.
!endif

!if defined(ASSEMBLY_IN_MINWIN) && "$(ASSEMBLY_IN_MINWIN)" != "1" && "$(ASSEMBLY_IN_MINWIN)" != "0"
!message $(BUILD_ERROR_MSG) ASSEMBLY_IN_MINWIN must be 0 or 1 or not defined.
!endif

!if defined(USE_ASMMETA) && "$(USE_ASMMETA)" != "1" && "$(USE_ASMMETA)" != "0"
!message $(BUILD_ERROR_MSG) USE_ASMMETA must be 0 or 1 or not defined.
!endif

!if defined(USE_ASMMETA) && !$(PROJECT_BUILDS_MANAGED_CODE)
!message $(BUILD_ERROR_MSG) USE_ASMMETA can only be defined for managed code.
!endif

!if defined(ASMMETA_AUTOCOPY)
!  message $(BUILD_ERROR_MSG) ASMMETA_AUTOCOPY is only to be set on the command line, not in a sources file.
!  message $(BUILD_ERROR_MSG)   It does not do anything when set in sources and is not meant to.
!endif

!if defined(GENERATE_NT_ASSEMBLY_INFO) && "$(GENERATE_NT_ASSEMBLY_INFO)" != "1" && "$(GENERATE_NT_ASSEMBLY_INFO)" != "2" && "$(GENERATE_NT_ASSEMBLY_INFO)" != "0"
!message $(BUILD_ERROR_MSG)   GENERATE_NT_ASSEMBLY_INFO must be 0, 1, or 2 or not defined.
!endif

!if defined(PUBLISH_ASMMETA_TO_PUBLIC) && "$(PUBLISH_ASMMETA_TO_PUBLIC)" != "1" && "$(PUBLISH_ASMMETA_TO_PUBLIC)" != "0"
!message $(BUILD_ERROR_MSG) PUBLISH_ASMMETA_TO_PUBLIC must be 0 or 1 or not defined.
!endif

!if defined(PUBLISH_ASMMETA_TO_INTERNAL) && "$(PUBLISH_ASMMETA_TO_INTERNAL)" != "1" && "$(PUBLISH_ASMMETA_TO_INTERNAL)" != "0"
!message $(BUILD_ERROR_MSG) PUBLISH_ASMMETA_TO_INTERNAL must be 0 or 1 or not defined.
!endif

!if defined(PUBLISH_ASMMETA_TO_TEST) && "$(PUBLISH_ASMMETA_TO_TEST)" != "1" && "$(PUBLISH_ASMMETA_TO_TEST)" != "0"
!message $(BUILD_ERROR_MSG) PUBLISH_ASMMETA_TO_TEST must be 0 or 1 or not defined.
!endif

!if "$(PUBLISH_ASMMETA_TO_PUBLIC:0=)$(PUBLISH_ASMMETA_TO_INTERNAL:0=)$(PUBLISH_ASMMETA_TO_TEST:0=)" == "111" || \
    "$(PUBLISH_ASMMETA_TO_PUBLIC:0=)$(PUBLISH_ASMMETA_TO_INTERNAL:0=)$(PUBLISH_ASMMETA_TO_TEST:0=)" == "11"
!message $(BUILD_ERROR_MSG) Only one of PUBLISH_ASMMETA_TO_PUBLIC, PUBLISH_ASMMETA_TO_INTERNAL, PUBLISH_ASMMETA_TO_TEST can be 1.
!endif

!if ("$(PUBLISH_ASMMETA_TO_TEST)" == "1" || \
    "$(PUBLISH_ASMMETA_TO_PUBLIC)" == "1" || \
    "$(PUBLISH_ASMMETA_TO_INTERNAL)" == "1") && \
    "$(PUBLISH_REF_PATH)" != ""
# People do this and it means to publish to PUBLISH_REF_PATH.
# Multimedia is down so allow it for now.
# !message $(BUILD_ERROR_MSG) Do not specify PUBLISH_ASMMETA_TO_PUBLIC/INTERNAL/TEST=1 and PUBLISH_REF_PATH.
!endif

!if defined(ASSEMBLY_IDENTITY) && "$(ASSEMBLY_IDENTITY)" == ""
!  message $(BUILD_ERROR_MSG) If ASSEMBLY_IDENTITY is defined, it must be non-empty.
!endif

!if defined(ASSEMBLY_MISCFILES) && "$(ASSEMBLY_MISCFILES)" == ""
!  message $(BUILD_ERROR_MSG) If ASSEMBLY_MISCFILES is defined, it must be non-empty.
!endif

!if defined(ASSEMBLY_MISCFILES) && !defined(ASSEMBLY_IDENTITY)
!  message $(BUILD_ERROR_MSG) If ASSEMBLY_MISCFILES is defined, ASSEMBLY_IDENTITY must also be defined.
!endif

!if defined(SXS_NO_BINPLACE) && "$(SXS_NO_BINPLACE)" != "1"
!message $(BUILD_ERROR_MSG) SXS_NO_BINPLACE must be 1 or not defined.
!endif

!if defined(RUN_GENMAN)
!message $(BUILD_ERROR_MSG) RUN_GENMAN is for internal purposes only and should not be defined in your sources file.
!endif

!if defined(OUTPUT_MANIFEST)
!message $(BUILD_ERROR_MSG) OUTPUT_MANIFEST is for internal purposes only and should not be defined in your sources file.
!endif

!if defined(MAKEIMAGE_CMD)
!message $(BUILD_WARNING_MSG) MAKEIMAGE_CMD was for internal purposes only and should not be defined in your sources file.
!endif

!if defined(ALLOW_DOLLAR_LPAREN_BUILD_DOT_IN_OUTPUT_XML) && "$(ALLOW_DOLLAR_LPAREN_BUILD_DOT_IN_OUTPUT_XML)" != "1"
!message $(BUILD_ERROR_MSG) ALLOW_DOLLAR_LPAREN_BUILD_DOT_IN_OUTPUT_XML must be 1 or not defined but it is $(ALLOW_DOLLAR_LPAREN_BUILD_DOT_IN_OUTPUT_XML).
!endif

!if defined(DO_MERGE_MANIFESTS)
!message $(BUILD_ERROR_MSG) DO_MERGE_MANIFESTS is for internal purposes only and should not be defined in your sources file.
!endif

!if defined(DO_REPLACE_STRINGS_IN_MANIFESTS)
!message $(BUILD_ERROR_MSG) DO_REPLACE_STRINGS_IN_MANIFESTS is for internal purposes only and should not be defined in your sources file.
!endif

!if defined(DO_BINPLACE_MANIFEST)
!message $(BUILD_ERROR_MSG) DO_BINPLACE_MANIFEST is for internal purposes only and should not be defined in your sources file.
!endif

!if defined(DO_MAKEIMAGE)
!message $(BUILD_ERROR_MSG) DO_MAKEIMAGE is for internal purposes only and should not be defined in your sources file.
!endif

!if defined(DO_INFTEST)
!message $(BUILD_ERROR_MSG) DO_INFTEST is for internal purposes only and should not be defined in your sources file.
!endif

!if defined(MANIFESTS) || defined(INSTRUMENTATION_MANIFEST)
MANIFESTS=$(MANIFESTS) $(INSTRUMENTATION_MANIFEST)
!endif

!if !defined(USE_ASMMETA)
USE_ASMMETA=0
!endif

!if defined(ASSEMBLY_IDENTITY)
!if !exist($(O)\_asmid.inc) && !defined(_MAKING_ASMID_INC)
!if [nmake -nologo -f $(NTMAKEENV)\makefile.def _MAKING_ASMID_INC=1 $(O)\_asmid.inc]
!endif
!endif
!if !defined(_MAKING_ASMID_INC)
!include $(O)\_asmid.inc
!endif
#
# support multiple versions of idtool.exe:
#  PROCESSOR_ARCHITECTURE vs. PROCESSORARCHITECTURE
#  PUBLIC_KEY_TOKEN vs. PUBLICKEYTOKEN
#
!if defined(ASSEMBLY_IDENTITY_PUBLICKEYTOKEN) && !defined(ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN)
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=$(ASSEMBLY_IDENTITY_PUBLICKEYTOKEN)
!endif
!if !defined(ASSEMBLY_IDENTITY_PUBLICKEYTOKEN) && defined(ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN)
ASSEMBLY_IDENTITY_PUBLICKEYTOKEN=$(ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN)
!endif
!if defined(ASSEMBLY_IDENTITY_PROCESSORARCHITECTURE) && !defined(ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE)
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=$(ASSEMBLY_IDENTITY_PROCESSORARCHITECTURE)
!endif
!if !defined(ASSEMBLY_IDENTITY_PROCESSORARCHITECTURE) && defined(ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE)
ASSEMBLY_IDENTITY_PROCESSORARCHITECTURE=$(ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE)
!endif
!endif

!if defined(ASSEMBLY_IDENTITY) && defined(_NTTREE) && !defined(NO_BINPLACE) && defined(ASSEMBLY_IDENTITY_KEY_FORM)
_NTTREE_IDENTITIES_ASSEMBLY_KEY_FORM_TXT=$(_NTTREE)\identities\$(ASSEMBLY_IDENTITY_KEY_FORM).txt
!endif

!if !defined(SXS_NO_BINPLACE) && defined(ASSEMBLY_IDENTITY)
SXS_NO_BINPLACE=0
!endif

!if $(PROJECT_BUILDS_MANAGED_CODE) && defined(ASSEMBLY_IDENTITY)
RUN_GENMAN=1
!endif

!if "$(MANIFESTS)" != "" && "$(ASSEMBLY_IDENTITY)" == ""
!message $(BUILD_ERROR_MSG) If you define MANIFESTS, you must define ASSEMBLY_IDENTITY or ASSEMBLY_IDENTITY_AUTOMATIC.
!endif

!if "$(MANIFESTS)" != "" || defined(ASSEMBLY_IDENTITY)
OUTPUT_MANIFEST=$(TARGETPATH)\$(TARGET_DIRECTORY)\$(ASSEMBLY_IDENTITY_NAME).manifest
OUTPUT_MANIFEST2=$(TARGETPATH)\$(TARGET_DIRECTORY)\$(ASSEMBLY_IDENTITY_KEY_FORM).manifest
!endif

#
# The below support for checked in binaries is going to change a lot.
#
#
# Support installing checked in managed binaries and binaries produced by tlbimp.exe.
#
!if "$(TARGETTYPE)" == "NOTARGET" && defined(ASSEMBLY_IDENTITY) # {

OUTPUT_MANIFEST=$(TARGETPATH)\$(TARGET_DIRECTORY)\$(ASSEMBLY_IDENTITY_NAME).manifest
OUTPUT_MANIFEST2=$(TARGETPATH)\$(TARGET_DIRECTORY)\$(ASSEMBLY_IDENTITY_KEY_FORM).manifest

RUN_GENMAN=1

!if !defined(GENMAN_INPUT) # {

GENMAN_INPUT1=$(TARGET_DIRECTORY)\$(TARGETNAME).metadata_dll
GENMAN_INPUT2=$(TARGET_DIRECTORY)\$(TARGETNAME).metadata_exe
GENMAN_INPUT3=$(TARGET_DIRECTORY)\$(TARGETNAME).dll
GENMAN_INPUT4=$(TARGET_DIRECTORY)\$(TARGETNAME).exe

#
# $(ASSEMBLY_IDENTITY_KEY_FORM).manifest would be a checked in "finished" manifest.
# manifest "snippets" would be specified in the MANIFESTS variable and would not be named $(ASSEMBLY_IDENTITY_KEY_FORM).manifest.
#
!if exist($(ASSEMBLY_IDENTITY_KEY_FORM).manifest) # {
RUN_GENMAN=0
!elseif exist($(TARGET_DIRECTORY)\$(ASSEMBLY_IDENTITY_KEY_FORM).manifest)
RUN_GENMAN=0
!elseif exist($(GENMAN_INPUT1))
GENMAN_INPUT=$(GENMAN_INPUT1)
!elseif exist($(GENMAN_INPUT2))
GENMAN_INPUT=$(GENMAN_INPUT2)
!elseif exist($(GENMAN_INPUT3))
GENMAN_INPUT=$(GENMAN_INPUT3)
!elseif exist($(GENMAN_INPUT4))
GENMAN_INPUT=$(GENMAN_INPUT4)
!else
RUN_GENMAN=0
!endif # }
!endif # }
!endif # }

#
# TARGEXT is .lib in pass1 building PROGLIB, DYNLINK
# but LINK_TARGETEXT is not.
#
# TBD: The logic for TARGETEXT should move up to here and provide this.
# This is just a small subset.
#
# EXPORT_DRIVER DRIVER MINIPORT DYNLINK LIBRARY DRIVER_LIBRARY..
#
!if "$(TARGETEXT)" != ""
LINK_TARGETEXT=$(TARGETEXT)
!elseif "$(TARGETTYPE)" == "PROGRAM" || "$(TARGETTYPE)" == "PROGLIB"
LINK_TARGETEXT=exe
!else
LINK_TARGETEXT=dll
!endif


#
# Deal with referencing public keys from the global build initialization data
# generated from the rather misnamed "versions.xml" into various includable forms
!if defined( USE_PUBLIC_KEY_REFERENCES )

!if defined(PROJECT_BUILDS_MANAGED_CODE)
REFERENCES=$(REFERENCES); \
 $(SDK_REF_PATH)\Microsoft.Windows.Identity.dll 
!else
!message $(BUILD_ERROR_MSG) USE_PUBLIC_KEY_REFERENCES only supports managed code
!endif

!endif


#
# Where did the name ".asmmeta" come from?
#   ".asm" == "assembly source code", not just x86, ia64, amd64, etc., but also il.
#   ".meta" == "metadata only .dll"
#     => ".asmmeta" == "assembly source code to metadata only .dll"
#
# ".meta" is also sometimes known as "dehydrated .dll" or "dehydrated assembly".
# (assembly has another meaning -- "unit of deployment", ".dll", "self described .dll", ".dll + .xml manifest")
#
# For our purposes, we drop the term ".meta" and instead refer to "metadata only .dlls" (or .exes).
#
# Asmmeta.exe is basically a stripped down ildasm.exe.
# It removes all code (leaving "ret" instructions) but leaves in all the declarations, all the metadata.
#
# Asmmeta.exe's output includes version numbers.
#
# Version numbers must be changable fairly rapidly, must be changed rapidly, else the ability
#   to change them will greatly decrease.
#
# So version numbers must be removed from asmmeta.exe's output, and put back in right before running ilasm.exe.
#
# o\foo.asmmeta_ver_pass0 has versions; it is input to ilasm.exe in pass0.
# o\foo.asmmeta_ver_pass2 has versions; it is the output of asmmeta.exe in pass2.
# Given a steady state of no code changes, the above two files are identical.
# .\foo.asmmeta lacks versions; it is the checked in textual "source" file (though not hand written and not very readable).
#
# foo.cs => o\foo.dll => o\asmmeta_ver_pass2 => comparison/copy => .\asmmeta => o\asmmeta_ver_pass0 => o\foo.metadata_dll
#
# as long as foo.cs is unchanged:
#   pass0: .\asmmeta => o\asmmeta_ver_pass0 => o\foo.metadata_dll
#   pass2: foo.cs => o\foo.dll => o\asmmeta_ver_pass2 => comparison/(no)copy => stop
#
# if foo.cs is changed, then:
#   pass0: .\asmmeta => o\asmmeta_ver_pass0 => o\foo.metadata_dll
#   pass2: foo.cs => o\foo.dll => o\asmmeta_ver_pass2 => comparison/copy => developer must build again
#   next pass0 => .\asmmeta => o\asmmeta_ver_pass0 => o\foo.metadata_dll
#
!if $(USE_ASMMETA)

PUBLISHED_BINARY_METADATA_EXTENSION=$(LINK_TARGETEXT)

#
# Allow the code .dll and the metadata only .dll to live in the same
# $(O) directory by giving the metadata only .dll a different name (extension).
#
O_BINARY_METADATA_EXTENSION=metadata_$(PUBLISHED_BINARY_METADATA_EXTENSION)

!if !defined(SOURCE_ASMMETA)
SOURCE_ASMMETA=$(TARGETNAME).asmmeta
!endif

!if !defined(O_BINARY_METADATA_DIRECTORY)
O_BINARY_METADATA_DIRECTORY=$(O)
!endif

!if exist($(SOURCE_ASMMETA))
O_BINARY_METADATA=$(O_BINARY_METADATA_DIRECTORY)\$(TARGETNAME).$(O_BINARY_METADATA_EXTENSION)
!endif
O_ASMMETA_OUTPUT=$(O)\$(TARGETNAME).asmmeta_ver_pass2
O_ASMMETA=$(O)\$(TARGETNAME).asmmeta

!if "$(PUBLISH_ASMMETA_TO_TEST)" == "1" || \
    "$(PUBLISH_ASMMETA_TO_PUBLIC)" == "1" || \
    "$(PUBLISH_ASMMETA_TO_INTERNAL)" == "1" || \
    "$(PUBLISH_REF_PATH)" != ""

!if "$(PUBLISH_REF_PATH)" == ""
!if "$(PUBLISH_ASMMETA_TO_INTERNAL)" == "1"
PUBLISH_REF_PATH=$(PROJECT_REF_PATH)
!elseif "$(PUBLISH_ASMMETA_TO_PUBLIC)" == "1"
PUBLISH_REF_PATH=$(SDK_REF_PATH)
!elseif "$(PUBLISH_ASMMETA_TO_TEST)" == "1"
PUBLISH_REF_PATH=$(BASEDIR)\public\test
!endif
!endif

!if defined(O_BINARY_METADATA)
PASS0_PUBLISH=$(PASS0_PUBLISH) {$(O_BINARY_METADATA)=$(PUBLISH_REF_PATH)\$(TARGETNAME).$(PUBLISHED_BINARY_METADATA_EXTENSION)}
!endif

!if defined(O_ASMMETA_OUTPUT)
PASS2_PUBLISH=$(PASS2_PUBLISH) {$(O_ASMMETA_OUTPUT)=$(PUBLISH_REF_PATH)\$(TARGETNAME).asmmeta}
!endif

!endif # PUBLISH_ASMMETA_TO_PUBLIC || PUBLISH_ASMMETA_TO_INTERNAL || PUBLISH_REF_PATH

!if !defined(ASMMETA_INPUT)
ASMMETA_INPUT=$(TARGET)
!endif # ASMMETA_INPUT

!endif # USE_ASMMETA

#
# This doesn't work because asmmeta.js removes various version-unstable attributes.
#
# VERIFY_METADATA=echo cl /EP _verifying_metadata_with_asmmeta.exe && (asmmeta.exe /verify $(TARGET) $(O_BINARY_METADATA) >nul || @echo $(BUILD_WARNING_MSG) $(TARGET) and $(O_BINARY_METADATA) vary, you just made an interface change? If not, seek help.))
#

!if defined(OUTPUT_MANIFEST) # {

!if "$(RUN_GENMAN)" == "1" # {

#
# Maybe in the future "REFERENCES" becomes renamed to DEPENDENT_ASSEMBLIES?
#
!if "$(REFERENCES)" != ""
SLASH_DEPENDENT_ASSEMBLIES=/dependentAssemblies:$(REFERENCES)
SLASH_DEPENDENT_ASSEMBLIES=$(SLASH_DEPENDENT_ASSEMBLIES: =)
!else
SLASH_DEPENDENT_ASSEMBLIES=
!endif

!if !defined(GENMAN_INPUT)
GENMAN_INPUT=$(TARGET)
!endif

MANIFEST_TEMP1=$(OUTPUT_MANIFEST)_temp1

!else

MANIFEST_TEMP1=

!endif # }
!endif # } OUTPUT_MANIFEST

MANIFEST_STRING_REPLACEMENTS1=$(NTMAKENV)\manifest_string_replacements.$(BUILD_PRODUCT).xml
MANIFEST_STRING_REPLACEMENTS2=$(NTMAKENV)\manifest_string_replacements.xml
!if defined(BASE_LIB_PATH)
MANIFEST_STRING_REPLACEMENTS3=$(BASE_LIB_PATH)\manifest_string_replacements.$(BUILD_PRODUCT).xml
MANIFEST_STRING_REPLACEMENTS4=$(BASE_LIB_PATH)\manifest_string_replacements.xml
!endif

!if     "$(MANIFEST_STRING_REPLACEMENTS1)" != "" && exist($(MANIFEST_STRING_REPLACEMENTS1))
MANIFEST_STRING_REPLACEMENTS=$(MANIFEST_STRING_REPLACEMENTS) $(MANIFEST_STRING_REPLACEMENTS1)
!elseif "$(MANIFEST_STRING_REPLACEMENTS2)" != "" && exist($(MANIFEST_STRING_REPLACEMENTS2))
MANIFEST_STRING_REPLACEMENTS=$(MANIFEST_STRING_REPLACEMENTS) $(MANIFEST_STRING_REPLACEMENTS2)
!elseif "$(MANIFEST_STRING_REPLACEMENTS3)" != "" && exist($(MANIFEST_STRING_REPLACEMENTS3))
MANIFEST_STRING_REPLACEMENTS=$(MANIFEST_STRING_REPLACEMENTS) $(MANIFEST_STRING_REPLACEMENTS3)
!elseif "$(MANIFEST_STRING_REPLACEMENTS4)" != "" && exist($(MANIFEST_STRING_REPLACEMENTS4))
MANIFEST_STRING_REPLACEMENTS=$(MANIFEST_STRING_REPLACEMENTS) $(MANIFEST_STRING_REPLACEMENTS4)
!endif

# cloned from CMI's MANIFEST_BUILD_TYPE
!if $(FREEBUILD)
FUSION_MANIFEST_BUILD_TYPE=release
!else
FUSION_MANIFEST_BUILD_TYPE=debug
!endif

!if defined(OUTPUT_MANIFEST) || defined(MANIFESTS) # {

!if !defined(NO_GENERATED_STRING_REPLACEMENTS_XML)
MANIFEST_STRING_REPLACEMENTS=$(MANIFEST_STRING_REPLACEMENTS) $(O)\_generated_string_replacements.xml
!endif

DO_MERGE_MANIFESTS=1

!if !defined(NO_BINPLACE) && "$(BINPLACE_LOG)" != ""

DO_BINPLACE_MANIFEST=1

!endif

!endif # }

!if defined(ASSEMBLY_IDENTITY) && "$(BUILD_PASS)" != "PASS0" && "$(BUILD_PRODUCT)" == "NT"

# SKIP_ASSEMBLY_VERIFICATION no longer does anything.
!if defined(SKIP_ASSEMBLY_VERIFICATION) && "$(SKIP_ASSEMBLY_VERIFICATION)" != "1"
!message $(BUILD_ERROR_MSG) SKIP_ASSEMBLY_VERIFICATION must be 1 or not defined.
#!message $(BUILD_WARNING_MSG) SKIP_ASSEMBLY_VERIFICATION no longer does anything.
!endif

!if "$(BUILD_MACHINE_TAG)" != "" && "$(VER_PRODUCTVERSION_STR)" != ""

DO_MAKEIMAGE=1
DO_INFTEST=1

!endif
!endif

#
# This presently doesn't work.
#
!if "$(BUILD_PRODUCT)" != "NT"
!undef OUTPUT_MANIFEST
DO_REPLACE_STRINGS_IN_MANIFESTS=0
DO_BINPLACE_MANIFEST=0
DO_MAKEIMAGE=0
DO_INFTEST=0
!endif

!if "$(BUILD_COMPLUS_VERSION)" == ""
DO_MAKEIMAGE=0
DO_INFTEST=0
!endif

#
# Temporary workaround -- makeimage.exe fails otherwise.
#
!if "$(ASSEMBLY_MISCFILES)" != ""
DO_MAKEIMAGE=0
DO_INFTEST=0
!endif

#
# SideBySide (SXS) Build
#
# Step by Step instructions
#
# For building a monolithic application, foo.ext (where .ext is usually .exe but for example .scr).
# For building an application that hosts arbitrary (3rd party) code.
# For building a single file component like comctl32.dll.
# For building a multiple file component.
#
# Reference
#
# An assembly contains a manifest and one or more files, usually .dlls.
# The manifest can be in a resource in one of the files, or it can be in a seperate
#   .manifest file. For purposes of fitting on an 8.3 CD, .man is allowed.
#   For preprocessing, the source file can be .manifest-src.
# Build.exe is generally limited to building one .dll per directory, so
#   you can be building files for an assembly without building a manifest.
#
# To build/binplace a manifest:
#
#  SXS_MANIFEST required
#    This is the source file that contains your manifest.
#    It must end in .manifest or .manifest-src.
#    It is always preprocessed. Available macros include:
#      SXS_ASSEMBLY_NAME
#      SXS_ASSEMBLY_VERSION
#      SXS_ASSEMBLY_LANGUAGE
#      SXS_PROCESSOR_ARCHITECTURE
#
#  SXS_MANIFEST_IN_RESOURCES optional
#    This is defined or not, so you just say
#      SXS_MANIFEST_IN_RESOURCES=
#    or don't say anything.
#
#  SXS_ASSEMBLY_NAME and/or SXS_SHORT_ASSEMBLY_NAME required
#    One can be generated from the other.
#    SXS_SHORT_ASSEMBLY_NAME is used where 8.3 limits apply, like on the product CD.
#    Both of these macros can be hierarchical, using dot, dash, or underscore to seperate
#    elements. SXS_SHORT_ASSEMBLY_NAME should actually only contain 8 character elements.
#
#  SXS_ASSEMBLY_VERSION optional, defaults to 5.1.
#    We append .0.0 to this.
#
#  SXS_ASSEMBLY_LANGUAGE or SXS_ASSEMBLY_LANGUAGE_INDEPENDENT required
#    SXS_ASSEMBLY_LANGUAGE_INDEPENDENT is defined or not.
#    SXS_ASSEMBLY_LANGUAGE is four digits like
#      0409 for English US
#      0009 for English
#      0000 for language independent
#    We should make this easier as is done for resources (LANGUAGE => RCCODEPAGE), but for now we don't.
#
# To build/binplace a file into an assembly, a subset of the information
# needed for manifests is needed:
#
#  SXS_ASSEMBLY_NAME and/or SXS_SHORT_ASSEMBLY_NAME
#  SXS_ASSEMBLY_VERSION
#  SXS_ASSEMBLY_LANGUAGE or SXS_ASSEMBLY_LANGUAGE_INDEPENDENT
#
# There are restrictions on the values of these macros and not all restrictions
# are currently enforced by the build. Enforcements that are present are done
# ifdef VERIFY_SOURCES in verify.src.
#

SXS_BUILD_ERROR_MSG=$(BUILD_ERROR_MSG):'SXS_BUILD':
SXS_MERGE_MODULE_ERROR_MSG=$(BUILD_ERROR_MSG):'SXS_MERGE_MODULE_GENERATION' :

# managed assembly
!if defined(ASSEMBLY_IDENTITY) && \
    (defined(SXS_MANIFEST) \
    || defined(SXS_BINPLACE_ALSO_ROOT) \
    || defined(SXS_ASSEMBLY_NAME) \
    || defined(SXS_ASSEMBLY_VERSION) \
    || defined(SXS_ASSEMBLY_LANGUAGE_INDEPENDENT) \
    || defined(SXS_ASSEMBLY_LANGUAGE)) #{
!message $(SXS_BUILD_ERROR_MSG) If ASSEMBLY_IDENTITY is set, no SXS_ macros are allowed.
!endif #}

!if defined(SXS_MANIFEST) \
 || defined(SXS_BINPLACE_ALSO_ROOT) \
 || defined(SXS_ASSEMBLY_NAME) \
 || defined(SXS_ASSEMBLY_VERSION) \
 || defined(SXS_ASSEMBLY_LANGUAGE_INDEPENDENT) \
 || defined(SXS_ASSEMBLY_LANGUAGE)
VERIFY_SOURCES=1
!endif

!if "$(ALT_PROJECT)" == "WOW6432" || "$(ALT_PROJECT_TARGET)" == "WOW6432"
SXS_PDB_WOW6432_W_PREFIX=w
SXS_LOG_WOWBINS_W_ASMS_PREFIX=w
SXS_LOG_BINPLACE_WOW6432_PREFIX=wow6432^\
SXS_WOW6432=1
!endif

#
# There's two meta-modes of operation in SXS - Application manifest mode and component manifest mode.
# Depending on what you have defined in your sources file, you can simplify all of the build process
# down to a very minimal set of commands in your sources files and still get Fusionization goodness.
#
# Example:
#
# SXS_APPLICATION_MANIFEST=MyAppManifest.manifest
#
# (or)
#
# SXS_COMPONENT_MANIFEST=MyComponentManifest.manifest
#
# See the code below for what gets defined based on each - it's more or less the defaults, but
# explicitly spelled out.
#

# No fair using either app and component manifest, and specifying sxs_manifest, or using both by accident
!if defined(SXS_APPLICATION_MANIFEST) && defined(SXS_COMPONENT_MANIFEST)
!message $(SXS_BUILD_ERROR_MSG) You can have only one of SXS_APPLICATION_MANIFEST or SXS_COMPONENT_MANIFEST, not both
!elseif defined(SXS_MANIFEST) && ( defined(SXS_APPLICATION_MANIFEST) || defined(SXS_COMPONENT_MANIFEST) )
!message $(SXS_BUILD_ERROR_MSG) When using SXS_APPLICATION_MANIFEST or SXS_COMPONENT_MANIFEST, do not specify SXS_MANIFEST
!endif

# Applications get the following defaults that are not defaulted later:
# - SXS_ASSEMBLY_LANGUAGE=SXS_ASSEMBLY_LANGUAGE_INDEPENDENT
# - SXS_ASSEMBLY_NAME=Microsoft.Windows.$(PROJECT).$(TARGETNAME)
# - Manifest in resources
!if defined(SXS_APPLICATION_MANIFEST)
SXS_MANIFEST=$(SXS_APPLICATION_MANIFEST)
SXS_MANIFEST_IN_RESOURCES=1
SXS_NO_BINPLACE=1
!if !defined(SXS_ASSEMBLY_NAME)
SXS_ASSEMBLY_NAME=Microsoft.Windows.$(_PROJECT_).$(TARGETNAME)
!endif
!if !defined(SXS_ASSEMBLY_LANGUAGE)
SXS_ASSEMBLY_LANGUAGE_INDEPENDENT=1
!endif

# Components get the following defaulted:
# - SXS_ASSEMBLY_NAME=Microsoft.Windows.$(PROJECT).$(TARGETNAME)
# - Language independent
!elseif defined(SXS_COMPONENT_MANIFEST)
SXS_MANIFEST=$(SXS_COMPONENT_MANIFEST)
!if !defined(SXS_ASSEMBLY_NAME)
SXS_ASSEMBLY_NAME=Microsoft.Windows.$(_PROJECT_).$(TARGETNAME)
!endif
!if !defined(SXS_ASSEMBLY_LANGUAGE)
SXS_ASSEMBLY_LANGUAGE_INDEPENDENT=1
!endif

!endif

!ifdef VERIFY_SOURCES
!include $(NTMAKEENV)\verify.src
!endif

!if defined(ISOLATION_AWARE_ENABLED)
C_DEFINES=$(C_DEFINES) -DISOLATION_AWARE_ENABLED=1
!endif

!if defined(ISOLATION_AWARE_VERSION)
C_DEFINES=$(C_DEFINES) -DISOLATION_AWARE_VERSION=$(ISOLATION_AWARE_VERSION)
!endif

#
# NO_BINPLACE implies SXS_NO_BINPLACE
#
!if defined(NO_BINPLACE) && !defined(SXS_NO_BINPLACE)
SXS_NO_BINPLACE=1
!endif

#
# Building a native .exe implies SXS_NO_BINPLACE.
#
!if "$(TARGETTYPE)" == "PROGRAM" && !$(PROJECT_BUILDS_MANAGED_CODE) && !defined(SXS_NO_BINPLACE)
SXS_NO_BINPLACE=1
!endif

!if !defined(SXS_NO_BINPLACE)
SXS_NO_BINPLACE=0
!endif

#
# We can build SXS_ASSEMBLY_NAME out of SXS_SHORT_ASSEMBLY_NAME
# and vice versa.
#

!if !defined(SXS_ASSEMBLY_NAME) && defined(SXS_SHORT_ASSEMBLY_NAME)
SXS_ASSEMBLY_NAME=$(SXS_SHORT_ASSEMBLY_NAME)
!endif

!if !defined(SXS_SHORT_ASSEMBLY_NAME) && defined(SXS_ASSEMBLY_NAME)
SXS_SHORT_ASSEMBLY_NAME=$(SXS_ASSEMBLY_NAME)
!endif

#
# Support the idea of a hierarchical 8.3 name, besides that this
# transform might be applied after the preceding assignment.
#
# eg: msft-vcrtl => msft\vcrtl
#

# Turn hierarchical names using [-._ ] as the element divider
# into hierarchical file system names. (Note that _ and . are not
# currently allowed in assembly names.)
SXS_SHORT_ASSEMBLY_NAME=$(SXS_SHORT_ASSEMBLY_NAME:-=\)
SXS_SHORT_ASSEMBLY_NAME=$(SXS_SHORT_ASSEMBLY_NAME:_=\)
SXS_SHORT_ASSEMBLY_NAME=$(SXS_SHORT_ASSEMBLY_NAME:.=\)
SXS_SHORT_ASSEMBLY_NAME=$(SXS_SHORT_ASSEMBLY_NAME: =\)

# Shorten one special name that is likely to appear in long assembly names.
SXS_SHORT_ASSEMBLY_NAME=$(SXS_SHORT_ASSEMBLY_NAME:Microsoft=Msft)
SXS_SHORT_ASSEMBLY_NAME=$(SXS_SHORT_ASSEMBLY_NAME:microsoft=msft)

!if defined(SXS_MANIFEST_IN_RESOURCES) && !defined(SXS_MANIFEST)
!message $(SXS_BUILD_ERROR_MSG) You must specify SXS_MANIFEST if you specify SXS_MANIFEST_IN_RESOURCES.
!endif

!if defined(SXS_ASSEMBLY_VERSION) && !defined(SXS_ASSEMBLY_NAME)
!message $(SXS_BUILD_ERROR_MSG) You may not specify SXS_ASSEMBLY_VERSION without SXS_ASSEMBLY_NAME or SXS_SHORT_ASSEMBLY_NAME.
!endif

!if (defined(SXS_ASSEMBLY_LANGUAGE) || defined(SXS_ASSEMBLY_LANGUAGE_INDEPENDENT)) && !defined(SXS_ASSEMBLY_NAME)
!message $(SXS_BUILD_ERROR_MSG) You may not specify SXS_ASSEMBLY_LANGUAGE or SXS_ASSEMBLY_LANGUAGE_INDEPENDENT without SXS_ASSEMBLY_NAME or SXS_SHORT_ASSEMBLY_NAME.
!endif

!if defined(SXS_BINPLACE_ALSO_ROOT) && !defined(SXS_ASSEMBLY_NAME)
!message $(SXS_BUILD_ERROR_MSG) You may not specify SXS_BINPLACE_ALSO_ROOT without SXS_ASSEMBLY_NAME or SXS_SHORT_ASSEMBLY_NAME.
!endif

!if defined(MANAGED_CXX)
# Managed CXX implies /EHsc (since that's the model managed code uses)
USE_NATIVE_EH=1
!if !$(FREEBUILD) && !defined(NO_DEBUG_ASSEMBLY)
LINKER_FLAGS=$(LINKER_FLAGS) /AssemblyDebug
!endif

!if "$(REFERENCE_PATH)" != ""
REFERENCE_PATH=$(REFERENCE_PATH: =)
USER_C_FLAGS=$(USER_C_FLAGS) -AI$(REFERENCE_PATH:;= -AI)
!endif

!endif

!if "$(BINPLACE_LOG)" != ""
BUILD_LOGS=$(BINPLACE_LOG)\..
!if [-mkdir $(BUILD_LOGS) >nul 2>&1]
!endif
!endif

!if $(ONCE_IN_ANY_PASS) && defined(BUILD_LOGS) && defined(ASSOCIATED_OCINF)
!if [echo %cd% $(ASSEMBLY_IDENTITY) $(ASSOCIATED_OCINF) >> $(BUILD_LOGS)\associated_infs_$(COMPUTERNAME).txt]
!endif
!endif

!if defined(ASSEMBLY_IDENTITY) && !$(SXS_NO_BINPLACE) # {
!if "$(BUILD_PRODUCT)" == "NT" && "$(BINPLACE_TO_COMPONENT_STORE)" != "0" && !defined(NO_BINPLACE)
ASSEMBLY_BINPLACE_DEST=components\$(ASSEMBLY_IDENTITY_KEY_FORM)
!endif
!elseif defined(SXS_ASSEMBLY_NAME) # } {
#
# SXS_ASSEMBLY_VERSION may only contain dots and digits.
# Removing them should leave nothing.
#
SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS=$(SXS_ASSEMBLY_VERSION)
SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS=$(SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS:.=)
SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS=$(SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS:0=)
SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS=$(SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS:1=)
SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS=$(SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS:2=)
SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS=$(SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS:3=)
SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS=$(SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS:4=)
SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS=$(SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS:5=)
SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS=$(SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS:6=)
SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS=$(SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS:7=)
SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS=$(SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS:8=)
SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS=$(SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS:9=)
!if "$(SXS_CHECK_ASSEMBLY_VERSION_CHARACTERS)" != ""
!message $(SXS_BUILD_ERROR_MSG) SXS_ASSEMBLY_VERSION ($(SXS_ASSEMBLY_VERSION)) may only contain dots and digits.
!endif

#
# ASSERT(SXS_ASSEMBLY_LANGUAGE xor SXS_ASSEMBLY_LANGUAGE_INDEPENDENT)
#
!if    (!defined(SXS_ASSEMBLY_LANGUAGE) && !defined(SXS_ASSEMBLY_LANGUAGE_INDEPENDENT)) \
|| ( defined(SXS_ASSEMBLY_LANGUAGE) &&  defined(SXS_ASSEMBLY_LANGUAGE_INDEPENDENT))
!message $(SXS_BUILD_ERROR_MSG) Must specify SXS_ASSEMBLY_LANGUAGE or SXS_ASSEMBLY_LANGUAGE_INDEPENDENT, not both.
!endif

#
# Derive from SXS_ASSEMBLY_LANGUAGE from SXS_ASSEMBLY_LANGUAGE_INDEPENDENT.
#
!if defined(SXS_ASSEMBLY_LANGUAGE_INDEPENDENT) && !defined(SXS_ASSEMBLY_LANGUAGE)
SXS_ASSEMBLY_LANGUAGE=x-ww
!endif

#
# This is for Fusion stuff only. It does not need to match the nt subsystem version.
#
!if !defined(SXS_ASSEMBLY_VERSION)
SXS_ASSEMBLY_VERSION=5.1
!endif

#
# Clients usually only provide major.minor, and we append .0.0.
#
!if defined(SXS_ASSEMBLY_VERSION) # {

!if !defined(SXS_ASSEMBLY_VERSION_PART_3)
SXS_ASSEMBLY_VERSION_PART_3=0
!endif

!if !defined(SXS_ASSEMBLY_VERSION_PART_4)
SXS_ASSEMBLY_VERSION_PART_4=0
!endif

SXS_ASSEMBLY_VERSION=$(SXS_ASSEMBLY_VERSION).$(SXS_ASSEMBLY_VERSION_PART_3).$(SXS_ASSEMBLY_VERSION_PART_4)

!endif # }

!if !$(SXS_NO_BINPLACE) # {
#
# We might need SXS_ASSEMBLY_LANGUAGE and even SXS_ASSEMBLY_PROCESSOR_ARCHITECTURE
# in SXS_BINPLACE_DIR, esp. for example if we have any data only assemblies with
# the same name/version as code containing assemblies.
#
# Eventually the mapping from assembly metadata to run-time paths and
# build-time paths will be exposed by sxs.dll/sxs.lib consumed
# by build tools written in C/C++ (possibly just binplace).
# Build/Make are too constraining for our needs.
# For now we get by.
#
# "asms" is very special, it is the root of where assemblies are binplaced
# and it is the root of where they appear on the CD. This string appears in
# a number of places:
#   \nt\tools\PostBuildScripts
#   \nt\admin\ntsetup\inf\win4\inf\dosnet.inx
#   \nt\admin\ntsetup\inf\win4\inf\syssetup.inx
#
SXS_BINPLACE_DIR1=asms
# Remove dots from SXS_ASSEMBLY_VERSION to make it legal 8.3 (only one dot allowed)
# We place version in front of name due to restrictions on how the manifest
# file name related to the name of leaf directory it is in.
SXS_BINPLACE_DIR2=$(SXS_ASSEMBLY_VERSION:.=)\$(SXS_SHORT_ASSEMBLY_NAME)
SXS_BINPLACE_DIR3=$(SXS_BINPLACE_DIR1)\$(SXS_BINPLACE_DIR2)
SXS_BINPLACE_SLASH_DIR3=\$(SXS_BINPLACE_DIR3)

#
# create msms destination directory
#
!if defined(SXS_GENERATE_MERGE_MODULE) # {

#
# if the generate mode is not defined, set it default : 0
#
!if !defined(SXS_MERGE_MODULE_FOR_ASSEMBLY_GROUP)
SXS_MERGE_MODULE_FOR_ASSEMBLY_GROUP=0
!else
SXS_MERGE_MODULE_FOR_ASSEMBLY_GROUP=1
!endif

!if "$(SXS_MERGE_MODULE_GUID)" == "" || "$(SXS_MERGE_MODULE_COMPONENT_GUID)" == ""  # {
!message $(SXS_MERGE_MODULE_ERROR_MSG) MergeModule GUID and MergeModule Component must be specified
!endif # }

!if !defined(SXS_MERGE_MODULE) # { use the manifest basename as the msm basename
SXS_MERGE_MODULE=$(SXS_MANIFEST_BASENAME).msm
!endif #}

!if !defined(SXS_MERGE_MODULE_LOCATION)
SXS_MERGE_MODULE_DESTINATION=asm_msm\$(SXS_BINPLACE_DIR2)
!else
#
#parse this string to generate the real path
#
SXS_MERGE_MODULE_LOCATION=$(SXS_ASSEMBLY_VERSION:.=)\$(SXS_MERGE_MODULE_LOCATION)
SXS_MERGE_MODULE_LOCATION=$(SXS_MERGE_MODULE_LOCATION:-=\)
SXS_MERGE_MODULE_LOCATION=$(SXS_MERGE_MODULE_LOCATION:_=\)
SXS_MERGE_MODULE_LOCATION=$(SXS_MERGE_MODULE_LOCATION:.=\)
SXS_MERGE_MODULE_LOCATION=$(SXS_MERGE_MODULE_LOCATION: =\)
SXS_MERGE_MODULE_LOCATION=asm_msm\$(SXS_MERGE_MODULE_LOCATION)
!endif
!endif # }

BINPLACE_GENERATE_PLACEFILE=1
!if "$(BINPLACE_DESTINATIONS)" == ""
BINPLACE_DESTINATIONS=$(SXS_BINPLACE_DIR3)
!else
BINPLACE_DESTINATIONS=$(BINPLACE_DESTINATIONS):$(SXS_BINPLACE_DIR3)
!endif
BINPLACE_DESTINATIONS_NORETAIL=$(BINPLACE_DESTINATIONS)
!if defined(SXS_BINPLACE_ALSO_ROOT)
!if "$(BINPLACE_DESTINATIONS)" == ""
BINPLACE_DESTINATIONS=retail
!else
BINPLACE_DESTINATIONS=$(BINPLACE_DESTINATIONS):retail
!endif
!endif

!endif # !SXS_NO_BINPLACE }

#
# Optionally uniquize the .pdb names, so they can go in a flat directory (%_nttree%\symbols.pri\retail\dll)
#
!if !defined(SXS_LONG_PDB_NAME)
SXS_LONG_PDB_NAME=$(SXS_PDB_WOW6432_W_PREFIX)$(SXS_ASSEMBLY_NAME:.=)-$(SXS_ASSEMBLY_VERSION:.=)-$(TARGETNAME:.=)
!endif
!if !$(SXS_NO_BINPLACE) #{
!if !defined(TARGETPDB) && "$(SXS_USE_LONG_PDB_NAME)" == "1"
LINKER_FLAGS=$(LINKER_FLAGS) -pdb:$(TARGETPATH)\$(TARGET_DIRECTORY)\$(SXS_LONG_PDB_NAME).pdb
!endif
SXS_BINPLACE_FLAGS=-ChangeAsmsToRetailForSymbols
!endif #}

!endif # !SXS_ASSEMBLY_NAME }

!if defined(BINPLACE_LOG) && !$(SXS_NO_BINPLACE) && !defined(NO_BINPLACE) && $(ONCE_IN_ANY_PASS) && defined(SXS_ASSEMBLY_NAME)
SXS_LOG_PASS=1
SXS_LOG_CMD= ( echo. )
BUILD_LOGS=$(BINPLACE_LOG)\..
!endif

!if defined(SXS_MANIFEST) # {

#
# If removing .manifest or .Manifest from SXS_MANIFEST leaves it unchanged,
# it doesn't contain either one and is invalid.
#
!if "$(SXS_MANIFEST:.Manifest=)" == "$(SXS_MANIFEST)" \
    && "$(SXS_MANIFEST:.manifest=)" == "$(SXS_MANIFEST)"
!message $(SXS_BUILD_ERROR_MSG) SXS_MANIFEST ($(SXS_MANIFEST)) must contain ".Manifest", it must end in ".Manifest" or ".Manifest-src"
!endif

SXS_MANIFEST_SOURCE_FILENAME=$(SXS_MANIFEST:..\=)

SXS_MANIFEST_BASENAME=$(SXS_MANIFEST_SOURCE_FILENAME)
SXS_MANIFEST_BASENAME=$(SXS_MANIFEST_BASENAME:.manifest-src=)
SXS_MANIFEST_BASENAME=$(SXS_MANIFEST_BASENAME:.Manifest-src=)
SXS_MANIFEST_BASENAME=$(SXS_MANIFEST_BASENAME:.manifest=)
SXS_MANIFEST_BASENAME=$(SXS_MANIFEST_BASENAME:.Manifest=)
SXS_MANIFEST_BASENAME=$(SXS_MANIFEST_BASENAME:.man=)
SXS_MANIFEST_BASENAME=$(SXS_MANIFEST_BASENAME:.Man=)
SXS_MANIFEST_BASENAME=$(SXS_MANIFEST_BASENAME:.man-src=)
SXS_MANIFEST_BASENAME=$(SXS_MANIFEST_BASENAME:.Man-src=)

#
# Always make .man file in the obj directory.
#
SXS_MANIFEST_OBJ1=$(O)\$(SXS_MANIFEST_BASENAME).o_manifest


!if !defined(SXS_MANIFEST_IN_RESOURCES)

#
# OBJ is files in obj\i386.
# BIN is binplaced files, possibly also in obj\i386.
#
# The binplaced file must be 8.3.
# The obj\i386 file
#  - should allow .exes to be run from obj\i386 that don't have manifest-in-resources
#  - not override manifest-in-resources
#
SXS_MANIFEST_BIN_FILENAME=$(SXS_MANIFEST_BASENAME).man

!if !defined(NO_BINPLACE) && !$(SXS_NO_BINPLACE) && ("$(BUILD_PASS)" == "PASS1" || "$(BUILD_PASS)" == "PASSALL")
SXS_MISCFILES=$(SXS_MISCFILES) $(O)\$(SXS_MANIFEST_BASENAME).man
!endif

# Make a .manifest file identical to the .man file (we just copy it).
!if "$(TARGETTYPE)" != "NOTARGET" && ("$(MAKEDLL)" != "" || "$(BUILD_PASS)" == "PASS2" || "$(BUILD_PASS)" == "PASSALL")
SXS_MANIFEST_OBJ2=$(O)\$(TARGETNAME).$(TARGETEXT).manifest
!endif

!else

SXS_MANIFEST_BIN_FILENAME=$(TARGETNAME).$(TARGETEXT)

!if !defined(SXS_MANIFEST_RESOURCE_ID)
!if defined(ISOLATION_AWARE_ENABLED) || "$(TARGETTYPE)" == "DYNLINK"
SXS_MANIFEST_RESOURCE_ID=ISOLATIONAWARE_MANIFEST_RESOURCE_ID
!elseif "$(TARGETTYPE)" == "PROGRAM" || "$(TARGETTYPE)" == "PROGLIB" || "$(TARGETTYPE)" == "UMAPPL_NOLIB"
SXS_MANIFEST_RESOURCE_ID=CREATEPROCESS_MANIFEST_RESOURCE_ID
!endif
!endif

#
# Putting manifests in resources requires no editing of the .rc file.
# We can do this via forceinclude-file or forceinclude-string.
# I thought rc.exe had a forceinclude-file feature like the C++ compiler.
# By the time I realized that it doesn't, it seemed better to press ahead
# with simulating it than not depend on it. There is unlikely any other way
# to support SXS_MANIFEST_IN_RESOURCES without requiring "nonlocal" .rc file
# edits (ie: without further fanning out how many files need to touched in how
# many places by clients who want to build sxs assemblies).
#
RCOPTIONS=-DSXS_MANIFEST_OBJ1="\"$(SXS_MANIFEST_OBJ1:\=/)\"" $(RCOPTIONS)
INCPATHRC=$(INCPATHRC)
RC_FORCE_INCLUDE_STRING=$(RC_FORCE_INCLUDE_STRING)^
^#include "windows.h"^
^/* RT_MANIFEST is in winuser.h and winuser.rh */^
$(SXS_MANIFEST_RESOURCE_ID) RT_MANIFEST SXS_MANIFEST_OBJ1
#RC_FORCE_INCLUDE_FILES=$(RC_FORCE_INCLUDE_FILES);$(BASE_INC_PATH)\SxsManifestInResource.rc2
#RC_FORCE_INCLUDE_STRING=

!endif # SXS_MANIFEST_IN_RESOURCES

!if defined(SXS_LOG_PASS) # {
#
# data for PostBuild/ManifestMangler
#

SXS_LOG_CMD= ( $(SXS_LOG_CMD) ) &                                            \
        ( echo                                                             \
        SXS_ASSEMBLY_NAME="$(SXS_ASSEMBLY_NAME)"                           \
        SXS_ASSEMBLY_VERSION="$(SXS_ASSEMBLY_VERSION)"                     \
        SXS_ASSEMBLY_LANGUAGE="$(SXS_ASSEMBLY_LANGUAGE)"                   \
        SXS_MANIFEST="$(SXS_LOG_BINPLACE_WOW6432_PREFIX)$(SXS_BINPLACE_DIR3)\$(SXS_MANIFEST_BIN_FILENAME)"   \
        | appendtool.exe -file $(BINPLACE_LOG)-sxs - )

#
# Produce manifest-related, including
#       Required: catalog,
#       Optional: merge module
#

!if !defined(SXS_FUSIONLIST_TXT_DATA_VALIDLANGS)
SXS_FUSIONLIST_TXT_DATA_VALIDLANGS=all
!endif
!if !defined(SXS_FUSIONLIST_TXT_DATA_LANGEXCEPTIONS)
SXS_FUSIONLIST_TXT_DATA_LANGEXCEPTIONS=-
!endif
!if !defined(SXS_FUSIONLIST_TXT_DATA_VALIDARCHS)
SXS_FUSIONLIST_TXT_DATA_VALIDARCHS=all
!endif
!if !defined(SXS_FUSIONLIST_TXT_DATA_VALIDDEBUG)
SXS_FUSIONLIST_TXT_DATA_VALIDDEBUG=all
!endif

#
# Filename ValidLangs Exceptions ValidArchs ValidDebug AltName
#
!if !defined(SXS_FUSIONLIST_TXT_DATA)       #{
SXS_FUSIONLIST_TXT_DATA=\
 $(SXS_BINPLACE_DIR3)\$(SXS_MANIFEST_BASENAME).cat \
 $(SXS_FUSIONLIST_TXT_DATA_VALIDLANGS) \
 $(SXS_FUSIONLIST_TXT_DATA_LANGEXCEPTIONS) \
 $(SXS_FUSIONLIST_TXT_DATA_VALIDARCHS) \
 $(SXS_FUSIONLIST_TXT_DATA_VALIDDEBUG)
!endif  #}

!if !defined(SXS_FUSIONLIST_TXT_DATA_WOW)   #{
SXS_FUSIONLIST_TXT_DATA_WOW=\
 $(SXS_BINPLACE_DIR1)\x86\$(SXS_BINPLACE_DIR2)\$(SXS_MANIFEST_BASENAME).cat \
 $(SXS_FUSIONLIST_TXT_DATA_VALIDLANGS) \
 $(SXS_FUSIONLIST_TXT_DATA_LANGEXCEPTIONS) \
 ia64;amd64 \
 $(SXS_FUSIONLIST_TXT_DATA_VALIDDEBUG)
!endif  #}

!if defined(SXS_GENERATE_MERGE_MODULE)   # { begin create log-file-entry for Assembly MergeModule

#
# the msm-log lsitfile is in the format of
#   SourceFileDirectory | Destination-MSM-Filename | MergeModuleID | MergeModuleComponent ID
#
!if !defined(SXS_MERGE_MODULE_TXT_DATA)   #{
SXS_MERGE_MODULE_TXT_DATA=\
 $(SXS_MERGE_MODULE_FOR_ASSEMBLY_GROUP),\
 $(SXS_MERGE_MODULE_GUID),\
 ..\$(SXS_MERGE_MODULE_LOCATION)\$(SXS_MERGE_MODULE),\
 ..\$(SXS_BINPLACE_DIR3)\$(SXS_MANIFEST_BASENAME).man,\
 $(SXS_MERGE_MODULE_COMPONENT_GUID)
!endif # }

!endif # } end create log-file-entry for Assembly MergeModule

!endif # SXS_LOG_PASS }

!endif # SXS_MANIFEST }

!if defined(SXS_LOG_PASS) && (defined(SXS_FUSIONLIST_TXT_DATA) || defined(SXS_FUSIONLIST_TXT_DATA_WOW)) # {

#
# $(COMPUTERNAME) is for unique per build machine file names in a distributed build environment.
# These files are combined later.
#
SXS_NEWPRS_FUSIONLIST_TXT=$(BINPLACE_LOG)\..\fusionlist_$(COMPUTERNAME).txt

!if defined(SXS_FUSIONLIST_TXT_DATA)
SXS_LOG_CMD=( $(SXS_LOG_CMD) ) & ( echo $(SXS_FUSIONLIST_TXT_DATA) | appendtool.exe -file $(SXS_NEWPRS_FUSIONLIST_TXT) - )
!endif
!if defined(SXS_FUSIONLIST_TXT_DATA_WOW)
SXS_LOG_CMD=( $(SXS_LOG_CMD) ) & ( echo $(SXS_FUSIONLIST_TXT_DATA_WOW) | appendtool.exe -file $(SXS_NEWPRS_FUSIONLIST_TXT) - )
!endif
!endif # }

!if defined(SXS_LOG_PASS) && defined(SXS_MERGE_MODULE_TXT_DATA) # {
SXS_MERGEMODULE_LIST_TXT=$(BINPLACE_LOG)\..\sxsMsmList_$(COMPUTERNAME).txt
!if defined(SXS_MERGE_MODULE_TXT_DATA)
SXS_LOG_CMD=( $(SXS_LOG_CMD) ) & ( echo $(SXS_MERGE_MODULE_TXT_DATA) | appendtool.exe -file $(SXS_MERGEMODULE_LIST_TXT) - )
!endif

!endif # }


#
# Do this independently of the presence of any other SXS options
# to aid .manifest preprocessing in the absense of any other sxs build support,
# like for users of CreateActCtx. The MultiRes test case uses this.
#
!if !defined(SXS_PROCESSOR_ARCHITECTURE)
!if defined(SXS_WOW6432)
SXS_PROCESSOR_ARCHITECTURE=wow64
!elseif defined(_BUILDARCH)
SXS_PROCESSOR_ARCHITECTURE=$(_BUILDARCH)
!elseif $(386)
SXS_PROCESSOR_ARCHITECTURE=x86
!elseif $(IA64)
SXS_PROCESSOR_ARCHITECTURE=ia64
!else
!message $(SXS_BUILD_ERROR_MSG) Cannot determine processorArchitecture.
!endif
!endif

!if defined(LOCALIZED_RESOURCES) && !defined(RCCODEPAGE)
! if "$(LANGUAGE)" == "JPN" || "$(LANGUAGE)" == "jpn"
RCCODEPAGE=932
! elseif "$(LANGUAGE)" == "KOR" || "$(LANGUAGE)" == "kor"
RCCODEPAGE=949
! elseif "$(LANGUAGE)" == "CHS" || "$(LANGUAGE)" == "chs"
RCCODEPAGE=936
! elseif "$(LANGUAGE)" == "CHP" || "$(LANGUAGE)" == "chp"
RCCODEPAGE=936
! elseif "$(LANGUAGE)" == "CHT" || "$(LANGUAGE)" == "cht"
RCCODEPAGE=950
! endif
!endif

#
# Set far east specific defines based on the project
#
DO_FE_SB=0

!if "$(ALT_PROJECT_TARGET)" == ""
ALT_PROJECT_TARGET=.
!endif

!if "$(ALT_PROJECT)" == "FE"  || \
    "$(ALT_PROJECT)" == "CHT" || \
    "$(ALT_PROJECT)" == "CHS" || \
    "$(ALT_PROJECT)" == "CHP" || \
    "$(ALT_PROJECT)" == "JPN" || \
    "$(ALT_PROJECT)" == "KOR" || \
    "$(ALT_PROJECT)" == "NEC_98"
C_DEFINES=$(C_DEFINES) -DDBCS -DKKBUGFIX
ASM_DEFINES=$(ASM_DEFINES) -DDBCS -DKKBUGFIX
DO_FE_SB=1
!endif

!if "$(ALT_PROJECT)" == "CHT"
C_DEFINES=$(C_DEFINES) -DTAIWAN
ASM_DEFINES=$(ASM_DEFINES) -DTAIWAN
!elseif "$(ALT_PROJECT)" == "CHS" || "$(ALT_PROJECT)" == "CHP"
C_DEFINES=$(C_DEFINES) -DPRC
ASM_DEFINES=$(ASM_DEFINES) -DPRC
!elseif "$(ALT_PROJECT)" == "JPN"
C_DEFINES=$(C_DEFINES) -DJAPAN
ASM_DEFINES=$(ASM_DEFINES) -DJAPAN
!elseif "$(ALT_PROJECT)" == "KOR"
C_DEFINES=$(C_DEFINES) -DKOREA
ASM_DEFINES=$(ASM_DEFINES) -DKOREA
!elseif "$(ALT_PROJECT)" == "NEC_98"
C_DEFINES=$(C_DEFINES) -DJAPAN -DNEC_98
ASM_DEFINES=$(ASM_DEFINES) -DJAPAN -DNEC_98
!elseif "$(ALT_PROJECT)" != ""
C_DEFINES=$(C_DEFINES) -D_$(ALT_PROJECT)_
!endif

!IF "$(ALT_PROJECT)" == "HYDRA"
ASM_DEFINES=$(ASM_DEFINES) -D_HYDRA_
HYDRA=1
!ENDIF

!IF "$(ALT_PROJECT)" == "JANUS"
ASM_DEFINES=$(ASM_DEFINES) -D_JANUS_
C_DEFINES=$(C_DEFINES) -D_JANUS_
JANUS=1
!ENDIF

!IF ("$(NO_W32_SB)" == "" && "$(W32_SB)" == "1")
DO_FE_SB=1
! ENDIF

!IF "$(DO_FE_SB)" == "1"
C_DEFINES=$(C_DEFINES) -DFE_SB -DFE_IME
ASM_DEFINES=$(ASM_DEFINES) -DFE_SB
!ENDIF

!IF "$(ALT_PROJECT)" == "DS"
# Nothing, just -D_DS_ from above
!ENDIF

!ifdef RESOURCE_ONLY_DLL
# Resource only DLL's have no exports, no entrypoint, no code, no data, no debug symbolic.
LINKER_DBG_SECTION=-debug:NONE
NO_DLL_EXPORTS=1
!undef NTBBT
!undef DLLENTRY
!undef NOLINK
NO_BROWSER_FILE=1
LINK_NO_RELEASE=1
MAKEDLL=1
TARGETLIBS=
LINKLIBS=
USE_NOLIBS=1
NO_NTDLL=1
AFX_FORCE_STDAFX=
AFX_FORCE_USRDLL=
MFC_LIBS=
!else
LINKER_DBG_SECTION=-debug
AFX_FORCE_STDAFX=/include:__afxForceSTDAFX
AFX_FORCE_USRDLL=/include:__afxForceUSRDLL
!endif

!ifdef DEPRECATE_DDK_FUNCTIONS
C_DEFINES=$(C_DEFINES) -DDEPRECATE_DDK_FUNCTIONS
!endif

!IFNDEF TARGETPATH
! ERROR Your .\sources. file must define the TARGETPATH= macro
!ENDIF

!if "$(TARGETPATH)" == "obj" || "$(TARGETPATH)" == "OBJ"
TARGETPATH=$(_OBJ_DIR)
!endif

!if "$(TARGETPATHLIB)" == "obj" || "$(TARGETPATHLIB)" == "OBJ"
TARGETPATHLIB=$(_OBJ_DIR)
!endif

!ifdef TARGETPATHLIB
! if ("$(TARGETTYPE)" == "DYNLINK") || ("$(TARGETTYPE)" == "EXPORT_DRIVER")
!  if "$(MAKEDLL)" == ""
# Pass 1 of a two pass build.  Make sure TargetPath is the same as targetpathlib.
NO_BROWSER_FILE=1
TARGETPATH=$(TARGETPATHLIB)
!  endif
! endif
!else
TARGETPATHLIB=$(TARGETPATH)
!endif

!IF ("$(TARGETPATH)" == "$(BASEDIR)\lib") || ("$(TARGETPATH)" == "$(BASEDIR)\LIB")
!  ERROR Setting TARGETPATH= $(BASEDIR)\lib in .\sources is not valid - please use obj.
!ENDIF

!IFNDEF TARGETTYPE
! ERROR Your .\sources. file must define the TARGETTYPE= macro
!ENDIF

!IFNDEF TARGETNAME
! IF "$(TARGETTYPE)" != "NOTARGET"
!  ERROR Your .\sources. file must define the TARGETNAME= macro
! ELSE
TARGETNAME=
! ENDIF
!ENDIF

!IFNDEF SOURCES
! ERROR Your .\sources. file must define the SOURCES= macro
!ENDIF

!ifndef COFFBASE_TXT_FILE
COFFBASE_TXT_FILE = $(NTMAKEENV)\coffbase.txt
!endif

!IFNDEF UMBASE
! IFDEF COFFBASE
UMBASE=@$(COFFBASE_TXT_FILE),$(COFFBASE)
! ELSE
!  if $(WIN64)
# wait for wow64/CreateProcess support
#UMBASE=@$(COFFBASE_TXT_FILE),usermode64
UMBASE=@$(COFFBASE_TXT_FILE),usermode
!  else
UMBASE=@$(COFFBASE_TXT_FILE),usermode
!  endif
! ENDIF
!ENDIF

LINKLIBS=$(LINKLIBS) $(PERFLIBS)

!if !defined(ATL_VER) || ("$(ATL_VER)" == "10")
ATL_VER=21
!endif

!if "$(ATL_VER)" == "70"
! if defined(USE_ATL) || defined(USE_STATIC_ATL)
ATL_INCLUDES=$(ATL_INC_ROOT)\atlmfc71
ATL_DEFINES=/D_ATL_STATIC_REGISTRY
!  ifdef DEBUG_CRTS
ATL_LIBS=$(ATL_LIB_PATH)\atlsd.lib
!  else
ATL_LIBS=$(ATL_LIB_PATH)\atls.lib
!  endif
BUFFER_OVERFLOW_CHECKS=1
! endif
!else
! if defined(USE_ATL)
ATL_INCLUDES=$(ATL_INC_ROOT)\atl$(ATL_VER)
ATL_DEFINES=/D_ATL_DLL
!  if "$(ATL_VER)" == "10"
ATL_LIBS=
!  else
ATL_LIBS=$(ATL_LIB_PATH)\atl.lib $(ADDITIONAL_ATL_LIBS)
!  endif
! elseif defined(USE_STATIC_ATL)
ATL_INCLUDES=$(ATL_INC_ROOT)\atl$(ATL_VER)
ATL_LIBS=$(ADDITIONAL_ATL_LIBS)
ATL_DEFINES=/D_ATL_STATIC_REGISTRY
! endif
!endif

!if !defined(WTL_VER)
WTL_VER=10
!endif

!if defined(USE_WTL)
!ifdef WTL_INC_PATH
WTL_INCLUDES=$(WTL_INC_PATH)\wtl$(WTL_VER)
!else
WTL_INCLUDES=$(SDK_INC_PATH)\wtl$(WTL_VER)
!endif
!endif

!if defined(USE_STL)
! if "$(STL_VER)" == "70"
STL_INC_PATH=$(STL7_INC_PATH)
C_DEFINES=$(C_DEFINES) /D_STATIC_CPPLIB /D_STL70_
USE_MSVCRT=1
! else
STL_INC_PATH=$(STL6_INC_PATH)
! endif
!endif

!IF DEFINED(USE_MFC) || DEFINED(USE_MFCUNICODE)

!if "$(PLATFORM_MFC_VER)" != "0x0600"
# MFC versions before 6.0 need NT4/Win95 values.  Override at your own risk.
!ifndef WIN32_WINNT_VERSION
WIN32_WINNT_VERSION=0x0400
!endif
!ifndef WIN32_IE_VERSION
WIN32_IE_VERSION=0x0300
!endif
!else   # MFC post 6x defaults to the current version of IE/Win2k.
!ifndef WIN32_WINNT_VERSION
WIN32_WINNT_VERSION=$(LATEST_WIN32_WINNT_VERSION)
!endif
!ifndef WIN32_IE_VERSION
WIN32_IE_VERSION=$(LATEST_WIN32_IE_VERSION)
!endif
!endif

!ifndef WIN32_WIN95_VERSION
WIN32_WIN95_VERSION=0x0400
!endif

!ifndef WIN32_WCE_VERSION
WIN32_WCE_VERSION=0x0300
!endif

#---------------------------------------------------------#
# this set of defines establishes the "correct" build     #
# environment for an app that needs to use MFC.  the      #
# app's sources file only needs to specify USE_MFC=1      #
# and this makefile will set the enviroment up correctly. #
#---------------------------------------------------------#

! ifndef UMENTRY
!  ifdef USE_MFCUNICODE
UMENTRY=wwinmain
!  else
UMENTRY=winmain
!  endif
! endif

! if "$(TARGETTYPE)" == "DYNLINK" && !defined(RESOURCE_ONLY_DLL)
!  ifndef DLLENTRY
DLLENTRY=_DllMainCRTStartup
!  endif
! endif

! ifndef UMTYPE
UMTYPE=windows
! endif

UMENTRYABS=

# Allow other MFC's.
#  To do so, you need to:
#    1. Define MFC_INCLUDES to point to your MFC headers.
#    2. Define MFC_LIBS to point to your MFC libraries (specifically, the dll
#       library)
#    3. Define USE_MSVCRT=1 if you don't want to link with the NT CRT DLL.
#
#  Note:
#     There is only one type of build (_AFXDLL or MFC in a DLL linking to the
#     CRT in a dll).
#     You should disable the alternate MFC's if compiling for RISC platforms.
#     You need to handle specifying the correct libs for Check/Free and
#     Ansi/Unicode.

! if !defined(USE_MSVCRT) && !defined(USE_NOLIBS) && !defined(USE_MSVCRT40)
!  if defined(USE_STATIC_MFC)
USE_LIBCMT=1
!  else
USE_CRTDLL=1
!  endif
! endif

# Add MFC_FLAGS in just in case there's old sources files that use it.

MFC_DEFINES=$(MFC_DEFINES) $(MFC_FLAGS) -D_AFX_NOFORCE_LIBS -D_MFC_VER=$(PLATFORM_MFC_VER)

! ifdef DEBUG_CRTS
MFC_DEFINES=$(MFC_DEFINES) -D_AFX_ENABLE_INLINES
! endif

! IFDEF USE_MFCUNICODE
MFC_DEFINES=$(MFC_DEFINES) -DUNICODE -D_UNICODE
! ENDIF

# Assume Latest MFC (4.0 for now)

! ifndef USE_STATIC_MFC
MFC_DEFINES=$(MFC_DEFINES) -D_AFXDLL
LINKER_FLAGS = $(LINKER_FLAGS) $(AFX_FORCE_STDAFX)
! endif
! ifdef MFC_USRDLL
MFC_DEFINES=$(MFC_DEFINES) -D_USRDLL
LINKER_FLAGS = $(LINKER_FLAGS) $(AFX_FORCE_USRDLL)
! endif

# MFC 4 uses Native EH only

!ifndef USE_NATIVE_EH
USE_NATIVE_EH=1
!endif
USE_RTTI=1

# UNICODE must use the UNICODE entrypoint

! ifdef USE_MFCUNICODE
!  if "$(UMENTRY)" == "winmain"
UMENTRY = wwinmain
!  else if "$(UMENTRY)" == "main"
UMENTRY = wmain
!  endif
! endif

! ifndef MFC_VER
MFC_VER=42
! else if "$(MFC_VER)" == "40" && !defined(USE_STATIC_MFC)
!undef USE_MSVCRT
!undef USE_CRTDLL
USE_MSVCRT40=1
! endif

!ifndef MFC_INC_PATH
MFC_INC_PATH=$(MFC_INC_ROOT)\mfc$(MFC_VER)
!endif

! ifndef MFC_DAO_INC
MFC_DAO_INC=$(MFC_INC_ROOT)\dao350
! endif

! ifndef MFC_INCLUDES
MFC_INCLUDES=$(MFC_INC_PATH);$(MFC_DAO_INC)
!  ifdef MFC_LANGUAGE
MFC_INCLUDES=$(MFC_INC_PATH)\l.$(MFC_LANGUAGE);$(MFC_INCLUDES)
!  endif
! endif

! ifndef MFC_LIBS
!  ifdef USE_STATIC_MFC

!   ifdef DEBUG_CRTS
!    ifdef USE_MFCUNICODE
MFC_STATIC_LIB =
MFC_LIBS=$(MFC_LIB_PATH)\uafxcwd.lib
!    else
MFC_STATIC_LIB =
MFC_LIBS=$(MFC_LIB_PATH)\nafxcwd.lib
!    endif
!   else
!    ifdef USE_MFCUNICODE
MFC_STATIC_LIB =
MFC_LIBS=$(MFC_LIB_PATH)\uafxcw.lib
!    else
MFC_STATIC_LIB =
MFC_LIBS=$(MFC_LIB_PATH)\nafxcw.lib
!    endif
!   endif

!  else                # USE_STATIC_MFC

!   ifdef DEBUG_CRTS
!    ifdef USE_MFCUNICODE
MFC_STATIC_LIB = $(MFC_LIB_PATH)\mfcs$(MFC_VER)ud.lib
MFC_LIBS=$(MFC_LIB_PATH)\mfc$(MFC_VER)ud.lib  \
         $(MFC_LIB_PATH)\mfcd$(MFC_VER)ud.lib \
         $(MFC_LIB_PATH)\mfcn$(MFC_VER)ud.lib \
         $(MFC_LIB_PATH)\mfco$(MFC_VER)ud.lib
!    else
MFC_STATIC_LIB = $(MFC_LIB_PATH)\mfcs$(MFC_VER)d.lib
MFC_LIBS=$(MFC_LIB_PATH)\mfc$(MFC_VER)d.lib  \
         $(MFC_LIB_PATH)\mfcd$(MFC_VER)d.lib \
         $(MFC_LIB_PATH)\mfcn$(MFC_VER)d.lib \
         $(MFC_LIB_PATH)\mfco$(MFC_VER)d.lib
!    endif
!   else
!    ifdef USE_MFCUNICODE
MFC_STATIC_LIB = $(MFC_LIB_PATH)\mfcs$(MFC_VER)u.lib
MFC_LIBS=$(MFC_LIB_PATH)\mfc$(MFC_VER)u.lib
!    else
MFC_STATIC_LIB = $(MFC_LIB_PATH)\mfcs$(MFC_VER).lib
MFC_LIBS=$(MFC_LIB_PATH)\mfc$(MFC_VER).lib
!    endif
!   endif
MFC_LIBS=$(MFC_STATIC_LIB) $(MFC_LIBS)

!  endif               # USE_STATIC_MFC
! endif                # MFC_LIBS
!endif                 # USE_MFC

!IFNDEF UMTYPE
!if "$(TARGETTYPE)" == "DYNLINK"
UMTYPE=console
!ifndef SUBSYSTEM_VERSION
SUBSYSTEM_VERSION=$(SUBSYSTEM_VERSION_CURRENT)
!endif
!else
UMTYPE=nt
!endif
!ENDIF

!ifdef USE_MFC30
LIBC_DEFINES=
!else
! ifdef DEBUG_CRTS
DCRT=d
LIBC_DEFINES = -D_DEBUG
! else
DCRT=
LIBC_DEFINES = -DNDEBUG
! endif
!endif

# For all but X86, MSVCRT20==MSVCRT40==CRTDLL==MSVCRT
!if !$(386)
! if defined(USE_MSVCRT20)
USE_MSVCRT=1
!  undef USE_MSVCRT20
! elseif defined(USE_MSVCRT40)
USE_MSVCRT=1
!  undef USE_MSVCRT40
! elseif defined(USE_CRTDLL)
USE_MSVCRT=1
!  undef USE_CRTDLL
! endif
!endif


!if defined(USE_CRTDLL) || defined(USE_MSVCRT)

! if !$(MPPC)
LIBC_LIB=$(CRT_LIB_PATH)\msvcrt$(DCRT).lib
!  if defined(USE_IOSTREAM)
LIBC_LIB=$(LIBC_LIB) $(CRT_LIB_PATH)\msvcirt$(DCRT).lib
!  endif
!  if defined(USE_STL)
LIBC_LIB=$(LIBC_LIB) $(CRT_LIB_PATH)\msvcprt$(DCRT).lib
!  endif
LIBC_DEFINES=$(LIBC_DEFINES) -D_DLL=1 -D_MT=1
! endif

!elseif defined(USE_IERT)
! ERROR USE_IERT is no longer supported.  Switch to USE_LIBCMT or USE_MSVCRT.
!elseif defined(USE_LIBCMT)

LIBC_LIB=$(CRT_LIB_PATH)\libcmt$(DCRT).lib
! if defined(USE_IOSTREAM)
LIBC_LIB=$(CRT_LIB_PATH)\libcimt$(DCRT).lib $(LIBC_LIB)
! endif
! if defined(USE_STL)
LIBC_LIB=$(CRT_LIB_PATH)\libcpmt$(DCRT).lib $(LIBC_LIB)
! endif
LIBC_DEFINES=$(LIBC_DEFINES) -D_MT=1

!elseif defined(USE_LIBCNTPR)

LIBC_LIB=$(SDK_LIB_PATH)\libcntpr.lib

!elseif (defined(USE_NTDLL) || \
       "$(TARGETTYPE)" == "DRIVER" || \
       "$(TARGETTYPE)" == "EXPORT_DRIVER" || \
       defined(USE_SYSDLL) )

LIBC_DEFINES=$(LIBC_DEFINES) -D_DLL=1
LIBC_LIB=

!elseif defined(USE_NOLIBS) || \
       "$(TARGETTYPE)" == "HAL" || \
       "$(TARGETTYPE)" == "GDI_DRIVER"

NO_NTDLL=1
LIBC_LIB=

!elseif defined(USE_MSVCRT20)

LIBC_LIB=$(CRT_LIB_PATH)\msvcrt2$(DCRT).lib
LIBC_DEFINES=$(LIBC_DEFINES) -D_DLL=1 -D_MT=1

!elseif defined(USE_MSVCRT40)

LIBC_LIB=$(CRT_LIB_PATH)\msvcrt4$(DCRT).lib
LIBC_DEFINES=$(LIBC_DEFINES) -D_DLL=1 -D_MT=1

!else

LIBC_LIB=$(CRT_LIB_PATH)\libc$(DCRT).lib
! if defined(USE_IOSTREAM)
LIBC_LIB=$(CRT_LIB_PATH)\libci$(DCRT).lib $(LIBC_LIB)
! endif
! if defined(USE_STL)
LIBC_LIB=$(CRT_LIB_PATH)\libcp$(DCRT).lib $(LIBC_LIB)
! endif

!endif

!if defined(USE_VCCOM)
LIBC_LIB = $(SDK_LIB_PATH)\vccomsup.lib $(LIBC_LIB)
!endif

!IFNDEF GPSIZE
GPSIZE= 0
!ENDIF

!ifdef NTLIBPATH
LIBRARY_PATH = $(NTLIBPATH)\*\lib
!else
LIBRARY_PATH = $(SDK_LIB_PATH)
!endif

!if defined(USE_MFC) ||  defined(USE_MFCUNICODE)
LIBC_LIB = $(MFC_LIBS) $(LIBC_LIB)
!endif

!if defined(USE_ATL) || defined(USE_STATIC_ATL)
LIBC_LIB = $(ATL_LIBS) $(LIBC_LIB)
# Piggy back on MFC_DEFINES for now.
MFC_DEFINES = $(MFC_DEFINES) $(ATL_DEFINES)
!endif

!if $(386) && defined(USE_MSLU)
# MSLU goes after MFC/ATL/CRT but before everything else
LIBC_LIB = $(LIBC_LIB) $(SDK_LIB_PATH)\unicows.lib
!endif

NT_LIBS=$(LIBRARY_PATH)\ntdll.lib
GUI32_LIBS=$(LIBRARY_PATH)\gdi32.lib \
           $(LIBRARY_PATH)\user32.lib

NT_CRT=$(LIBRARY_PATH)\nt.lib
WIN32_LIBS=$(LIBC_LIB) \
           $(LIBRARY_PATH)\advapi32.lib \
           $(LIBRARY_PATH)\kernel32.lib

NTSS_LIBS=$(NT_LIBS) $(NT_CRT) $(BASE_LIB_PATH)\smdll.lib

OS2_LIBS=$(NT_LIBS)  $(SDK_LIB_PATH)\os2dll.lib

!if "$(DRIVERTYPE)" == "wdm" || "$(DRIVERTYPE)" == "WDM"
# Building a WDM driver.  Default the subsystem version to the DDK version # (currently 1.0)
! ifndef SUBSYSTEM_VERSION
SUBSYSTEM_VERSION=1.10
! endif
!endif

!ifndef SUBSYSTEM_VERSION
! ifndef EXPECTED_WINVER
SUBSYSTEM_WINVER   = ,4.00
! else
SUBSYSTEM_WINVER   = ,$(EXPECTED_WINVER)
! endif
SUBSYSTEM_CONVER   = ,4.00
SUBSYSTEM_OS2VER   =
SUBSYSTEM_NATVER   =,$(SUBSYSTEM_VERSION_LATEST)
!else
SUBSYSTEM_WINVER   = ,$(SUBSYSTEM_VERSION)
SUBSYSTEM_CONVER   = ,$(SUBSYSTEM_VERSION)
SUBSYSTEM_OS2VER   = ,$(SUBSYSTEM_VERSION)
SUBSYSTEM_NATVER   = ,$(SUBSYSTEM_VERSION)

# Set the appropriate default WIN32_xxxxx values

! if "$(SUBSYSTEM_VERSION)" == "4.00"
!  ifndef WIN32_WINNT_VERSION
WIN32_WINNT_VERSION=0x0400
!  endif
!  ifndef WIN32_WIN95_VERSION
WIN32_WIN95_VERSION=0x0400
!  endif
!  ifndef WIN32_WCE_VERSION
WIN32_WCE_VERSION=0x0400
!  endif
!  ifndef WIN32_IE_VERSION
WIN32_IE_VERSION=0x0300
!  endif
! elseif "$(SUBSYSTEM_VERSION)" == "3.51"
!  ifndef WIN32_WINNT_VERSION
WIN32_WINNT_VERSION=0x0351
!  endif
!  ifndef WIN32_WIN95_VERSION
WIN32_WIN95_VERSION=0x0300
!  endif
!  ifndef WIN32_WCE_VERSION
WIN32_WCE_VERSION=0x0300
!  endif
!  ifndef WIN32_IE_VERSION
WIN32_IE_VERSION=0x0200
!  endif
!  ifndef WINVER_VERSION
WINVER_VERSION=0x0400            # Special case - WINVER was 4.00 for NT 3.51
!  endif
! elseif "$(SUBSYSTEM_VERSION)" == "3.50"
!  ifndef WIN32_WINNT_VERSION
WIN32_WINNT_VERSION=0x0350
!  endif
!  ifndef WIN32_WIN95_VERSION
WIN32_WIN95_VERSION=0x0300
!  endif
!  ifndef WIN32_WCE_VERSION
WIN32_WCE_VERSION=0x0300
!  endif
!  ifndef WIN32_IE_VERSION
WIN32_IE_VERSION=0x0100
!  endif
!  ifndef WINVER_VERSION
WINVER_VERSION=0x0400            # Special case - WINVER was 4.00 for NT 3.50
!  endif
! endif
!endif

#
# Set NTDDI_VERSION
#

!if "$(NTDDI_VERSION)" == ""

# Default
C_DEFINES=$(C_DEFINES) -DNTDDI_VERSION=$(_NTDDI_VERSION)
!else

# User specified
C_DEFINES=$(C_DEFINES) -DNTDDI_VERSION=$(NTDDI_VERSION)
!endif


CRT_INCLUDES=$(CRT_INC_PATH)
!ifdef USE_IOSTREAM
CRT_INCLUDES=$(CRT_INCLUDES);$(IOSTREAMS_INC_PATH)
!endif
!ifdef USE_STL
CRT_INCLUDES=$(CRT_INCLUDES);$(STL_INC_PATH)
!endif

!IF "$(UMTYPE)" == "nt"

SUBSYSTEM=native$(SUBSYSTEM_NATVER)
UMINCL=$(CRT_INCLUDES)

STD_CALL_ENTRY=1
UMENTRY=-entry:NtProcessStartup

UMLIBS=$(UMLIBS) $(NT_LIBS) $(NT_CRT)
NOT_TERMINAL_SERVER_AWARE=1

!ELSEIF "$(UMTYPE)" == "windows"

SUBSYSTEM=windows$(SUBSYSTEM_WINVER)
UMINCL=$(CRT_INCLUDES)

! IF "$(UMENTRY)" == "winmain"
UMENTRY=-entry:WinMainCRTStartup
! ELSEIF "$(UMENTRY)" == "wwinmain"
UMENTRY=-entry:wWinMainCRTStartup
! ELSEIF "$(UMENTRY)" == "wmain"
UMENTRY=-entry:wmainCRTStartup
! ELSEIF "$(UMENTRYABS)" == ""
UMENTRY=-entry:mainCRTStartup
! ELSE
UMENTRY=-entry:$(UMENTRYABS)
! ENDIF

UMLIBS=$(UMLIBS) $(WIN32_LIBS) $(GUI32_LIBS)

!ELSEIF "$(UMTYPE)" == "console"

SUBSYSTEM=console$(SUBSYSTEM_CONVER)
UMINCL=$(CRT_INCLUDES)

! IF "$(UMENTRY)" == "winmain"
UMENTRY=-entry:WinMainCRTStartup
! ELSEIF "$(UMENTRY)" == "wwinmain"
UMENTRY=-entry:wWinMainCRTStartup
! ELSEIF "$(UMENTRY)" == "wmain"
UMENTRY=-entry:wmainCRTStartup
! ELSEIF "$(UMENTRYABS)" == ""
UMENTRY=-entry:mainCRTStartup
! ELSE
UMENTRY=-entry:$(UMENTRYABS)
! ENDIF

!IF !$(MPPC)
UMLIBS=$(UMLIBS) $(WIN32_LIBS)
!ENDIF

!ELSEIF "$(UMTYPE)" == "ntss"

SUBSYSTEM=native$(SUBSYSTEM_NATVER)
UMINCL=$(CRT_INCLUDES)

STD_CALL_ENTRY=1
UMENTRY=-entry:NtProcessStartup
NOT_TERMINAL_SERVER_AWARE=1

!IF !$(MPPC)
UMLIBS=$(UMLIBS) $(NTSS_LIBS)
!ENDIF

!ELSEIF "$(UMTYPE)" == "os2"

SUBSYSTEM=os2$(SUBSYSTEM_OS2VER)
UMINCL=$(SDK_INC_PATH)\os2;$(CRT_INCLUDES)

STD_CALL_ENTRY=1
UMENTRY=-entry:NtProcessStartup
NOT_TERMINAL_SERVER_AWARE=1

UMLIBS=$(UMLIBS) $(OS2_LIBS)

!ELSE
! ERROR Invalid UMTYPE value - $(UMTYPE)
!ENDIF  # UMTYPE tests


#
# If you edit this line you need to modify $(BASEDIR)\sdktools\build\build.c
#

NTINCLUDES=$(OAK_INC_PATH);$(SDK_INC_PATH)

#
# Let drivers include files such as ntddk.h.
# WDM drivers\libs can only include wdm.h type of files though ...
# DDK_INC_PATH must be first for precedence.
#
!IF "$(DRIVERTYPE)" == "wdm" || "$(DRIVERTYPE)" == "WDM"
NTINCLUDES=$(NTINCLUDES);$(WDM_INC_PATH)
!ELSEIF "$(DRIVERTYPE)" == "fs" || "$(DRIVERTYPE)" == "FS"
NTINCLUDES=$(NTINCLUDES);$(DDK_INC_PATH);$(IFSKIT_INC_PATH)
!ELSEIF "$(TARGETTYPE)" == "DRIVER"        || \
        "$(TARGETTYPE)" == "EXPORT_DRIVER" || \
        "$(TARGETTYPE)" == "MINIPORT"      || \
        "$(TARGETTYPE)" == "DRIVER_LIBRARY"
NTINCLUDES=$(NTINCLUDES);$(DDK_INC_PATH);$(WDM_INC_PATH)
!ENDIF

#
# Add Windows Driver Framework inc if it is a WDF driver
#
!if defined(USE_WDF_DYNAMIC) || defined(USE_WDF_STATIC) || defined(USE_WDF)
NTINCLUDES=$(NTINCLUDES);$(DDK_INC_PATH)\wdf
!ENDIF

!IFNDEF CBSTRING
! IF "$(MAJORCOMP)" == "ntos" || \
     "$(MAJORCOMP)" == "NTOS" || \
     "$(TARGETTYPE)" == "DRIVER"         || \
     "$(TARGETTYPE)" == "DRIVER_LIBRARY" || \
     "$(TARGETTYPE)" == "GDI_DRIVER"     || \
     "$(TARGETTYPE)" == "HAL"            || \
     "$(TARGETTYPE)" == "EXPORT_DRIVER"  || \
     "$(TARGETTYPE)" == "MINIPORT"
!    IF "$(DRIVERTYPE)" != "VXD"
CBSTRING= -cbstring
!    ENDIF
! ELSE
CBSTRING=
! ENDIF
!ENDIF


!if "$(TARGETTYPE)" == "DRIVER_LIBRARY"
TARGETTYPE=LIBRARY
!endif

#
#  Add PROJECT_INC_PATH to NTINCLUDES, if NO_PRIVATE_INC is not set
#
!IFDEF PROJECT_INC_PATH
! IFNDEF NO_PRIVATE_INC
NTINCLUDES=$(PROJECT_ROOT)\inc;$(PROJECT_ROOT)\inc\$(O);$(PROJECT_INC_PATH);$(NTINCLUDES)
! ENDIF
!ENDIF

NTINCLUDES=$(O);$(NTINCLUDES)

!IFDEF INCLUDES_FROM
! IF [process-includes-from $(INCLUDES_FROM) >__makefile.def.tmp]
! ENDIF
! INCLUDE __makefile.def.tmp
! IF [del __makefile.def.tmp >nul 2>nul]
! ENDIF
!ENDIF

!IFDEF LIBS_FROM
! IF [process-libs-from $(LIBS_FROM) >__makefile.def.tmp]
! ENDIF
! INCLUDE __makefile.def.tmp
! IF [del __makefile.def.tmp >nul 2>nul]
! ENDIF
!ENDIF

!if "$(POCKETPC)" == ""
!IFNDEF COMPILER_WARNINGS
COMPILER_WARNINGS=-FI$(SDK_INC_PATH)\warning.h $(PROJECT_COMPILER_WARNINGS)
!ifdef USE_LINT
LINT_FORCEDINCS=$(LINT_FORCEDINCS) -header($(SDK_INC_PATH)\warning.h)
!endif
!ENDIF
!endif

# If you change this to 600, fix MIDL_OPTIMIZATION default below.
!ifndef WIN32_WINNT_VERSION
WIN32_WINNT_VERSION=$(LATEST_WIN32_WINNT_VERSION)
!endif

!ifndef WIN32_WIN95_VERSION
WIN32_WIN95_VERSION=$(LATEST_WIN32_WIN95_VERSION)
!endif

!ifndef WIN32_WCE_VERSION
WIN32_WCE_VERSION=$(LATEST_WIN32_WCE_VERSION)
!endif

!ifndef WIN32_IE_VERSION
WIN32_IE_VERSION=$(LATEST_WIN32_IE_VERSION)
!endif

!ifndef WINVER_VERSION
!if defined(CHICAGO_PRODUCT)
WINVER_VERSION=$(WIN32_WIN95_VERSION)
!elseif defined(POCKETPC)
WINVER_VERSION=$(WIN32_WCE_VERSION)
!else
WINVER_VERSION=$(WIN32_WINNT_VERSION)
!endif
!endif

!ifdef UNDEF_WINVER
_WINVER_VERSION=/UWINVER
!else
_WINVER_VERSION=/DWINVER=$(WINVER_VERSION)
!endif

!IF defined(POCKETPC)

NO_NTDLL=1
! IFNDEF WIN32_DEFINE
WIN32_DEFINE=-DWIN32=300 -D_WIN32_WCE=$(WIN32_WCE_VERSION) $(_WINVER_VERSION)
!  if "$(POCKETPC_EMULATION)" != ""
WIN32_DEFINE = $(WIN32_DEFINE) -D_WIN32_WCE_EMULATION
!  endif
! ENDIF

!ELSEIF defined(CHICAGO_PRODUCT)

NO_NTDLL=1
! IFNDEF WIN32_DEFINE
WIN32_DEFINE=-DWIN32=200 -D_CHICAGO_=200 -D_WIN32_WINDOWS=$(WIN32_WIN95_VERSION) $(_WINVER_VERSION)
! ENDIF

!ELSEIF $(MPPC)

! IFNDEF MAC_INCLUDES
MAC_INCLUDES=$(BASEDIR)\com\macdcom\dll\src\inc
MAC_INCLUDES=$(MAC_INCLUDES); $(SDK_INC_PATH)\mppc
MAC_INCLUDES=$(MAC_INCLUDES); $(SDK_INC_PATH)
MAC_INCLUDES=$(MAC_INCLUDES); $(SDK_INC_PATH)\mppc\macos
MAC_INCLUDES=$(MAC_INCLUDES); $(SDK_INC_PATH)\mppc\mrc
! ENDIF

NTINCLUDES= $(MAC_INCLUDES);$(NTINCLUDES)

NO_NTDLL=1
WIN32_DEFINE=-DPOWERMAC=1

!ELSE

WIN32_DEFINE=-DWIN32=100 -D_NT1X_=100 -DWINNT=1 -D_WIN32_WINNT=$(WIN32_WINNT_VERSION) $(_WINVER_VERSION)

!ENDIF

WIN32_DEFINE = $(WIN32_DEFINE) -D_WIN32_IE=$(WIN32_IE_VERSION)

INCLUDES     = $(INCLUDES: =)
NTINCLUDES   = $(NTINCLUDES: =)
UMINCL       = $(UMINCL: =)
MFC_INCLUDES = $(MFC_INCLUDES: =)
USER_INCLUDES =$(USER_INCLUDES: =)
ATL_INCLUDES = $(ATL_INCLUDES: =)
WTL_INCLUDES = $(WTL_INCLUDES: =)

# MFC, ATL, WTL, and USER first

INCPATH0=-I$(MFC_INCLUDES:;= -I) -I$(ATL_INCLUDES:;= -I) -I$(WTL_INCLUDES:;= -I) -I$(USER_INCLUDES:;= -I)
INCPATH1=-I$(MFC_INCLUDES:;= -I) -I$(ATL_INCLUDES:;= -I) -I$(WTL_INCLUDES:;= -I) -I$(USER_INCLUDES:;= -I)

# INCLUDES if set

!ifdef INCLUDES
INCPATH0 = $(INCPATH0) -I$(INCLUDES:;= -I)
INCPATH1 = $(INCPATH1) -I$(INCLUDES:;= -I)
!endif

# Finally NT and UM

INCPATH0=$(INCPATH0) -I$(NTINCLUDES:;= -I) -I$(UMINCL:;= -I)
INCPATH1=$(INCPATH1) -I$(NTINCLUDES:;= -I) -I$(UMINCL:;= -I)

# Remove empty "-I " settings (INCL/NTINCLUDES/UMINCL/MFC_INCLUDES macros may be empty above)

INCPATH0=$(INCPATH0:-I =)
INCPATH1=$(INCPATH1:-I =)
!ifdef USE_LINT
LINT_INCLUDES=-i$(TARGET_DIRECTORY)\ -i. $(LINT_PRECOMPPATH) $(INCPATH1:-I=-i)
!endif

!IFNDEF DLLENTRY
DLLENTRY=-noentry
!ELSE
! if "$(DLLENTRY:-entry:=)" == "$(DLLENTRY)"
DLLENTRY=-entry:$(DLLENTRY)
! endif
!ENDIF

!IF $(MPPC)
DLLENTRY=-noentry
!ENDIF

!IFNDEF DLLBASE
! IFDEF COFFBASE
DLLBASE=@$(COFFBASE_TXT_FILE),$(COFFBASE)
! ELSE
DLLBASE=@$(COFFBASE_TXT_FILE),$(TARGETNAME)
! ENDIF
!ENDIF

!IFNDEF DLLDEF
DLLDEF=$(@B).def
!ENDIF

!IFNDEF BOOTBASE
! IFDEF FRAZZLE
BOOTBASE=0xd0100000,0xd0104000
! ELSE
BOOTBASE=0xd0ff0000,0xd0ff4000
! ENDIF
!ENDIF

!IFNDEF DRIVERBASE
DRIVERBASE=0x10000
!ENDIF

!IFNDEF HALBASE
HALBASE=0x80010000
!ENDIF

!if "$(URTBASE)" != ""
! if "$(URT_VER)" == ""
URT_VER=1.2
! endif
# If the target doesn't support 1.0 or 1.1 (ia64/amd64) move to the next highest version
! if "$(URT_VER)" == "1.0" && "$(URT_VER_1_0)" == ""
URT_VER=1.1
! endif
! if "$(URT_VER)" == "1.1" && "$(URT_VER_1_1)" == ""
URT_VER=1.2
! endif
# Allow 1.2 or 1.1 or 1.0 - default to 1.2 if nothing
! if "$(URT_VER)" == "1.1"
COMPLUS_VERSION=$(URT_VER_1_1)
! elseif "$(URT_VER)" == "1.0"
COMPLUS_VERSION=$(URT_VER_1_0)
! elseif "$(URT_VER)" == "1.2"
COMPLUS_VERSION=$(URT_VER_1_2)
! else
!  message $(BUILD_ERROR_MSG) URT_VER not understood, should be 1.0 or 1.1 or 1.2 or not defined.
! endif

! if [set COMPLUS_VERSION=$(COMPLUS_VERSION)]
! endif
! if [set URT_VER=$(URT_VER)]
! endif

URTTARGET=$(URTBASE)\urt\$(COMPLUS_VERSION)
AC_NAME=$(NTMAKEENV)\AC\$(HOST_PROCESSOR_ARCHITECTURE)\AC.exe

! if (defined(MANAGED_CODE) || defined(MANAGED_VB) || defined(MANAGED_CXX)) || "$(URT_VER)" != "1.2"

PATH=$(URTTARGET);$(PATH)
!  if [set path=$(PATH)]
!  endif

! endif

!endif

!if (defined(MANAGED_CODE) || defined(MANAGED_VB) || defined(MANAGED_CXX))

!if [set URTTARGET=$(URTTARGET)]
!endif
!if defined(NEW_URT_VERSION)
C_DEFINES=$(C_DEFINES) /DNEW_URT_VERSION
!endif

#
# Need to stop managed code from having the PDB path embedded as binplace will strip
# this out and cause the hash to change.  This will break multi-file assemblies.
#
NO_PDB_PATHS=1

#
# The managed compilers emits comdat'd debug symbols that aren't related to anything else - if
# opt:ref is used, you can't effectively debug your code (yeah it's a lame bug).
#
LINKER_NOREF=1

!ifdef MANAGED_CXX

! if defined(NEW_MCPP_SYNTAX)
CLR_FLAGS=newSyntax
! else
CLR_FLAGS=oldSyntax
! endif

! if "$(MANAGED_TARGET_TYPE)" == "module"
LINKER_FLAGS=$(LINKER_FLAGS) /NoAssembly
CLR_FLAGS=$(CLR_FLAGS),noAssembly
! endif

! if $(386) && "$(URT_VER)" == "1.0"
CLR_FLAGS=$(CLR_FLAGS),initialAppDomain
! endif

! if "$(MCPP_TYPE)" == "pure"
CLR_FLAGS=$(CLR_FLAGS),pure
! elseif "$(MCPP_TYPE)" == "safe"
CLR_FLAGS=$(CLR_FLAGS),safe
! endif

USER_C_FLAGS=$(USER_C_FLAGS) /clr:$(CLR_FLAGS)

! ifndef NO_PRIVATE_NATIVE_TYPES
USER_C_FLAGS=$(USER_C_FLAGS) /d1PrivateNativeTypes
! endif
!endif

!if "$(ENABLE_NETMODULE_WARNINGS)" == "1"
! if "$(SUPPRESS_NETMODULE_WARNINGS)" != "1"
!  if "$(MANAGED_TARGET_TYPE)" == "module"
!   message $(BUILD_WARNING_MSG) MANAGED_TARGET_TYPE=module is deprecated.
!  endif
!  if "$(USER_CS_FLAGS:/addmodule:=)" != "$(USER_CS_FLAGS)"
!   message $(BUILD_WARNING_MSG) USER_CS_FLAGS containing /addmodule is deprecated.
!  endif
!  if "$(MANAGED_REFERENCES:/addmodule:=)" != "$(MANAGED_REFERENCES)"
!   message $(BUILD_WARNING_MSG) MANAGED_REFERENCES containing /addmodule is deprecated.
!  endif
! endif
!endif

!if "$(SUPPRESS_NETMODULE_ERRORS)" != "1"
! if defined(NETMODULES)
!  message $(BUILD_ERROR_MSG) NETMODULES is no longer supported.
! endif
!endif

!endif

!if (defined(MANAGED_CODE) || defined(MANAGED_VB))
#
# Figure out the target type if the user didn't specify.
#

! if !defined(MANAGED_TARGET_TYPE)
!  if "$(TARGETTYPE)" == "PROGRAM"
!   if "$(UMTYPE)" != "console"
MANAGED_TARGET_TYPE=winexe
!   else
MANAGED_TARGET_TYPE=exe
!   endif
!  elseif "$(TARGETTYPE)" == "DYNLINK"
MANAGED_TARGET_TYPE=library
!  endif
! endif

#
# tlbimp doesn't support /baseaddress - dummy up rebase_cmd so it can be called in makefile.inc
#

REBASE_CMD=rebase.exe -i $(COFFBASE_TXT_FILE) $@

#
# Generate a macro file to include for managed code base address
#

! if !defined(GENBASEMAC_CMD)
GENBASEMAC_CMD=$(_NTBINDIR)\tools\genbasemac.pl
! endif
! if "$(GENBASEMAC_CMD)"!=""
!    if !exist($(GENBASEMAC_CMD))
!     message NMAKE : Uxxxx: unable to find $(GENBASEMAC_CMD)
!    endif
!    message BUILD: $(GENBASEMAC_CMD) $(O) $(TARGETNAME) $(COFFBASE_TXT_FILE)
!    IF ([-perl $(GENBASEMAC_CMD) $(O) $(TARGETNAME) $(COFFBASE_TXT_FILE)])
!    ENDIF
!    IF EXIST( $(O)\coffbase.mac )
!        INCLUDE $(O)\coffbase.mac
!    ELSE
MANAGED_COFFBASE=0x400000
!    ENDIF
! endif

#
# Build up list of referenced modules for c# compiler
#

! if "$(REFERENCES)" != ""
!  IF $(386)
REFERENCES=$(REFERENCES:*=I386)
!  ELSEIF $(IA64)
REFERENCES=$(REFERENCES:*=IA64)
!  elseif $(AMD64)
REFERENCES=$(REFERENCES:*=AMD64)
!  endif
REFERENCES=$(REFERENCES: =)
MANAGED_REFERENCES=/r:$(REFERENCES:;= /r:)
! endif

#
# Define the standard switches
#

!if $(FREEBUILD)
MANAGED_DBG_FLAGS=/optimize+ /debug:pdbonly
!else
!if defined(MANAGED_VB)
MANAGED_DBG_FLAGS=/debug:full /define:DEBUG=1
!else
MANAGED_DBG_FLAGS=/debug:full /define:DEBUG
!endif
!endif

!ifdef NEW_URT_VERSION
MANAGED_DBG_FLAGS=$(MANAGED_DBG_FLAGS) /define:NEW_URT_VERSION
!endif

!if "$(MANAGED_RESOURCES)" != ""
MANAGED_RESOURCES=$(MANAGED_RESOURCES: =)
MANAGED_RESOURCES=/resource:$(MANAGED_RESOURCES:;= /resource:)
!endif

MANAGED_CODE_BUILD_TOOL= \
!if defined(MANAGED_VB)
    $(VB_NET_COMPILER_NAME)
!else
    $(CS_COMPILER_NAME)
!endif

# make sure csc.rsp is never used
MANAGED_CODE_BUILD_TOOL=$(MANAGED_CODE_BUILD_TOOL) /noconfig

MANAGED_CODE_DEFAULT_REFERENCES= \
!ifndef NO_DEFAULT_MANAGED_CODE_REFERENCES
    /r:$(URTTARGET)\Accessibility.dll \
    /r:$(URTTARGET)\Microsoft.Vsa.dll \
    /r:$(URTTARGET)\System.Configuration.Install.dll \
    /r:$(URTTARGET)\System.Data.dll \
    /r:$(URTTARGET)\System.Design.dll \
    /r:$(URTTARGET)\System.DirectoryServices.dll \
    /r:$(URTTARGET)\System.dll \
    /r:$(URTTARGET)\System.Drawing.Design.dll \
    /r:$(URTTARGET)\System.Drawing.dll \
    /r:$(URTTARGET)\System.EnterpriseServices.dll \
    /r:$(URTTARGET)\System.Management.dll \
    /r:$(URTTARGET)\System.Messaging.dll \
    /r:$(URTTARGET)\System.Runtime.Remoting.dll \
    /r:$(URTTARGET)\System.Runtime.Serialization.Formatters.Soap.dll \
    /r:$(URTTARGET)\System.Security.dll \
    /r:$(URTTARGET)\System.ServiceProcess.dll \
    /r:$(URTTARGET)\System.Web.dll \
    /r:$(URTTARGET)\System.Web.RegularExpressions.dll \
    /r:$(URTTARGET)\System.Web.Services.dll \
    /r:$(URTTARGET)\System.Windows.Forms.Dll \
    /r:$(URTTARGET)\System.XML.dll
!endif

MANAGED_CODE_BUILD_SWITCHES= \
    $(MANAGED_CODE_DEFAULT_REFERENCES) \
    $(MANAGED_CODE_BUILD_SWITCH_CUSTOM) \
    /target:$(MANAGED_TARGET_TYPE) \
    /out:$(TARGET) \
    /baseaddress:$(MANAGED_COFFBASE) \
    $(MANAGED_STD_FLAGS) \
    $(MANAGED_REFERENCES) \
    $(MANAGED_RESOURCES)

MANAGED_CODE_BUILD_CMD = \
    $(MANAGED_CODE_BUILD_TOOL) \
    $(MANAGED_CODE_BUILD_SWITCHES) \
    $(SOURCES)

REFERENCE_DIR=$(PROJECT_ROOT)\Reference\$(TARGET_DIRECTORY)

! IF "$(SERVICEBASE)" == ""
SERVICEBASE=http://localhost
! ENDIF

#
# Managed code always defined MAKEDLL (it's a single pass build after all).
#

MAKEDLL=1

!endif        # MANAGED_CODE || MANAGED_VB

#
# Map lower case to upper case for variables that can be specified from the
# command line.
#

!IFDEF nttest
NTTEST=$(nttest)
!ENDIF

!IFDEF makedll
MAKEDLL=$(makedll)
!ENDIF

#
# Include the list of object files (defined as the OBJECTS macro) that was
# built by BUILD program, using the SOURCES= macro defined in the sources.
# file.  Use macro substitution to build the supported target objects.
#

!if !exist($(_OBJ_DIR)\_objects.mac)
!if [-build -O]
!endif
!endif

!if "$(DO_NOTHING_MANAGED_CODE_NOT_ENABLED)" != "1"
!INCLUDE $(_OBJ_DIR)\_objects.mac
!endif

!IF $(386)
OBJECTS=$(386_OBJECTS)
MYMUILINK=$(MUI_386_OBJECTS)
DLLLIBOBJECTS=$(DLLLIBOBJECTS) $(386_DLLLIBOBJECTS)
!ELSEIF $(MPPC)
OBJECTS=$(MPPC_OBJECTS)
MYMUILINK=$(MUI_MPPC_OBJECTS)
DLLLIBOBJECTS=$(DLLLIBOBJECTS) $(MPPC_DLLLIBOBJECTS)
!ELSEIF $(IA64)
OBJECTS=$(IA64_OBJECTS)
MYMUILINK=$(MUI_IA64_OBJECTS)
DLLLIBOBJECTS=$(DLLLIBOBJECTS) $(IA64_DLLLIBOBJECTS)
!ELSEIF $(AMD64)
OBJECTS=$(AMD64_OBJECTS)
MYMUILINK=$(MUI_AMD64_OBJECTS)
DLLLIBOBJECTS=$(DLLLIBOBJECTS) $(AMD64_DLLLIBOBJECTS)
!ELSEIF $(ARM)
OBJECTS=$(ARM_OBJECTS)
MYMUILINK=$(MUI_ARM_OBJECTS)
DLLLIBOBJECTS=$(DLLLIBOBJECTS) $(ARM_DLLLIBOBJECTS)
!ENDIF

!ifdef MAC_RESOURCE
MAC_RESOURCE_OBJECT=$(_OBJ_DIR)\$(TARGET_DIRECTORY)\$(MAC_RESOURCE:.r=.rsc)
OBJECTS=$(OBJECTS) $(MAC_RESOURCE_OBJECT)
!endif

#
# BUILD.EXE defines the NOLINK variable to disable the building of any
# test executables when it is recursing on a dirs. file to build components
# in subdirectories.
#

!IF "$(BUILDMSG)" != "Stop."
! IFDEF NOLINK
!  UNDEF NTTEST
!  UNDEF MAKEDLL
! ELSE
!  IFDEF nolink
!   UNDEF NTTEST
!   UNDEF MAKEDLL
!  ENDIF
! ENDIF # DEF NOLINK
!ENDIF # BUILDMSG != "Stop."

!IF (!defined(MANAGED_CODE) && !defined(MANAGED_VB))
DYNLINK_LIB=$(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(TARGETNAME).lib
DYNLINK_LIBDIR=$(ALT_PROJECT_TARGET)\$(TARGET_DIRECTORY)\$(TARGETNAME).lib
!ENDIF

!IF "$(TARGETNAMEP)" != ""
DYNLINK_LIBP=$(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(TARGETNAMEP).lib
DYNLINK_LIBPDIR=$(ALT_PROJECT_TARGET)\$(TARGET_DIRECTORY)\$(TARGETNAMEP).lib
!ENDIF

!IF !$(MPPC)
DYNLINK_EXP=$(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(TARGETNAME).exp
!ENDIF

#
# Determine type of target link we are doing
#
!IF "$(TARGETTYPE)" == "PROGLIB"
! IF "$(TARGETEXT)" == ""
TARGETEXT=exe
! endif
TARGETLIB=
!ELSEIF "$(TARGETTYPE)" == "PROGRAM"
! IF "$(TARGETEXT)" == ""
TARGETEXT=exe
! endif
! ifdef USE_NTDLL
TARGETLIB=$(SDK_LIB_PATH)\ntdll.lib
! else
TARGETLIB=
! endif
!ELSEIF "$(TARGETTYPE)" == "DYNLINK"

! IF "$(MAKEDLL)" != ""
!  IF "$(TARGETNAME)" == "ntdll"
TARGETLIB=

!  ELSEIF defined (USE_NTDLL)           # USE_NTDLL never links with LIBC_LIB
TARGETLIB=$(WIN32DLL_LIBS) $(SDK_LIB_PATH)\ntdll.lib

!  ELSEIF defined (USE_SYSDLL)          # USE_SYSDLL uses either kernel32 (Win95) or ntdll (NT) for CRT support
!   if defined(CHICAGO_PRODUCT)
TARGETLIB=$(WIN32DLL_LIBS) $(SDK_LIB_PATH)\kernel32.lib
!   else
TARGETLIB=$(WIN32DLL_LIBS) $(SDK_LIB_PATH)\ntdll.lib
!   endif
!  ELSEIF defined (NO_NTDLL)            # NO_NTDLL never links with ntdll
TARGETLIB=$(WIN32DLL_LIBS) $(LIBC_LIB)

!  ELSE                                 # Everything else uses ntdll after libc.
TARGETLIB=$(WIN32DLL_LIBS) $(LIBC_LIB) $(SDK_LIB_PATH)\ntdll.lib

!  ENDIF
!  IF "$(TARGETEXT)" == ""
TARGETEXT=dll
!  ENDIF
! ELSE # "$(MAKEDLL)" != ""
TARGETEXT=lib
TARGETLIB=
! ENDIF # "$(MAKEDLL)" != ""

!ELSEIF "$(TARGETTYPE)" == "LIBRARY"
TARGETEXT=lib
TARGETLIB=

!ELSEIF "$(TARGETTYPE)" == "DRIVER"
TARGETEXT=sys
! if "$(DRIVERTYPE)" == "wdm" || "$(DRIVERTYPE)" == "WDM"
TARGETLIB=$(DDK_LIB_PATH)\wdm.lib
! ELSEIF "$(DRIVERTYPE)" == "VXD"
TARGETEXT=vxd
! ELSEIF "$(DRIVERTYPE)" == "fs" || "$(DRIVERTYPE)" == "FS"

!if $(_NT_TARGET_VERSION) >= 0x0600
TARGETLIB=$(DDK_LIB_PATH)\ntoskrnl.lib $(DDK_LIB_PATH)\hal.lib $(DDK_LIB_PATH)\wmilib.lib $(IFSKIT_LIB_PATH)\fltMgr.lib
!else
TARGETLIB=$(DDK_LIB_PATH)\ntoskrnl.lib $(DDK_LIB_PATH)\hal.lib $(DDK_LIB_PATH)\wmilib.lib
!endif

! ELSE
TARGETLIB=$(DDK_LIB_PATH)\ntoskrnl.lib $(DDK_LIB_PATH)\hal.lib $(DDK_LIB_PATH)\wmilib.lib
! ENDIF

#
# Add Windows Driver Framework lib if it is a WDF driver
#
!IF DEFINED(USE_WDF_DYNAMIC)
TARGETLIB=$(TARGETLIB) \
          $(DDK_LIB_PATH)\WdfDynamic.lib \
          $(DDK_LIB_PATH)\ntstrsafe.lib \
          $(DDK_LIB_PATH)\WdfLdr.lib \
          $(DDK_LIB_PATH)\WdfDriverEntry.lib 
!ELSEIF DEFINED(USE_WDF_STATIC)
TARGETLIB=$(TARGETLIB) \
          $(DDK_LIB_PATH)\WdfStatic.lib \
          $(DDK_LIB_PATH)\csq.lib \
          $(DDK_LIB_PATH)\ntstrsafe.lib \
          $(DDK_LIB_PATH)\wdmsec.lib 
!ELSEIF DEFINED(USE_WDF)
TARGETLIB=$(TARGETLIB) \
          $(DDK_LIB_PATH)\Wdf.lib \
          $(DDK_LIB_PATH)\csq.lib \
          $(DDK_LIB_PATH)\ntstrsafe.lib \
          $(DDK_LIB_PATH)\wdmsec.lib        
!ENDIF        

!ELSEIF "$(TARGETTYPE)" == "EXPORT_DRIVER"
! IF "$(MAKEDLL)" != ""
TARGETEXT=sys
!  if "$(DRIVERTYPE)" == "wdm" || "$(DRIVERTYPE)" == "WDM"
TARGETLIB=$(DDK_LIB_PATH)\wdm.lib
!  ELSEIF "$(DRIVERTYPE)" == "fs" || "$(DRIVERTYPE)" == "FS"
!if $(_NT_TARGET_VERSION) >= 0x0600
TARGETLIB=$(DDK_LIB_PATH)\ntoskrnl.lib $(DDK_LIB_PATH)\hal.lib $(DDK_LIB_PATH)\wmilib.lib $(IFSKIT_LIB_PATH)\fltMgr.lib
!else
TARGETLIB=$(DDK_LIB_PATH)\ntoskrnl.lib $(DDK_LIB_PATH)\hal.lib $(DDK_LIB_PATH)\wmilib.lib
!endif
!  ELSE
TARGETLIB=$(DDK_LIB_PATH)\ntoskrnl.lib $(DDK_LIB_PATH)\hal.lib $(DDK_LIB_PATH)\wmilib.lib
!  ENDIF

#
# Add Windows Driver Framework lib if it is a WDF export driver
#
!IF DEFINED(USE_WDF_DYNAMIC)
TARGETLIB=$(TARGETLIB) \
          $(DDK_LIB_PATH)\WdfDynamic.lib \
          $(DDK_LIB_PATH)\WdfLdr.lib \
          $(DDK_LIB_PATH)\WdfDriverEntry.lib \
          $(DDK_LIB_PATH)\ntstrsafe.lib \
          $(DDK_LIB_PATH)\wdm.lib
!ELSEIF DEFINED(USE_WDF_STATIC)
TARGETLIB=$(TARGETLIB) \
          $(DDK_LIB_PATH)\WdfStatic.lib \
          $(DDK_LIB_PATH)\csq.lib \
          $(DDK_LIB_PATH)\ntstrsafe.lib \
          $(DDK_LIB_PATH)\wdmsec.lib    \
          $(DDK_LIB_PATH)\usbd.lib \
          $(DDK_LIB_PATH)\wdm.lib
!ELSEIF DEFINED(USE_WDF)
TARGETLIB=$(TARGETLIB) \
          $(DDK_LIB_PATH)\Wdf.lib \
          $(DDK_LIB_PATH)\csq.lib \
          $(DDK_LIB_PATH)\ntstrsafe.lib \
          $(DDK_LIB_PATH)\wdmsec.lib
!ENDIF

! ELSE
TARGETEXT=lib
TARGETLIB=
! ENDIF

!ELSEIF "$(TARGETTYPE)" == "HAL"
! IF "$(MAKEDLL)" != ""
TARGETEXT=dll
TARGETLIB=$(DDK_LIB_PATH)\ntoskrnl.lib
! ELSE
TARGETEXT=lib
TARGETLIB=
! ENDIF

!ELSEIF "$(TARGETTYPE)" == "MINIPORT"
TARGETEXT=sys

!ELSEIF "$(TARGETTYPE)" == "GDI_DRIVER"

TARGETEXT=dll
TARGETLIB=$(DDK_LIB_PATH)\win32k.lib
!ifdef USE_LIBCNTPR_FOR_GDI_DRIVER_CRTS
TARGETLIB=$(SDK_LIB_PATH)\libcntpr.lib $(TARGETLIB)
!endif
!ENDIF # TARGETTYPE


TARGET=

!ifdef NOLIB
!undef NTTARGETFILE1
!endif

!IF "$(TARGETTYPE)" != "UMAPPL_NOLIB" && !defined(NOLIB) && !defined(NOTARGET)

! IF "$(OBJECTS)" != ""
TARGET=$(TARGETPATH)\*\$(TARGETNAME).$(TARGETEXT)
! ELSEIF "$(OBJLIBFILES)" != "" && "$(TARGETTYPE)" == "LIBRARY"
TARGET=$(TARGETPATH)\*\$(TARGETNAME).$(TARGETEXT)
! ENDIF

!ENDIF # TARGETTYPE != UMAPPL_NOLIB

!IFDEF NOTARGETLIB
TARGETLIB=
!ENDIF

!IFNDEF MACHINE_TARGETLIBS
MACHINE_TARGETLIBS=$(TARGETLIB) $(TARGETLIBS)
!ENDIF

!if (!defined(MANAGED_CODE) && !defined(MANAGED_VB))
TARGETOBJFILES=$(TARGETOBJFILES) $(OBJECTS)
!ENDIF

# DO_LSBUILD is a global enviroment setting applied at the razzle level
!if "$(DO_LSBUILD)" == "1"

# one sets e.g. LCX_MISCFILES=$(MISCFILES) in the "sources"

!  if "$(LOC_ROOT: =)" == ""
# we binplace localized MISCFILES counterparts into $(_NTTREE)\$(LOC_ROOT)
LCX_BINPLACE_ROOT=LCX\SRC
!  endif

# the -R argument overwrites
# the -O  argument unless
# -o comes after -R in binplace.exe command line
LCX_BINPLACE_FLAGS=-:TR .lcg  -o $(LCX_BINPLACE_ROOT) -v



!IF "$(LSBUILD_LANG)"==""
LSBUILD_LANG=0x0409
!ENDIF

# we build lcx from win32 MUI bits.
# the project might define BUILD_LCX to force binplace lcx files


!if "$(TARGETTYPE)" != "NOTARGET" && "$(TARGETNAME)" != ""

BUILD_LCX=1

!endif # $(TARGETTYPE)

!if "$(BUILD_PASS)" != "PASSALL"  && "$(BUILD_PASS)" != "PASS2"

BUILD_LCX=0

!endif

!if !(386)
LSBUILD_TOOL=
!else
LSBUILD_TOOL=$(RAZZLETOOLPATH)\x86\lsbuild\LSBUILD.exe
!endif # 386

!if !defined(LSBUILD_TOOL)  || !exists($(LSBUILD_TOOL))
BUILD_LCX=0
!message Warning: LSBUILD tool is not defined or not installed in your razzle
!endif # LSBUILD_TOOL

!if  "$(BUILD_LCX)" == "1"

LCX_TARGET=$(O)\$(TARGETNAME).$(TARGETEXT).lcg
# no rule for $(LCX_TARGET) yet: the dependency first 
LCX_DEPEND=

# our primary dependency is MUI in $(TARGETPATH)\$(TARGET_DIRECTORY)
# cannot use $(TARGET) macro here.
# 
# 

MUI_DEPEND=$(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).$(LINK_TARGETEXT).mui

!if exist($(MUI_DEPEND)) 
!message  LCX_DEPEND=$(MUI_DEPEND)
LCX_DEPEND=$(MUI_DEPEND)

!endif

# the inline file is used when executing the make rule.
# the language code from codes.txt, TPSettings.xml
# and possibly other file specific data from some helper app
# would be dynamically set at execution time


!if "$(TARGETPATH)" == ""  || "$(TARGETPATH)" == "obj" || "$(TARGETPATH)" == "OBJ"
_T=$(BASEDIR)\$(_PROJECT_)\$(ALT_PROJECT_TARGET)\$(O)
_T=$(O)
!else
_T=$(TARGETPATH)\$(TARGET_DIRECTORY)
!endif

# _O=$(BASEDIR)\$(_PROJECT_)\$(ALT_PROJECT_TARGET)\$(TARGETNAME)\$(O)

LCX_BUILD_CMD=$(LSBUILD_TOOL) parse /o $(LCX_TARGET)
#  /basepath $(_T)

# providing the flexible flags part and the dependency list
LCX_FLAGS=


# the generated LC files are always in $(O)
LCE_DEPEND=$(O)\$(TARGETNAME).res.rcx
LCI_DEPEND=$(TARGETNAME).$(TARGETEXT).lci

!if exist($(LCE_DEPEND))
# our possible dependency is lce (the mc.exe/rc.exe output file)
LCX_DEPEND=$(LCX_DEPEND) $(LCE_DEPEND)
LCX_FLAGS=$(LCX_FLAGS) /c $(LCE_DEPEND)
!endif  # LCE_DEPEND

!if exist($(LCI_DEPEND))
# our possible dependency is lci (dev commented file)
LCX_DEPEND=$(LCX_DEPEND) $(LCI_DEPEND)
LCX_FLAGS=$(LCX_FLAGS) /c $(LCI_DEPEND)
!endif  # LCI_DEPEND

!endif # BUILD_LCX

!endif  # DO_LSBUILD


#
# MUI LANGUAGE_NEUTRAL
#
!if !defined(LANGUAGE_NEUTRAL_EXCLUDE_FILE)
LANGUAGE_NEUTRAL_EXCLUDE_FILE=$(BASEDIR)\tools\PostBuildScripts\lgnexclude.txt
!endif
!if defined(DO_LANGUAGE_NEUTRAL)
!undef  DO_LANGUAGE_NEUTRAL
!endif
!if defined(LANGUAGE_NEUTRAL_STS)
!undef  LANGUAGE_NEUTRAL_STS
!endif
!if "$(TARGETTYPE)" == "DRIVER"  || "$(TARGETTYPE)" == "DRIVER_LIBRARY" || "$(TARGETTYPE)" == "GDI_DRIVER"  || \
    "$(TARGETTYPE)" == "HAL"     || "$(TARGETTYPE)" == "EXPORT_DRIVER"  || "$(TARGETTYPE)" == "MINIPORT" || \
    (  ("$(MAJORCOMP)" == "ntos" || "$(MAJORCOMP)"  == "NTOS")  &&  "$(TARGETTYPE)" != "LIBRARY"  )
DO_LANGUAGE_NEUTRAL_DRV=1
!endif


!if  "$(LANGUAGE_NEUTRAL)" == "1"
!  if  ( defined(DO_LANGUAGE_NEUTRAL_DRV) || "$(TARGETTYPE)" == "PROGRAM" || "$(TARGETTYPE)" == "PROGLIB"   || "$(TARGETTYPE)" == "DYNLINK" || ("$(TARGETTYPE)" == "NOTARGET" && defined(MISCFILES))  ) && (!defined(MANAGED_CODE) && !defined(MANAGED_VB)) 
!      undef LNEXCLUDEFILE
!      if EXIST($(LANGUAGE_NEUTRAL_EXCLUDE_FILE)) && "$(TARGETTYPE)" != "NOTARGET"
!         if [ @echo LNEXCLUDEFILE = \>$(O)\$(TARGETNAME:\=).$(TARGETTYPE).exclude]
!         endif !
!         if [ @findstr -i -m -r  "^$(TARGETNAME)\." $(LANGUAGE_NEUTRAL_EXCLUDE_FILE) >>$(O)\$(TARGETNAME:\=).$(TARGETTYPE).exclude 2>nul]
!         endif
!         if EXIST($(O)\$(TARGETNAME:\=).$(TARGETTYPE).exclude)
!         include $(O)\$(TARGETNAME:\=).$(TARGETTYPE).exclude
!         endif
!     endif
!      if ! defined(LNEXCLUDEFILE) || "$(LNEXCLUDEFILE)" == ""
DO_LANGUAGE_NEUTRAL=1
LANGUAGE_NEUTRAL_STS=LGNSTS_UNKNOWN
!      else
LANGUAGE_NEUTRAL_STS=LGNSTS_EXCLUDE
!      endif
!      if EXIST($(O)\$(TARGETNAME:\=).$(TARGETTYPE).exclude)
!         if [@del $(O)\$(TARGETNAME:\=).$(TARGETTYPE).exclude]
!         endif
!      endif
!  ELSE
!      if  "$(TARGETTYPE)" == "PROGRAM" || "$(TARGETTYPE)" == "DYNLINK"
LANGUAGE_NEUTRAL_STS=LGNSTS_MANAGED
!      endif
!      if  "$(TARGETTYPE)" == "DRIVER" || "$(TARGETTYPE)" == "GDI_DRIVER" || "$(TARGETTYPE)" == "EXPORT_DRIVER"  || "$(TARGETTYPE)" == "HAL" || "$(TARGETTYPE)" == "MINIPORT"
LANGUAGE_NEUTRAL_STS=LGNSTS_KERNEL
!      endif
!  ENDIF

!ELSE
!   IF  "$(LANGUAGE_NEUTRAL)" == "0"
LANGUAGE_NEUTRAL_STS=LGNSTS_PROJOFF
!   ENDIF
!ENDIF  #LANGUAGE_NEUTRAL == "1"


!if  "$(LANGUAGE_NEUTRAL)" == "1" && !defined(LANGUAGE_NEUTRAL_RESDIR)
LANGUAGE_NEUTRAL_RESDIR=muires_0409
!endif

#
# MUI Manifest
#
!if  defined(DO_LANGUAGE_NEUTRAL)
! if !defined(DO_LANGUAGE_NEUTRAL_DRV) 
MUI_MANIFEST_ROOT_SOURCE=$(NTMAKEENV)\MUI.MUImanifest
! else
MUI_MANIFEST_ROOT_SOURCE=$(NTMAKEENV)\MUI_DRV.MUImanifest
! endif
MUI_MANIFEST_ROOT=$(NTMAKEENV)
! if ! defined(MUI_MANIFEST)
!    if !defined(DO_LANGUAGE_NEUTRAL_DRV) 
MUI_MANIFEST=MUI.MUImanifest
!    else
MUI_MANIFEST=MUI_DRV.MUImanifest
!    endif
! endif
MUI_MANIFEST_SOURCE_FILENAME=$(MUI_MANIFEST:..\=)
MUI_MANIFEST_BASENAME=$(MUI_MANIFEST_SOURCE_FILENAME) 
MUI_MANIFEST_BASENAME=$(MUI_MANIFEST_BASENAME:.MUImanifest=)
MUI_MANIFEST_BASENAME=$(MUI_MANIFEST_BASENAME:.muimanifest=)
MUI_MANIFEST_BASENAME=$(MUI_MANIFEST_BASENAME:.muiManifest=)
MUI_MANIFEST_BASENAME=$(MUI_MANIFEST_BASENAME:.MUIManifest=)
MUI_MANIFEST_OBJ1=$(O)\$(MUI_MANIFEST_BASENAME).mmf
MAKE_MUI_MANIFEST_CMD=nmake -nologo $(MUI_MANIFEST_OBJ1)
MUI_MANIFEST_DEFINES= 
MUI_MANIFEST_PREPROCESSOR_NAME=preprocessor.exe
! if "$(TARGETTYPE)" != "NOTARGET"
LANGUAGE_NEUTRAL_RESOURCE = -q $(MUI_MANIFEST_OBJ1)
! else
LANGUAGE_NEUTRAL_RESOURCE=
! endif
LANGUAGE_NEUTRAL_RESOURCE_BINPLACE = -J$(MUI_MANIFEST_OBJ1)
!else
MAKE_MUI_MANIFEST_CMD=
LANGUAGE_NEUTRAL_RESOURCE=
LANGUAGE_NEUTRAL_RESOURCE_BINPLACE=
!endif 


!IF "$(NOLINK)" == "" ||                                     \
    ("$(NOLINK)" != "" && ("$(TARGETTYPE)"=="LIBRARY" ||     \
                        (   ("$(TARGETTYPE)"=="DYNLINK" ||   \
                         "$(TARGETTYPE)"=="PROGLIB" || \
                         "$(TARGETTYPE)"=="EXPORT_DRIVER" || \
                         "$(TARGETTYPE)"=="HAL")    &&       \
                            "$(MAKEDLL)" == "")              \
                           )                                 \
    )


! IF "$(NOLINK)" != "" && "$(TARGET)" != ""
!  ifndef NO_DLL_EXPORTS
TARGETLIBFILES=$(TARGETLIBFILES) $(TARGETPATH)\*\$(TARGETNAME).lib
!  endif
! ELSE
TARGETEXEFILES=$(TARGETEXEFILES) $(TARGET)
! ENDIF

!ENDIF # NOLINK == "" || building .lib file for dll

!if "$(UMAPPL)" == ""
# Turn off UMEXEFILES/UMOBJFILES (handles case where it's conditional in sources file
# and build doesn't realize it when generating _objects.mac).
UMEXEFILES=
UMOBJFILES=
!else
# Temporary - add old UMEXE/UMOBJFILES support until new build.exe prop's everywhere
! if !defined(UMEXEFILES) || !defined(UMOBJFILES)
UMOBJFILES=obj\*\$(UMAPPL:*=.obj obj\*\).obj
!  IFNDEF NOLINK
!   IF "$(UMAPPLEXT)" == ".com"
UMEXEFILES=obj\*\$(UMAPPL:*=.com obj\*\).com
!   ELSEIF "$(UMAPPLEXT)" == ".exe"
UMEXEFILES=obj\*\$(UMAPPL:*=.exe obj\*\).exe
!   ELSEIF "$(UMAPPLEXT)" == ".scr"
UMEXEFILES=obj\*\$(UMAPPL:*=.scr obj\*\).scr
!   ELSE
!    ERROR Unsupport UMAPPLEXT = $(UMAPPLEXT)
!   ENDIF
!  ENDIF
! endif
!endif

!IF "$(NTTEST)" != ""

TARGETOBJFILES=$(TARGETOBJFILES) $(O)\$(NTTEST).obj

! IFNDEF NOLINK

TARGETEXEFILES=$(TARGETEXEFILES) $(O)\$(NTTEST).exe

! ENDIF # NDEF NOLINK
!ENDIF # NTTEST != ""

!IFDEF USE_LINT
! IFNDEF LINT_OUTPUT
LINT_OUTPUT=$(TARGETNAME)
! ENDIF
! IFNDEF LINT_EXT
LINT_EXT=tmp
! ENDIF
! IF "$(LINT_TYPE)" == "all"
TARGETLOBFILES1=
TARGETLOBFILES2=$(O)\$(LINT_OUTPUT).$(LINT_EXT)
! ELSEIF "$(LINT_TYPE)" == "lob"
TARGETLOBFILES1=$(TARGETOBJFILES:.obj=.lob)
TARGETLOBFILES2=
! ELSE
TARGETLOBFILES1=
TARGETLOBFILES2=$(TARGETOBJFILES:.obj=.lob)
! ENDIF
!ELSE
TARGETLOBFILES1=
TARGETLOBFILES2=
!ENDIF

#
# Define NT_UP as 0 in environment to turn on MP.
# If undefined or equal to 1, you get UP.
#

!IFNDEF NT_UP
NT_UP=1
!ENDIF

!IF "$(NT_UP)"=="0"
NT_UP_DEFINES=
!ELSE
NT_UP_DEFINES=-DNT_UP=1
!ENDIF

!IFNDEF NT_INST
NT_INST=0
!ENDIF

#
# User defined variables (environment variables or command line).
# A cpu specific definition will take precedence over the MSC definition.
#
# xxx_WARNING_LEVEL
# xxx_OPTIMIZATION
# xxx_CPPFLAGS
#

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF

DEFAULT_MSC_OPT = /Oxs

#
# End of user defined variables.
#

STD_DEFINES=-DCONDITION_HANDLING=1 $(NT_UP_DEFINES) \
            -DNT_INST=$(NT_INST) $(WIN32_DEFINE) $(NT_PNP_POWER_DEFINES) \
            $(NT_PNP_STUB_DEFINES)

!IFNDEF NOT_LEAN_AND_MEAN
STD_DEFINES = $(STD_DEFINES) -DWIN32_LEAN_AND_MEAN=1
!ENDIF

!if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
TARGET_DBG_DEFINES= -DDEVL=1 -DDBG=1
!else
TARGET_DBG_DEFINES= -DDEVL=1
!endif

!if !defined(RESOURCE_ONLY_DLL) || \
    ("$(NTDEBUG)" == "ntsd") || \
    ("$(NTDEBUG)" == "ntsdnodbg") || \
    ("$(NTDEBUG)" == "cvp") || \
    ("$(NTDEBUG)" == "sym")
DBGFLAGS=/Zi
!else
DBGFLAGS=
!endif

!ifdef OFFICIAL_BUILD_MACHINE
TARGET_DBG_DEFINES=$(TARGET_DBG_DEFINES) -DOFFICIAL_BUILD=1
!endif

!ifndef __BUILDMACHINE__
__BUILDMACHINE__=$(USERNAME: =)
!endif
TARGET_DBG_DEFINES=$(TARGET_DBG_DEFINES)\
!ifdef BUILDDATE
    -D__BUILDDATE__=$(BUILDDATE)\
!endif
    -D__BUILDMACHINE__=$(__BUILDMACHINE__)

!IF "$(PRECOMPILED_OPTION)" == ""
! IF "$(PRECOMPILED_INCLUDE)" != ""
!  IF "$(PRECOMPILED_INCLUDE)" != "$(PRECOMPILED_INCLUDE:.hxx=)"
PRECOMPILED_CXX=1
!  ENDIF
!  IF "$(PRECOMPILED_INCLUDE)" != "$(PRECOMPILED_INCLUDE:.hpp=)"
PRECOMPILED_CXX=1
!  ENDIF
!  IF "$(PRECOMPILED_INCLUDE)" != "$(PRECOMPILED_INCLUDE:.cxx=)"
PRECOMPILED_CXX=1
!  ENDIF
!  IF "$(PRECOMPILED_INCLUDE)" != "$(PRECOMPILED_INCLUDE:.cpp=)"
PRECOMPILED_CXX=1
!  ENDIF
!  IF "$(PRECOMPILED_PCH)" == ""
PRECOMPILED_PCH=$(PRECOMPILED_INCLUDE:.hxx=.pch)
PRECOMPILED_PCH=$(PRECOMPILED_PCH:.hpp=.pch)
PRECOMPILED_PCH=$(PRECOMPILED_PCH:.h=.pch)
PRECOMPILED_PCH=$(PRECOMPILED_PCH:.cxx=.pch)
PRECOMPILED_PCH=$(PRECOMPILED_PCH:.cpp=.pch)
PRECOMPILED_PCH=$(PRECOMPILED_PCH:.c=.pch)
PRECOMPILED_PCH=$(PRECOMPILED_PCH:..\=)
!  ENDIF
!  IF "$(PRECOMPILED_OBJ)" == ""
PRECOMPILED_OBJ=$(PRECOMPILED_PCH:.pch=.obj)
!  ENDIF
! ENDIF
!ENDIF

!IF "$(PRECOMPILED_OPTION)" == ""
! IF "$(PRECOMPILED_INCLUDE)" != ""
!  IF "$(PRECOMPILED_PCH)" != ""
HEADERFILE=/Fp$(O)\$(PRECOMPILED_PCH)
!  ENDIF
!  IF "$(PRECOMPILED_OBJ)" != ""
HEADEROBJNAME=$(O)\$(PRECOMPILED_OBJ)
HEADEROBJ=/Fo"$(MAKEDIR)\$(HEADEROBJNAME)"
!  ENDIF

!  IF !$(MPPC)
!   IF "$(PRECOMPILED_CXX)" == ""
PRECOMPILED=/Yu$(PRECOMPILED_INCLUDE:..\=) $(HEADERFILE)
PRECOMPILED_CXX=
!   ELSE
PRECOMPILED=
PRECOMPILED_CXX=/Yu$(PRECOMPILED_INCLUDE:..\=) $(HEADERFILE)
!   ENDIF
!  ENDIF
PRECOMPILED_TARGET=$(O)\$(PRECOMPILED_PCH)
! ELSE
PRECOMPILED=
PRECOMPILED_CXX=
! ENDIF
!ELSE
! IF "$(PRECOMPILED_CXX)" == ""
PRECOMPILED=$(PRECOMPILED_OPTION)
PRECOMPILED_CXX=
! ELSE
PRECOMPILED=
PRECOMPILED_CXX=$(PRECOMPILED_OPTION)
! ENDIF
PRECOMPILED_TARGET=$(PRECOMPILED_TARGET)
! IF "$(PRECOMPILED_TARGET)" != ""
HEADERFILE=/Fp$(PRECOMPILED_TARGET)
! ENDIF
! IF "$(PRECOMPILED_OBJ)" != ""
HEADEROBJNAME=$(PRECOMPILED_OBJ)
HEADEROBJ=/Fo$(HEADEROBJNAME)
! ENDIF
!ENDIF

!IF "$(NTNOPCH)" != ""
# Need to do this conditionally.  If the pch obj exists, it's likely existing files
# reference it (ie: this isn't a clean build).  Keep the file ref but delete the
# pch stuff so links will work.
!ifdef HEADEROBJNAME
!if !exist($(HEADEROBJNAME))
HEADEROBJNAME=
HEADEROBJ=
PRECOMPILED_OBJ=
!if [del $(O)\_headerobjname.inc 2>nul]
!endif
!else
#
# Clearing PRECOMPILED_PCH below makes the delayed evaluation of HEADEROBJNAME
# be just objfre\i386\, which nmake complains it does not know how to make,
# and which causes stdinc.obj to not be put in the .lib.
#
# Force the evaluation of HEADEROBJNAME.
#
!if [-mkdir $(O) 2>nul] && [echo HEADEROBJNAME=$(HEADEROBJNAME) > $(O)\_headerobjname.inc]
!endif
!endif
!endif
PRECOMPILED=
PRECOMPILED_CXX=
PRECOMPILED_INCLUDE=
PRECOMPILED_TARGET=
PRECOMPILED_PCH=
!if defined(HEADEROBJNAME) && exist($(O)\_headerobjname.inc)
!include $(O)\_headerobjname.inc
!endif
!ENDIF



USECXX_FLAG=$(USECXX_FLAG:p=P)

!IF ("$(PRECOMPILED_CXX)" == "") && ("$(USECXX_FLAG)" == "")
PRECOMPILED_FLAG=$(PRECOMPILED_FLAG) /Tc
!ELSE
PRECOMPILED_FLAG=$(PRECOMPILED_FLAG) /Tp
!ENDIF

#
# Set linker options
#

#
# Merge _PAGE with PAGE, _TEXT with .text, and make sure
# INIT sections are discardable
#

!if !$(MPPC)
!ifdef LINKER_NOREF
LINK_REF_FLAG=-OPT:NOREF -OPT:NOICF
!else
! ifdef LINKER_NOICF
LINK_REF_FLAG=-OPT:REF -OPT:NOICF
! else
LINK_REF_FLAG=-OPT:REF -OPT:ICF
! endif
!endif
!endif

!ifdef NOT_TERMINAL_SERVER_AWARE
TSLINKER_FLAG=
!else
!       if $(_NT_TOOLS_VERSION) >= 0x700
TSLINKER_FLAG=/tsaware
!       else
TSLINKER_FLAG=
!       endif
!endif

DEFAULT_LINK_LIB_IGNORE=4010,4037,4039,4065,4070,4078,4087,4089,4221
!if "$(BUILD_PRODUCT)" == "NT" || defined(LINK_ALLOW_MISSING_BASE_ADDRESS)
# Missing base address not interesting for OS (entire product rebased at postbuild time)
DEFAULT_LINK_LIB_IGNORE=$(DEFAULT_LINK_LIB_IGNORE),4198
!endif

!ifdef LINK_LIB_IGNORE
LINK_LIB_IGNORE_FLAG=-IGNORE:$(LINK_LIB_IGNORE),$(DEFAULT_LINK_LIB_IGNORE)
!else
LINK_LIB_IGNORE_FLAG=-IGNORE:$(DEFAULT_LINK_LIB_IGNORE)
!endif

!IF $(IA64)
LINK_LIB_IGNORE_FLAG= $(LINK_LIB_IGNORE_FLAG),4108,4088,4218
!ENDIF

!if defined(LINK_TIME_CODE_GENERATION) && !defined(FORCENATIVEOBJECT)
# 4218: non-native module found; restarting link with /LTCG
# 4235: /LTCG specified but no code generation required; remove /LTCG from the link command line to improve linker performance
LINK_LIB_IGNORE_FLAG= $(LINK_LIB_IGNORE_FLAG),4218,4235
!endif

!ifdef LINK_NO_RELEASE
LINK_RELEASE=
!else
LINK_RELEASE=/release
!endif

!ifdef USE_INCREMENTAL_LINKING
LINK_INCREMENTAL_FLAG = -OPT:NOREF \
                        $(LINK_LIB_IGNORE_FLAG)
!else
LINK_INCREMENTAL_FLAG = $(LINK_REF_FLAG) \
                        $(LINK_LIB_IGNORE_FLAG) \
                        -INCREMENTAL:NO \
                        -FULLBUILD \
                        $(LINK_RELEASE)
!endif

!ifdef LARGE_ADDRESS_AWARE
LINKER_FLAGS = $(LINKER_FLAGS) -LARGEADDRESSAWARE
!endif

LINK_TIME_CODE_GENERATION_LINKER_FLAGS=
!if defined(LINK_TIME_CODE_GENERATION) && !defined(FORCENATIVEOBJECT)
# If NTPOGO is true or NTPOGO_TARGENAME is defined, a package is
# generated in $(_NTTREE)\POGO\$(NTPOGO_TARGETNAME) that contains
# all of files necessary to build a POGO instrumented/optimized binary.
# pgi.cmd and pgo.cmd are generated to do the PGI and PGO builds.
!if (defined(NTPOGO) || defined(NTPOGO_TARGETNAME)) && defined(_NTPOGODIR)
!if !defined(NTPOGO_TARGETNAME)
NTPOGO_TARGETNAME=$(TARGETNAME)
!endif
NTPOGO_TARGETDIR=$(_NTTREE)\$(_NTPOGODIR)\$(NTPOGO_TARGETNAME)
!if [rmdir /s /q $(NTPOGO_TARGETDIR)]
!endif
!if [-mkdir $(NTPOGO_TARGETDIR) >nul 2>&1]
!endif
# Profiling has to be turned off for POGO (link.rsp is now emitted as a unicode file, so pipe it to stdout for findstr to work).
!if [@echo type link.rsp ^| findstr -i -v -r "[-/^]order:@" ^> pogo.rsp > $(NTPOGO_TARGETDIR)\pgi.cmd]
!endif
!if [@echo type link.rsp ^| findstr -i -v -r "[-/^]order:@" ^> pogo.rsp > $(NTPOGO_TARGETDIR)\pgo.cmd]
!endif
# Kernel?
!if (("$(MAJORCOMP)" == "ntos" || "$(MAJORCOMP)" == "NTOS") && \
     ("$(MINORCOMP)" == "init" || "$(MINORCOMP)" == "INIT")) || \
    ("$(TARGETTYPE)" == "HAL")
!if [@copy $(ENDUSER_LIB_PATH)\pogortntos.lib $(NTPOGO_TARGETDIR)]
!endif
!if [@echo link @pogo.rsp -ltcg:PGI pogortntos.lib -d2:-PogoNtoskrnl >> $(NTPOGO_TARGETDIR)\pgi.cmd]
!endif
!if [@echo link @pogo.rsp -ltcg:PGO -d2:-PogoNtoskrnl >> $(NTPOGO_TARGETDIR)\pgo.cmd]
!endif
# Driver?
!elseif (("$(TARGETTYPE)" == "DRIVER") || ("$(TARGETTYPE)" == "EXPORT_DRIVER"))
!if [@copy $(ENDUSER_LIB_PATH)\pogortsys.lib $(NTPOGO_TARGETDIR)]
!endif
!if [@echo link @pogo.rsp -ltcg:PGI pogortsys.lib -d2:-PogoKmode >> $(NTPOGO_TARGETDIR)\pgi.cmd]
!endif
!if [@echo link @pogo.rsp -ltcg:PGO -d2:-PogoKmode >> $(NTPOGO_TARGETDIR)\pgo.cmd]
!endif
# Neither kernel or driver?
!else
!if [@copy $(ENDUSER_LIB_PATH)\pogort.lib $(NTPOGO_TARGETDIR)]
!endif
!if [@echo link @pogo.rsp -ltcg:PGI pogort.lib >> $(NTPOGO_TARGETDIR)\pgi.cmd]
!endif
!if [@echo link @pogo.rsp -ltcg:PGO >> $(NTPOGO_TARGETDIR)\pgo.cmd]
!endif
!endif
LINKER_FLAGS=$(LINKER_FLAGS) -linkrepro:$(NTPOGO_TARGETDIR)
!endif
LINK_TIME_CODE_GENERATION_LINKER_FLAGS=-ltcg
LINKER_FLAGS=$(LINKER_FLAGS) $(LINK_TIME_CODE_GENERATION_LINKER_FLAGS)
!endif

!if $(MPPC)
LINKER_FLAGS =  $(LINKER_FLAGS) \
                -SECTION:INIT,d \
                $(LINK_INCREMENTAL_FLAG) \
                -NODEFAULTLIB

!else
LINKER_FLAGS =  $(LINKER_FLAGS) \
                -MERGE:_PAGE=PAGE \
                -MERGE:_TEXT=.text \
                -SECTION:INIT,d \
                $(LINK_INCREMENTAL_FLAG) \
                -NODEFAULTLIB

!endif

LINKER_FLAGS=$(LINKER_FLAGS) $(LINKER_WX_SWITCH)

LINK_OS_VERSIONS = -version:$(LINKER_APP_VERSION) -osversion:$(LINKER_OS_VERSION)

!IF $(MPPC)

#*****MacPPC linker flags

TARGET_DIRECTORY=mppc
UMLIBS=$(UMLIBS:*=mppc)
LINKLIBS=$(LINKLIBS:*=mppc)
DLLDEF=$(DLLDEF:*=mppc)
PRECOMPILED_TARGET= $(PRECOMPILED_TARGET:*=mppc)
PRECOMPILED_OBJ= $(PRECOMPILED_OBJ:*=mppc)
PRECOMPILED_OPTION= $(PRECOMPILED_OPTION:*=mppc)

#
# Set the default creator and type.  If were building a dll then use
# cfmg and shlb, for apps use ???? and APPL.
#

!ifndef MAC_CREATOR
!if "$(TARGETTYPE)" == "DYNLINK"
MAC_CREATOR=cfmg
!else
MAC_CREATOR=????
!endif
!endif

!ifndef MAC_TYPE
!if "$(TARGETTYPE)" == "DYNLINK"
MAC_TYPE=shlb
!else
MAC_TYPE=APPL
!endif
!endif

#
# MAC_CREATOR and MAC_TYPE may contain embedded spaces.  To do this we need to
# enclose their operand in quotes.  Now get rid of the quotes leaving the spaces
#

MAC_CREATOR=$(MAC_CREATOR:^"=)
MAC_TYPE=$(MAC_TYPE:^"=)

#
# Setup for the linker
#


!if "$(TARGETTYPE)"=="DYNLINK"
LINKER_FLAGS=$(LINKER_FLAGS) -mac:nobundle -dll -def:$(DLLDEF)
LINKER_FLAGS=$(LINKER_FLAGS) -mac:MFILEPAD
LINKER_FLAGS=$(LINKER_FLAGS) -mac:init="$(MAC_INITPROC)"
LINKER_FLAGS=$(LINKER_FLAGS) -mac:term="$(MAC_TERMPROC)"
!else
LINKER_FLAGS=-mac:bundle
!endif

LINKER_FLAGS=$(LINKER_FLAGS) -mac:type="$(MAC_TYPE)"
LINKER_FLAGS=$(LINKER_FLAGS) -mac:creator="$(MAC_CREATOR)"
LINKER_FLAGS=$(LINKER_FLAGS) -debug
LINKER_FLAGS=$(LINKER_FLAGS) -debugtype:both
LINKER_FLAGS=$(LINKER_FLAGS) -NODEFAULTLIB

#*****End Mac linker flags
!ELSE
LINKER_FLAGS = $(LINKER_FLAGS) $(LINKER_DBG_SECTION) -debugtype:cv $(LINK_OS_VERSIONS)
!ENDIF

LIBRARIAN_FLAGS = $(LINK_LIB_IGNORE_FLAG) $(LIBRARIAN_FLAGS) $(LINKER_WX_SWITCH) -nodefaultlib
LIBRARIAN_FLAGS = $(LIBRARIAN_FLAGS) -machine:$(MACHINE_TYPE)

LINK_TIME_CODE_GENERATION_LIBRARIAN_FLAGS =
!if defined(LINK_TIME_CODE_GENERATION) && !defined(FORCENATIVEOBJECT)
LINK_TIME_CODE_GENERATION_LIBRARIAN_FLAGS = -ltcg
LIBRARIAN_FLAGS = $(LIBRARIAN_FLAGS) $(LINK_TIME_CODE_GENERATION_LIBRARIAN_FLAGS)
!endif

!ifndef LIB_NAME
LIB_NAME=lib
!endif

LIBRARIAN=$(LIB_NAME) -out:$@ $(LIBRARIAN_FLAGS)

!ifndef LINK_NAME
LINK_NAME=link
!endif

LINKER=$(LINK_NAME) -out:$@ -machine:$(MACHINE_TYPE)

!if defined(NTPROFILEINPUT) && ("$(TARGETTYPE)" == "LIBRARY")
! message NTPROFILEINPUT should be removed in: $(MAKEDIR).
!endif

!IF defined(NTPROFILEINPUT) || defined(EXEPROFILEINPUT)
ORDER=-order:@$(@B).prf
!ENDIF

!IFDEF DLLORDER
ORDER=-order:@$(DLLORDER)
!ENDIF

!if "$(SUBSYSTEM_NATVER)" != ",5.02" && \
    "$(SUBSYSTEM_NATVER)" != ",6.00"
! ifndef DRIVER_ALIGNMENT
DRIVER_ALIGNMENT=0x80
! endif
! ifndef HAL_ALIGNMENT
HAL_ALIGNMENT=0x80
! endif
! ifndef KERNEL_ALIGNMENT
KERNEL_ALIGNMENT=0x80
! endif
!endif

!ifdef DRIVER_ALIGNMENT
DRIVER_ALIGN_SWITCH=-align:$(DRIVER_ALIGNMENT) /stub:$(SDK_LIB_DEST)\stub512.com
!endif
!ifdef HAL_ALIGNMENT
HAL_ALIGN_SWITCH=-align:$(HAL_ALIGNMENT) /stub:$(SDK_LIB_DEST)\stub512.com
!endif
!ifdef KERNEL_ALIGNMENT
KERNEL_ALIGN_SWITCH=-align:$(KERNEL_ALIGNMENT) /stub:$(SDK_LIB_DEST)\stub512.com
!endif

#
# [GorN] 3/30/2000
#
#    WPP section (WMI tracing preprocessor)
#
#    env. vars:
#
#    RUN_WPP=list of files to run wpp on
#    WPP_REVISION=override default revision
#


!if !defined(WPP_REVISION)
WPP_REVISION=rev1
!endif

!if !defined(WPP_NAME)
WPP_NAME=tracewpp.exe
!endif

!if $(ANSI_ANNOTATION)
WPP_MAKEFILE_FLAGS=-DWPP_ANSI_ANNOTATION
!endif

!if defined(RUN_WPP)
RUN_WPP=$(WPP_MAKEFILE_FLAGS) -cfgdir:$(WPP_CONFIG_PATH)\$(WPP_REVISION) -odir:$(O) $(RUN_WPP)


#  execute wpp now

!message BUILDMSG2: $(WPP_NAME)
!if [-$(WPP_NAME) $(RUN_WPP)]
!endif

!  if exist(obj\_tracewpp.mac)
!     include obj\_tracewpp.mac
WPP_TARGETS=$(WPP_EXTRA_TARGETS)
!  endif
BINPLACE_FLAGS = $(BINPLACE_FLAGS) -:TMF
C_DEFINES=$(C_DEFINES) -DRUN_WPP
!else
WPP_TARGETS=
!endif



#
# LINT section
#
# Main env. vars:
# USE_LINT=1 to turn on PC-lint processing
# LINT_TYPE={all,lob,<nothing>}
#           all - processes all $(SOURCES) files at once
#           lob - processes $(SOURCES) individually and then consolidates
#           <nothing> - processes $(SOURCES) individually (like John Daly's tool)
#
# Other env. vars:
# LINT_PATH=path to PC-lint directory (default=$(BASEDIR)\lint)
# LINT_APP=name of PC-lint executable (default=lint-nt)
# LINT_OUTPUT=base name of lint output file (default=$(TARGETNAME))
# LINT_EXT=extension of output files (default=tmp)
# LINT_FORCEDINCS=list of forced include files. same as in -FI compiler switch
# LINT_OPTS=options passed to PC-lint (default=+v -zero)
# LINT_PRECOMPPATH=paths that were used for precompiled header.
#                  - some components generate a pch in
#                    a separate step and use the pch amongst several
#                    subdirs. This env. var. lets one specify the
#                    include paths used for the pch.
#
!ifdef USE_LINT

# Convert CDEFINES which may contain /DSYMBOL1, -DSYMBOL2 to
# -dSYMBOL1 and -dSYMBOL2 which PC-Lint wants
LINT_DEFS=$(CDEFINES:-D=-d)
LINT_DEFINES=$(LINT_DEFS:/D=-d)

! ifndef LINT_PATH
LINT_PATH=$(BASEDIR)\lint
! endif

! ifndef LINT_APP
LINT_APP=$(LINT_PATH)\lint-nt
! endif

!ifndef LINT_OPTS
LINT_OPTS=+v -zero
!endif

! if "$(LINT_TYPE)" == "all"
!  ifndef LINT_ALL_CMD
LINT_ALL_CMD=$(LINT_APP) $(LINT_OPTS) $(LINT_INCLUDES) $(LINT_DEFINES) $(LINT_FORCEDINCS) -i$(LINT_PATH)\ std.lnt -os($(O)\$(LINT_OUTPUT).$(LINT_EXT))
!  endif
! else
!  if "$(LINT_TYPE)" == "lob"
!   ifndef LINT_CMD
LINT_CMD=$(LINT_APP) -u $(LINT_OPTS) $(LINT_INCLUDES) $(LINT_DEFINES) $(LINT_FORCEDINCS) -i$(LINT_PATH)\ std.lnt +os($(O)\$(LINT_OUTPUT).$(LINT_EXT)) -oo($@)
!   endif
!   ifndef LINT_CMD2
LINT_CMD2=$(LINT_APP) $(LINT_OPTS) -i$(LINT_PATH)\ std.lnt +os($(O)\$(LINT_OUTPUT).$(LINT_EXT)) $(O)\*.lob
!   endif
!  else
!   ifndef LINT_CMD
LINT_CMD=$(LINT_APP) $(LINT_OPTS) $(LINT_INCLUDES) $(LINT_DEFINES) $(LINT_FORCEDINCS) -i$(LINT_PATH)\ std.lnt +os($(O)\$(LINT_OUTPUT).$(LINT_EXT))
!   endif
!  endif
! endif
!else
LINT_CMD2=
!endif

!ifndef LINT_CMD2
LINT_CMD2=
!endif

DRIVER_ENTRY=DriverEntry
GDI_DRIVER_ENTRY=DrvEnableDriver

!if defined(USE_WDF_DYNAMIC) || defined(USE_WDF_STATIC)
BUFFER_OVERFLOW_CHECKS=1
!endif

!if "$(BUFFER_OVERFLOW_CHECKS)" == "1" || \
    ("$(BUFFER_OVERFLOW_CHECKS)" == "CHK" && !$(FREEBUILD))
! if "$(TARGETTYPE)" == "DRIVER" || \
    "$(TARGETTYPE)" == "EXPORT_DRIVER" || \
    "$(TARGETTYPE)" == "DRIVER_LIBRARY"
!  if "$(DRIVERTYPE)" == "WDM" || "$(DRIVERTYPE)" == "wdm"
BO_FLAGS=/GS
BO_LIB=$(SDK_LIB_PATH)\BufferOverflowK.lib $(DDK_LIB_PATH)\wdm.lib
DRIVER_ENTRY=GsDriverEntry
!  else
!   if "$(DRIVERTYPE)" != "VXD"
BO_FLAGS=/GS
BO_LIB=$(SDK_LIB_PATH)\BufferOverflowK.lib $(DDK_LIB_PATH)\ntoskrnl.lib
DRIVER_ENTRY=GsDriverEntry
!   endif
!  endif
! else
!  if "$(TARGETTYPE)" == "GDI_DRIVER"
BO_FLAGS=/GS
BO_LIB=$(SDK_LIB_PATH)\BufferOverflowGDI.lib
GDI_DRIVER_ENTRY=GsDrvEnableDriver
!  else
!   if  "$(TARGETTYPE)" == "MINIPORT"
BO_FLAGS=/GS
BO_LIB=$(SDK_LIB_PATH)\BufferOverflowMiniport.lib
# DRIVER_ENTRY=GsDriverEntry
!   else
!    if "$(TARGETTYPE)" == "DYNLINK"
!     if !(("$(UMTYPE)"== "nt") || ("$(UMTYPE)"=="ntss"))
BO_FLAGS=/GS
BO_LIB=$(SDK_LIB_PATH)\BufferOverflowU.lib $(SDK_LIB_PATH)\kernel32.lib
!      if !defined(RESOURCE_ONLY_DLL) && "$(DLLENTRY)" == "-noentry"
DLLENTRY=-entry:_DllMainCRTStartupForGS
!      endif
!     endif
!    else
!     if ("$(UMTYPE)"== "nt") || ("$(UMTYPE)"=="ntss")
BO_FLAGS=/GS
BO_LIB=$(SDK_LIB_PATH)\BufferOverflow.lib
!     else
BO_FLAGS=/GS
BO_LIB=$(SDK_LIB_PATH)\BufferOverflowU.lib $(SDK_LIB_PATH)\kernel32.lib
!     endif
!    endif
!   endif
!  endif
! endif
!else
!if "$(BUFFER_OVERFLOW_CHECKS)" == "NTDLL"
# Needed for EXEs that can't link to kernel32.dll (smss.exe, sprestrt.exe, etc)
BO_FLAGS=/GS
BO_LIB=$(SDK_LIB_PATH)\BufferOverflow.lib
!else
!if "$(BUFFER_OVERFLOW_CHECKS)" == "GDI"
# Needed for LIBs linked into drivers of type GDI_DRIVER
BO_FLAGS=/GS
BO_LIB=$(SDK_LIB_PATH)\BufferOverflowGDI.lib
!else
!if "$(BUFFER_OVERFLOW_CHECKS)" == "NO_NTDLL"
BO_FLAGS=/GS
BO_LIB=$(SDK_LIB_PATH)\BufferOverflowU.lib
!endif
!endif
!endif
!endif  # Overflow checks

!if defined(RUNTIME_COMPILER_CHECKS)
BO_FLAGS=$(BO_FLAGS) /RTCsu
BO_LIB=$(BO_LIB) # Insert path to RTC lib here
!endif 

#
# Standard inference rules for C files that produce object files.
#
#
# Clear the suffixes list to bypass the builtin nmake order
#
.SUFFIXES:

!ifndef PASS0ONLY
# NOTE: order IS important in the list below!
.SUFFIXES: .asm .asmx .s .c .cpp .cxx .cs .class .f .java .obj .exe .odl .p .rc .rcpp .res .resx .resz .resources .sdl .tdl .thk .txt .vb .pas .for .f90 .cbl .bas
!endif

#
# Processor specific control and options.
#

!include $(TARGET_DIRECTORY)mk.inc

!ifdef VERIFIER_DDK_EXTENSIONS
!if "$(TARGETTYPE)" == "DRIVER" && \
    "$(DRIVERTYPE)" != "wdm" && "$(DRIVERTYPE)" != "WDM" && \
    "$(DRIVERTYPE)" != "VXD"
C_DEFINES=$(C_DEFINES) -DVERIFIER_DDK_EXTENSIONS
ENTRY_SUFFIX=_DDK$(ENTRY_SUFFIX)
TARGETLIB=$(DDK_LIB_PATH)\DDK_EXT.LIB $(TARGETLIB)
!endif
!endif

!ifndef LINKER_STACKSIZE
!ifdef LINKER_STACKCOMMITSIZE
LINKER_STACKSIZE = -STACK:$(DEFAULT_STACKRESERVE),$(LINKER_STACKCOMMITSIZE)
!else
LINKER_STACKSIZE = -STACK:$(DEFAULT_STACKRESERVE),$(DEFAULT_STACKCOMMIT)
!endif
!endif

!if defined(USE_WDF_DYNAMIC) || defined(USE_WDF_STATIC)
DRIVER_ENTRY=FxDriverEntry
!endif

LINKER_STACKSIZE_DLL=-STACK:0x40000,0x1000


LIBRARY_OBJS=$(IMPLIB_OBJS) $(MFC_STATIC_LIB) $(LINKLIBS) $(OBJECTS)

!if "$(TARGETTYPE)" != "DRIVER" && \
    "$(TARGETTYPE)" != "EXPORT_DRIVER" && \
    "$(TARGETTYPE)" != "MINIPORT" && \
    "$(TARGETTYPE)" != "GDI_DRIVER"
LINKER_FLAGS = $(LINKER_FLAGS) -merge:.rdata=.text
!endif

LINKER_FLAGS=$(LINKER_FLAGS) /pdbcompress

!if $(DELAYLOAD_SUPPORTED)
! if "$(DELAYLOAD)" != ""
!  if "$(DLOAD_ERROR_HANDLER)" != ""
!   if "$(DLOAD_ERROR_HANDLER)" == "KERNEL32" || \
       "$(DLOAD_ERROR_HANDLER)" == "kernel32.dll" || \
       "$(DLOAD_ERROR_HANDLER)" == "KERNEL32.DLL" || \
       "$(DLOAD_ERROR_HANDLER)" == "Kernel32.DLL" || \
       "$(DLOAD_ERROR_HANDLER)" == "Kernel32.dll"
DLOAD_ERROR_HANDLER = kernel32
!   endif
!   if "$(DLOAD_FORCE_ERROR_CHECK)" != ""
# force delayload checking as if this module used kernel32 as its error handler
BINPLACE_FLAGS = -dl $(TARGETNAME).$(TARGETEXT),FORCE $(BINPLACE_FLAGS)
!   else
BINPLACE_FLAGS = -dl $(TARGETNAME).$(TARGETEXT),$(DLOAD_ERROR_HANDLER) $(BINPLACE_FLAGS)
!   endif
!  else
!   if "$(NOLINK)" == ""
! message BUILDMSG: Warning: DLOAD_ERROR_HANDLER not specified in $(MAKEDIR)
!   endif
!  endif
!  if "$(DLOAD_ERROR_HANDLER)" == "kernel32"
CRTLIBS=$(CRTLIBS) $(BASE_LIB_PATH)\kernel32dloadhandler.lib
TARGETLIBS = $(TARGETLIBS) $(SDK_LIB_PATH)\kernl32p.lib
!  else
CRTLIBS=$(CRTLIBS) $(CRT_LIB_PATH)\delayimp.lib
!  endif
DELAYLOAD = $(DELAYLOAD: =)
DELAYLOAD_FLAGS = /delayload:$(DELAYLOAD:;= /delayload:)
!  ifdef DELAYLOAD_UNLOAD_SUPPORT
DELAYLOAD_FLAGS = $(DELAYLOAD_FLAGS) /delay:unload
!  endif
LINKER_FLAGS = $(LINKER_FLAGS) $(DELAYLOAD_FLAGS)
C_DEFINES=$(C_DEFINES) /DDELAYLOAD_VERSION=$(DELAYLOAD_VERSION)
! endif
!endif


DRIVER_SWITCH = -driver

!if "$(DRIVERTYPE)" == "wdm" || "$(DRIVERTYPE)" == "WDM"
DRIVER_SWITCH = $(DRIVER_SWITCH) -driver:wdm
!else if "$(DRIVERTYPE)" == "VXD"
DRIVER_SWITCH = -vxd $(SDK_LIB_DEST)\i386\vxdwraps.clb
!endif

!ifdef BINARY_PUBLISH_DIR
! ifndef BINARY_PUBLISH_FILES
!  error Must define BINARY_PUBLISH_FILES if defining BINARY_PUBLISH_DIR
! endif

BINARY_PUBLISH_ROOT=$(BASEDIR)\$(_PROJECT_)\$(PROJECT_BINDROP_DIR)
BINARY_PUBLISH_ROOT=$(BINARY_PUBLISH_ROOT)\$(BINARY_PUBLISH_DIR)
BINARY_PUBLISH_ROOT=$(BINARY_PUBLISH_ROOT)\$(TARGET_DIRECTORY)\$(BUILD_TYPE)

!endif

!ifdef NO_BINPLACE

BINPLACE_CMD=echo Skip Binplace:
BINPLACE_FLAGS=

!else

!if defined(BINPLACE_ADDITIONAL_PLACEFILES)
BINPLACE_ADDITIONAL_PLACEFILES=$(BINPLACE_ADDITIONAL_PLACEFILES:"=)
!endif

!if "$(BINPLACE_ADDITIONAL_PLACEFILES)" == "1" || "$(BINPLACE_ADDITIONAL_PLACEFILES)" == "0"
!message $(BUILD_ERROR_MSG) BINPLACE_ADDITIONAL_PLACEFILES is not a boolean.
!endif

!if "$(BINPLACE_ADDITIONAL_PLACEFILES)" != ""
BINPLACE_GENERATE_PLACEFILE=1
!endif

! ifndef BINPLACE_PLACEFILE
!  if "$(BINPLACE_GENERATE_PLACEFILE)" == "1"
BINPLACE_PLACEFILE = $(O)\_placefil.txt
!  elseif "$(BUILD_PRODUCT)" == "IE"
BINPLACE_PLACEFILE = $(BINPLACE_PLACEFILE_DIR)\ieplace.txt
!  else
BINPLACE_PLACEFILE = $(BINPLACE_PLACEFILE_DIR)\placefil.txt
!  endif
! endif

! if "$(BINPLACE_GENERATE_PLACEFILE)" == "1"
MAKE_PLACEFILE_CMD=echo.

# the following case will not happen for sxs_managed assembly because SXS_ASSEMBLY_NAME will not be defined
!  if defined(SXS_LOG_PASS) && defined(SXS_ASSEMBLY_NAME) && "$(TARGETTYPE)" != "NOTARGET"
MAKE_PLACEFILE_CMD=($(MAKE_PLACEFILE_CMD) ) && ( for /f "delims=:" %i in ('echo $(BINPLACE_DESTINATIONS_NORETAIL)') do for %j in ($(TARGET))  do echo %i\%~nxj | appendtool.exe -file $(BINPLACE_LOG)\..\symbolcd_cablists_asms_$(COMPUTERNAME).lst - )
!  endif

!  if "$(BINPLACE_ADDITIONAL_PLACEFILES)" != ""
#
# BINPLACE_ADDITIONAL_PLACEFILES is a semicolon delimited list of additional placefiles.
#
MAKE_PLACEFILE_CMD=( $(MAKE_PLACEFILE_CMD) ) && ( merge_placefiles $(BINPLACE_ADDITIONAL_PLACEFILES:;= ) $(BINPLACE_PLACEFILE_DIR)\placefil.txt $(BINPLACE_PLACEFILE) )
!endif
!else
MAKE_PLACEFILE_CMD=echo.
! endif

BINPLACE_FLAGS = -P $(BINPLACE_PLACEFILE) $(BINPLACE_FLAGS) $(SXS_BINPLACE_FLAGS)

! if !defined(BUILD_NO_SYMCHK)
BINPLACE_FLAGS = -:DBG -j $(BINPLACE_FLAGS)
! endif

_NTTREE= $(_NTTREE)\$(ALT_PROJECT_TARGET)

# If NTDBGFILES is defined then use binplace to split the symbols.
# Define BINPLACE flags as needed if separate .DBG file requested.

! IFDEF NTDBGFILES
BINPLACE_DBGFLAGS_NT = -S $(_NTTREE)\Symbols
!  ifdef NTDBGFILES_PRIVATE
BINPLACE_DBGFLAGS_NT = $(BINPLACE_DBGFLAGS_NT) -n $(_NTTREE)\Symbols.pri
!  endif
! else
BINPLACE_DBGFLAGS_NT=
! ENDIF

! if "$(VERIFY_LC)" == "1"
!  ifndef LC_PATH
LC_PATH=.
!  endif
BINPLACE_LC_FLAGS = -G $(LC_PATH)\$(@F).lc
BINPLACE_LC_MISCFLAGS = -G $(LC_PATH)\$(**F).lc
! else
BINPLACE_LC_FLAGS=
BINPLACE_LC_MISCFLAGS=
! endif

!if "$(LOC_MISCFILES: =)" != ""
# one sets e.g. LOC_MISCFILES=$(MISCFILES) in the "sources"

!  if "$(LOC_ROOT: =)" == ""
# we binplace localized MISCFILES counterparts into $(_NTTREE)\$(LOC_ROOT)
LOC_ROOT=LCX\SRC
!  endif

# the -R argument overwrites
# the -O  argument unless
# -o comes after -R in binplace.exe command line
LOC_BINPLACE_FLAGS=-:TR .lcg  -o $(LOC_ROOT) -v

!endif

BINPLACE_FLAGS=-R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS)

!if  defined(DO_LANGUAGE_NEUTRAL)
BINPLACE_MISC_FLAGS =$(LANGUAGE_NEUTRAL_RESOURCE_BINPLACE) -G0 -G2 -G3 $(O)\mui -G5 $(LANGUAGE_NEUTRAL_RESDIR)
!else
BINPLACE_MISC_FLAGS =
!endif

!if defined(LANGUAGE_NEUTRAL_STS)
LANGUAGE_NEUTRAL_STATUS_CMD=\
            if not exist $@.mui ( \
                if not exist $@.mui.notloc ( \
                   echo Build_Status  LN_MUI_STS: $(LANGUAGE_NEUTRAL_STS) $(@F) \
                ) else ( \
                   del $@.mui.notloc \
                ) \
            )
!else
LANGUAGE_NEUTRAL_STATUS_CMD=
!endif

!if defined(BINPLACE_DESTINATIONS)
BINPLACE_FLAGS=-:DEST $(BINPLACE_DESTINATIONS) $(BINPLACE_FLAGS)
!endif

BINPLACE_TOOL=binplace
!if !defined(BUILD_DEBUG) && !defined(SHOW_BINPLACE)
BINPLACE_TOOL=@$(BINPLACE_TOOL)
!endif

BINPLACE_CMD=if exist $@ $(BINPLACE_TOOL) $(BINPLACE_FLAGS) $(BINPLACE_LC_FLAGS) $@

!endif

BINPLACE_CMD_NT=$(BINPLACE_CMD)

!if "$(ASSEMBLY_BINPLACE_DEST)" != "" && !defined(NO_BINPLACE)

BINPLACE_TO_COMPONENT_STORE_CMD=if exist $@ $(BINPLACE_TOOL) -:DEST $(ASSEMBLY_BINPLACE_DEST) $(BINPLACE_FLAGS) $(BINPLACE_LC_FLAGS) $@

!endif

!ifdef NTDUMPAMAP
MAPDUMP_CMD = link -dump -map $@ | sort /R /+62 > $(_NTDUMPAMAP)\$(@B).srt
!else
MAPDUMP_CMD =
!endif

#
# Define this macro so including make files can supply a yes prompt
# as appropriate.  Put the "yes." file in a visible place for OEM's
# so they can make too.
#

!IFNDEF NOPASS0

#
# Pass Zero Inference Rules: IDL files (MIDL) and MC files
#

.SUFFIXES: .h .idl .mc .odl .tdl .asn .thk .mof

! IF $(386)
PASS0_OBJECTS=$(PASS0_386_OBJECTS)
! ELSEIF $(MPPC)
PASS0_OBJECTS=$(PASS0_MPPC_OBJECTS)
! ELSEIF $(IA64)
PASS0_OBJECTS=$(PASS0_IA64_OBJECTS)
! ELSEIF $(AMD64)
PASS0_OBJECTS=$(PASS0_AMD64_OBJECTS)
! ELSEIF $(ARM)
PASS0_OBJECTS=$(PASS0_ARM_OBJECTS)
! ENDIF

!ENDIF  # IFNDEF NOPASS0

!ifndef MIDL
MIDL = midl
!endif
MKTYPLIB = mktyplib
ASN = asn1
# Disable midl timestamps wherever possible
MIDL_FLAGS=$(MIDL_FLAGS) $(MIDL_WX_SWITCH) /no_stamp

!IFDEF USE_OLE_MC
MC = mc -o
!ELSE
MC = mc

!ENDIF
MOFCOMP = mofcomp

!IF "$(IDL_TYPE)" == "ole" || "$(IDL_TYPE)" == ""
IDL_TYPE=OLE
!ELSEIF "$(IDL_TYPE)" == "rpc"
IDL_TYPE=RPC
!ENDIF

!IFNDEF PASS0_HEADERDIR
PASS0_HEADERDIR=.
!ENDIF

!IF "$(WIN32_WINNT_VERSION)" == "0x0500"
MIDL_OPTIMIZATION=$(MIDL_OPTIMIZATION_NT5)
!ELSE
! IF "$(WIN32_WINNT_VERSION)" != "$(LATEST_WIN32_WINNT_VERSION)"
MIDL_OPTIMIZATION=$(MIDL_OPTIMIZATION_NT4)
! ENDIF
!ENDIF

!IF DEFINED(MIDL_NO_ROBUST)
MIDL_OPTIMIZATION=$(MIDL_OPTIMIZATION_NO_ROBUST)
!ENDIF

# If the user specified a midl protocol, switch to it.  This assumes that it
# is defaulted in makefile.plt to "-protocol all" or ""

!ifdef MIDL_PROTOCOL
MIDL_OPTIMIZATION=$(MIDL_OPTIMIZATION:-protocol all=)
MIDL_OPTIMIZATION=$(MIDL_OPTIMIZATION) -protocol $(MIDL_PROTOCOL)
!endif

! ifdef MIDL_TLBDIR
MIDL_TLBSWITCH=/tlb $(MIDL_TLBDIR)\$(<F:.idl=.tlb)
! else
MIDL_TLBSWITCH=
! endif

!IF "$(IDL_TYPE)" == "OLE"

#! IF DEFINED(PASS0_CLIENTDIR) || DEFINED(PASS0_SERVERDIR)
#!  ERROR PASS0_CLIENTDIR and PASS0_SERVERDIR can only be used with IDL_TYPE=RPC!
#! ENDIF

! IFNDEF PASS0_SOURCEDIR
PASS0_SOURCEDIR=.
! ENDIF

! IFNDEF MIDL_UUIDDIR
MIDL_UUIDDIR=$(PASS0_SOURCEDIR)
! ENDIF

! ifndef PASS0_UUIDDIR
PASS0_UUIDDIR=$(MIDL_UUIDDIR)
! endif

!ifndef PACKING
!if $(MPPC)
PACKING= -Zp2
!else
PACKING= -Zp8
!endif
!endif

!ifdef USE_IDLBASED_DLLDATA
DLLDATA_NAME=$(<F:.idl=_dlldata.c)
!else
DLLDATA_NAME=dlldata.c
!endif

! IFNDEF NO_PASS0_RULES
.idl{$(PASS0_HEADERDIR)}.h:
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\$(<F:.idl=_p.c) \
    -dlldata $(PASS0_SOURCEDIR)\$(DLLDATA_NAME) \
    -iid $(MIDL_UUIDDIR)\$(<F:.idl=_i.c) \
    $(MIDL_TLBSWITCH) \
    -header $@ \
    -cpp_cmd $(MIDL_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $<

{..\}.idl{$(PASS0_HEADERDIR)}.h:
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\$(<F:.idl=_p.c) \
    -dlldata $(PASS0_SOURCEDIR)\$(DLLDATA_NAME) \
    -iid $(MIDL_UUIDDIR)\$(<F:.idl=_i.c) \
    $(MIDL_TLBSWITCH) \
    -header $@ \
    -cpp_cmd $(MIDL_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $<

{$(O)}.idl{$(PASS0_HEADERDIR)}.h:
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\$(<F:.idl=_p.c) \
    -dlldata $(PASS0_SOURCEDIR)\$(DLLDATA_NAME) \
    -iid $(MIDL_UUIDDIR)\$(<F:.idl=_i.c) \
    $(MIDL_TLBSWITCH) \
    -header $@ \
    -cpp_cmd $(MIDL_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $<
! ENDIF

!ELSEIF "$(IDL_TYPE)" == "RPC"

#! IF DEFINED(PASS0_SOURCEDIR) || DEFINED(MIDL_UUIDDR)
#!  ERROR PASS0_SOURCEDIR and MIDL_UUIDDIR can only be used with IDL_TYPE=OLE!
#! ENDIF

! IFNDEF PASS0_CLIENTDIR
PASS0_CLIENTDIR=$(TARGETPATH)
! ENDIF

! IFNDEF PASS0_SERVERDIR
PASS0_SERVERDIR=$(PASS0_CLIENTDIR)
! ENDIF

! IFNDEF NO_PASS0_RULES
.idl{$(PASS0_HEADERDIR)}.h:
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -cstub $(PASS0_CLIENTDIR)\$(<F:.idl=_c.c) \
    -sstub $(PASS0_SERVERDIR)\$(<F:.idl=_s.c) \
    $(MIDL_TLBSWITCH) \
    -header $@ \
    -cpp_cmd $(MIDL_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $<

{..\}.idl{$(PASS0_HEADERDIR)}.h:
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -cstub $(PASS0_CLIENTDIR)\$(<F:.idl=_c.c) \
    -sstub $(PASS0_SERVERDIR)\$(<F:.idl=_s.c) \
    $(MIDL_TLBSWITCH) \
    -header $@ \
    -cpp_cmd $(MIDL_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $<

{$(O)}.idl{$(PASS0_HEADERDIR)}.h:
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -cstub $(PASS0_CLIENTDIR)\$(<F:.idl=_c.c) \
    -sstub $(PASS0_SERVERDIR)\$(<F:.idl=_s.c) \
    $(MIDL_TLBSWITCH) \
    -header $@ \
    -cpp_cmd $(MIDL_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $<

! ENDIF

!ELSE

! ERROR Invalid IDL_TYPE value. Supported values: OLE and RPC.

!ENDIF  # IDL_TYPE

CPPXX = $(C_PREPROCESSOR_FLAGS:/Tc=)
CPPXX = $(CPPXX:-Tc=)

!IFNDEF NO_PASS0_RULES

! IFNDEF MC_SOURCEDIR
! IFDEF PASS0_SOURCEDIR
MC_SOURCEDIR=$(PASS0_SOURCEDIR)
! ELSE
MC_SOURCEDIR=$(PASS0_CLIENTDIR)
! ENDIF
! ENDIF

.mc{$(PASS0_HEADERDIR)}.h:
    $(MC) -h $(PASS0_HEADERDIR) -r $(MC_SOURCEDIR) $(MC_FLAGS) $<
.mc{$(MC_SOURCEDIR)}.rc:
    $(MC) -h $(PASS0_HEADERDIR) -r $(MC_SOURCEDIR) $(MC_FLAGS) $<

{..\}.mc{$(PASS0_HEADERDIR)}.h:
    $(MC) -h $(PASS0_HEADERDIR) -r $(MC_SOURCEDIR) $(MC_FLAGS) $<
{..\}.mc{$(MC_SOURCEDIR)}.rc:
    $(MC) -h $(PASS0_HEADERDIR) -r $(MC_SOURCEDIR) $(MC_FLAGS) $<

{$(O)}.mc{$(PASS0_HEADERDIR)}.h:
    $(MC) -h $(PASS0_HEADERDIR) -r $(MC_SOURCEDIR) $(MC_FLAGS) $<
{$(O)}.mc{$(MC_SOURCEDIR)}.rc:
    $(MC) -h $(PASS0_HEADERDIR) -r $(MC_SOURCEDIR) $(MC_FLAGS) $<

# ManagedObjectFormat files
#   First preprocess MOF via the C pre processor
#   Next separate MOF into MOF and MFL, then concatenate them and
#   finally compile into binary form
{..\}.mof{$(O)}.mof:
    @type <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<$(BUILD_NOKEEP)
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $@
$(CPPXX: =
)
<<$(BUILD_NOKEEP)

{}.mof{$(O)}.mof:
    @type <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<$(BUILD_NOKEEP)
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $@
$(CPPXX: =
)
<<$(BUILD_NOKEEP)
{$(O)}.mof{$(O)}.bmf:
!ifdef MOFCOMP_NO_DEFAULT_NAMESPACE
    $(MOFCOMP) -Amendment:ms_409 -MFL:$(O)\MFL.MFL -MOF:$(O)\MOF.MOF $<
!else
    $(MOFCOMP) -N:root\wmi -Amendment:ms_409 -MFL:$(O)\MFL.MFL -MOF:$(O)\MOF.MOF $<
!endif
    wmimofck -y$(O)\MOF.MOF -z$(O)\MFL.MFL $(O)\MOFMFL.MOF
    $(MOFCOMP) -WMI -B:$@ $(O)\MOFMFL.MOF

!ifdef USE_MIDL_FOR_MKTYPLIB

MIDL_MKTYPLIB_FLAGS = \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext \
    -c_ext \
    $(C_DEFINES) -D__MKTYPLIB__ \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $(MKTYPLIB_FLAGS:-h =-header ) \
    -tlb $@ \
    -cpp_cmd $(MIDL_CPP) \
    -mktyplib203

.odl{$(O)\}.tlb:
    $(MIDL) $(MIDL_MKTYPLIB_FLAGS) $<

{..\}.odl{$(O)\}.tlb:
    $(MIDL) $(MIDL_MKTYPLIB_FLAGS) $<

.tdl{$(O)\}.tlb:
    $(MIDL) $(MIDL_MKTYPLIB_FLAGS) $<

{..\}.tdl{$(O)\}.tlb:
    $(MIDL) $(MIDL_MKTYPLIB_FLAGS) $<

!else

.odl{$(O)\}.tlb:
    @echo $(MKTYPLIB) /tlb $@ -nocpp $(MKTYPLIB_FLAGS) $<
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $(O)\MyTypLib.TMP
$(CPPXX: =
)
-D__MKTYPLIB__
<<$(BUILD_NOKEEP)
    @$(MKTYPLIB) /tlb $@ -nocpp $(MKTYPLIB_FLAGS) $(O)\MyTypLib.TMP

{..\}.odl{$(O)\}.tlb:
    @echo $(MKTYPLIB) /tlb $@ -nocpp $(MKTYPLIB_FLAGS) $<
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $(O)\MyTypLib.TMP
$(CPPXX: =
)
-D__MKTYPLIB__
<<$(BUILD_NOKEEP)
    @$(MKTYPLIB) /tlb $@ -nocpp $(MKTYPLIB_FLAGS) $(O)\MyTypLib.TMP

.tdl{$(O)\}.tlb:
    @echo $(MKTYPLIB) /tlb $@ -nocpp $(MKTYPLIB_FLAGS) $<
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $(O)\MyTypLib.TMP
$(CPPXX: =
)
-D__MKTYPLIB__
<<$(BUILD_NOKEEP)
    @$(MKTYPLIB) /tlb $@ -nocpp $(MKTYPLIB_FLAGS) $(O)\MyTypLib.TMP

{..\}.tdl{$(O)\}.tlb:
    @echo $(MKTYPLIB) /tlb $@ -nocpp $(MKTYPLIB_FLAGS) $<
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $(O)\MyTypLib.TMP
$(CPPXX: =
)
-D__MKTYPLIB__
<<$(BUILD_NOKEEP)
    @$(MKTYPLIB) /tlb $@ -nocpp $(MKTYPLIB_FLAGS) $(O)\MyTypLib.TMP

!endif


# OSSINFO must be set in the *environment* for the ASN compiler to find its
# configuration file, $(OSSINFO)\ossinfo.

! ifndef OSSINFO
OSSINFO=$(SDK_LIB_DEST)
! endif

! ifndef ASNDEFAULTFILE
ASNDEFAULTFILE=$(OSSINFO)\asn1dflt.z4
! endif

! ifndef ASNSYNTAX
ASNSYNTAX=-1990
! endif

ASNFLAGS=$(ASNDEFAULTFILE) $(ASNSYNTAX) $(ASNFLAGS)

# if ASNDBG is explicitly set, let that control whether the voluminous ASN
# symbols are supressed.  Otherwise, suppress the symbols for free builds.

! ifdef ASNDBG
!  if $(ASNDBG) == 0
ASNFLAGS=-minimize $(ASNFLAGS)
!  endif
! elseif $(FREEBUILD)
ASNFLAGS=-minimize $(ASNFLAGS)
! endif

{}.asn{$(PASS0_HEADERDIR)}.h:
    $(ASN) $(ASNFLAGS) -out $(PASS0_HEADERDIR)\$(@B) $<

!ENDIF

#
# Default language ID to US English (0x0409)
#

!IFDEF RCCODEPAGE
RCOPTIONS=$(RCOPTIONS) -c $(RCCODEPAGE)
!ENDIF

!IFNDEF RCNOFONTMAP
RCOPTIONS=-z "MS Sans Serif,Helv/MS Shell Dlg" $(RCOPTIONS)
!ENDIF

SXS_RC_MANIFEST_DEFINES=$(SXS_MANIFEST_DEFINES)
SXS_RC_MANIFEST_DEFINES=$(SXS_RC_MANIFEST_DEFINES:"\"=""")
SXS_RC_MANIFEST_DEFINES=$(SXS_RC_MANIFEST_DEFINES:\""=""")
RCOPTIONS=$(SXS_RC_MANIFEST_DEFINES) $(RCOPTIONS)
!ifdef RCLANGUAGE
RCOPTIONS=-l $(RCLANGUAGE) $(RCOPTIONS)
!else
RCOPTIONS=-l 409 $(RCOPTIONS)
!endif

!if defined(DO_LANGUAGE_NEUTRAL)
RCOPTIONS=$(RCOPTIONS) $(LANGUAGE_NEUTRAL_RESOURCE) -fm $*.muires
!ENDIF

RC_COMPILER=rc $(RCOPTIONS)

INCPATHRC = $(INCPATH0: =)
INCPATHRC = $(INCPATHRC:-I=;)
INCPATHRC = $(INCPATHRC:/I=;)

CDEFINERC = $(CDEFINES:  = )
CDEFINERC = $(CDEFINERC:  = )

!if defined(RC_FORCE_INCLUDE_FILES)
# Concatenate the FORCE_INCLUDES files in front of the .rc file.
# We put nul in front because there is an extra leading semicolon which produces
# an extra leading plus sign.
RC_TEMP1=$(@R).rc_temp1
RC_FORCE_INCLUDE_FILES_CMD=copy nul$(RC_FORCE_INCLUDE_FILES:;=+)+$< $(RC_TEMP1)
INCPATHRC=$(INCPATHRC);..
!else
RC_TEMP1=$<
RC_FORCE_INCLUDE_FILES_CMD=
!endif

!if defined(RC_FORCE_INCLUDE_STRING)
RC_TEMP2=$(@R).rc_temp2
INCPATHRC=$(INCPATHRC);..
!else
RC_TEMP2=$(RC_TEMP1)
!endif

RC_TEMP=$(RC_TEMP2)

!if defined(SXS_MANIFEST_IN_RESOURCES)
MAKE_MANIFEST_CMD=nmake -nologo $(SXS_MANIFEST_OBJ1)
!else
MAKE_MANIFEST_CMD=
!endif

!IF $(MPPC)
{$(O)\}.rc{$(O)\}.res:
     $(RC_COMPILER) -r -m -fo $@ $(RC_DEFINES) $(RCXBANG) $(INCPATH0) $<
!ELSE
{$(O)\}.rc{$(O)\}.res:
    $(NOECHO)$(MAKE_MUI_MANIFEST_CMD)
    $(TYPE) <<$(ECHO_RSP)
    $(RC_COMPILER) -r -fo $@ $(CDEFINES) $(INCPATH0) $<
<<$(BUILD_NOKEEP)
    $(NOECHO)$(MAKE_MANIFEST_CMD)
    $(NOECHO)$(RC_FORCE_INCLUDE_FILES_CMD)
! IF defined(RC_FORCE_INCLUDE_STRING)
    $(NOECHO)copy << + $(RC_TEMP1) $(RC_TEMP2)
$(RC_FORCE_INCLUDE_STRING)
<<$(BUILD_NOKEEP)
! endif
    $(NOECHO)set include=$(INCPATHRC);$(INCLUDE)
    $(NOECHO)$(RC_COMPILER) -r -fo $@ $(CDEFINERC) $(RC_TEMP)
    $(NOECHO)set include=$(INCLUDE)
!ENDIF

!IF $(MPPC)
{..\}.rc{$(O)\}.res:
     $(RC_COMPILER) -r -m -fo $@ $(RC_DEFINES) $(RCXBANG) $(INCPATH0) $<
!ELSE
{..\}.rc{$(O)\}.res:
    $(NOECHO)$(MAKE_MUI_MANIFEST_CMD)
    $(TYPE) <<$(ECHO_RSP)
    $(RC_COMPILER) -r -fo $@ $(CDEFINES) $(INCPATH0) $<
<<$(BUILD_NOKEEP)
    $(NOECHO)$(MAKE_MANIFEST_CMD)
    $(NOECHO)$(RC_FORCE_INCLUDE_FILES_CMD)
! if defined(RC_FORCE_INCLUDE_STRING)
    $(NOECHO)copy << + $(RC_TEMP1) $(RC_TEMP2)
$(RC_FORCE_INCLUDE_STRING)
<<$(BUILD_NOKEEP)
! endif
    $(NOECHO)set include=$(INCPATHRC);$(INCLUDE)
    $(NOECHO)$(RC_COMPILER) -r -fo $@ $(CDEFINERC) $(RC_TEMP)
    $(NOECHO)set include=$(INCLUDE)
!ENDIF

!IF $(MPPC)
{}.rc{$(O)\}.res:
    $(RC_COMPILER) -r -m -fo $@ $(RC_DEFINES) $(RCXBANG) $(INCPATH0) $<
!ELSE
{}.rc{$(O)\}.res:
    $(NOECHO)$(MAKE_MUI_MANIFEST_CMD)
    $(TYPE) <<$(ECHO_RSP)
    $(RC_COMPILER) -r -fo $@ $(CDEFINES) $(INCPATH0) $<
<<$(BUILD_NOKEEP)
    $(NOECHO)$(MAKE_MANIFEST_CMD)
    $(NOECHO)$(RC_FORCE_INCLUDE_FILES_CMD)
! if defined(RC_FORCE_INCLUDE_STRING)
    $(NOECHO)copy << + $(RC_TEMP1) $(RC_TEMP2)
$(RC_FORCE_INCLUDE_STRING)
<<$(BUILD_NOKEEP)
! endif
    $(NOECHO)set include=$(INCPATHRC);$(INCLUDE)
    $(NOECHO)$(RC_COMPILER) -r -fo $@ $(CDEFINERC) $(RC_TEMP)
    $(NOECHO)set include=$(INCLUDE)
!ENDIF

!IF $(MPPC)

#
# The definitions for the resource compiler are the same as the definitions
# for the C compiler except we need to remove INC_OLE2 because the resource
# compiler doesn't understand the pragma's that the VC guys used to rename
# the macos include files.  Thus, the resource compiler can't parse the ole
# headers
#

RC_DEFINES=$(C_DEFINES:INC_OLE2=NO_OLE)

#
# Setup for the mac resource compiler
#

# Macintosh-specific resourse (.r) to .rsc rule
MRC_COMPILER=mrc -l 0x409

.SUFFIXES: .r

{..\}.r{$(_OBJ_DIR)\$(TARGET_DIRECTORY)\}.rsc:
    $(MRC_COMPILER) -o $(@R).rsc $(RC_DEFINES) $(INCPATH0) $<

.r{$(_OBJ_DIR)\$(TARGET_DIRECTORY)\}.rsc:
    $(MRC_COMPILER) -o $(@R).rsc $(RC_DEFINES) $(INCPATH0) $<
!ENDIF


{..\}.rc.rcpp:
    set include=$(INCPATHRC);$(INCLUDE)
    $(RC_COMPILER) -r -p -fo $(@R).tmp $(CDEFINERC) $<
    @set include=$(INCLUDE)

{}.rc.rcpp:
    set include=$(INCPATHRC);$(INCLUDE)
    $(RC_COMPILER) -r -p -fo $(@R).tmp $(CDEFINERC) $<
    @set include=$(INCLUDE)

.thk{$(O)\}.asm:
    thunk -o $@ $<

JVC = jvc /nologo

!ifndef JAVA_DEBUG_FLAGS
!if $(FREEBUILD)
JAVA_DEBUG_FLAGS = /O
!else
JAVA_DEBUG_FLAGS = /g
!endif
!endif

!ifndef JAVA_WARNING_FLAGS
JAVA_WARNING_FLAGS = /w4
!endif

JAVA_BASE_CLASS = \
    $(SDK_PATH)\classes\afc.zip; \
    $(SDK_PATH)\classes\classes.zip

JAVA_CLASS_PATH = $(JAVA_BASE_CLASS); $(MAKEDIR); $(USER_CLASS_PATH)
JAVA_CLASS_PATH = $(JAVA_CLASS_PATH: =)

JVC_FLAGS = /cp $(JAVA_CLASS_PATH) $(JAVA_DEBUG_FLAGS) $(JAVA_WARNING_FLAGS) /d $(O)

{$(MAKEDIR)}.java{$(O)\}.class:
    $(JVC) $(JVC_FLAGS) $<

ECHO_RSP = $(O)\echo.msg
CL_RSP   = $(O)\cl.rsp
CLCOD_RSP = $(O)\clcod.rsp
LINK_RSP = $(O)\lnk.rsp

{$(O)\}.cxx{$(O)\}.obj:
    @type <<$(ECHO_RSP)
$(ECHO_CXX_MSG)
<<$(BUILD_NOKEEP)
    @$(CXX_COMPILER_NAME) @<<$(CL_RSP) -Fo"$(MAKEDIR)\$(O)/" /FC
$(CXX_COMPILER_FLAGS: =
)
$<
<<$(BUILD_NOKEEP)

{..\}.cxx{$(O)\}.obj::
    @type <<$(ECHO_RSP)
$(ECHO_CXX_MSG)
<<$(BUILD_NOKEEP)
    @$(CXX_COMPILER_NAME) @<<$(CL_RSP) -Fo"$(MAKEDIR)\$(O)/" /FC
$(CXX_COMPILER_FLAGS: =
)
$<
<<$(BUILD_NOKEEP)

{..\$(TARGET_DIRECTORY)\}.cxx{$(O)\}.obj::
    @type <<$(ECHO_RSP)
$(ECHO_CXX_MSG)
<<$(BUILD_NOKEEP)
    @$(CXX_COMPILER_NAME) @<<$(CL_RSP) -Fo"$(MAKEDIR)\$(O)/" /FC
$(CXX_COMPILER_FLAGS: =
)
$<
<<$(BUILD_NOKEEP)

{$(O)\}.cpp{$(O)\}.obj::
    @type <<$(ECHO_RSP)
$(ECHO_CXX_MSG)
<<$(BUILD_NOKEEP)
    @$(CXX_COMPILER_NAME) @<<$(CL_RSP) -Fo"$(MAKEDIR)\$(O)/" /FC
$(CXX_COMPILER_FLAGS: =
)
$<
<<$(BUILD_NOKEEP)

{..\}.cpp{$(O)\}.obj::
    @type <<$(ECHO_RSP)
$(ECHO_CXX_MSG)
<<$(BUILD_NOKEEP)
    @$(CXX_COMPILER_NAME) @<<$(CL_RSP) -Fo"$(MAKEDIR)\$(O)/" /FC
$(CXX_COMPILER_FLAGS: =
)
$<
<<$(BUILD_NOKEEP)

{..\$(TARGET_DIRECTORY)\}.cpp{$(O)\}.obj::
    @type <<$(ECHO_RSP)
$(ECHO_CXX_MSG)
<<$(BUILD_NOKEEP)
    @$(CXX_COMPILER_NAME) @<<$(CL_RSP) -Fo"$(MAKEDIR)\$(O)/" /FC
$(CXX_COMPILER_FLAGS: =
)
$<
<<$(BUILD_NOKEEP)

{}.cxx{$(O)\}.obj::
    @type <<$(ECHO_RSP)
$(ECHO_CXX_MSG)
<<$(BUILD_NOKEEP)
    @$(CXX_COMPILER_NAME) @<<$(CL_RSP) -Fo"$(MAKEDIR)\$(O)/" /FC
$(CXX_COMPILER_FLAGS: =
)
$<
<<$(BUILD_NOKEEP)

{$(TARGET_DIRECTORY)\}.cxx{$(O)\}.obj::
    @type <<$(ECHO_RSP)
$(ECHO_CXX_MSG)
<<$(BUILD_NOKEEP)
    @$(CXX_COMPILER_NAME) @<<$(CL_RSP) -Fo"$(MAKEDIR)\$(O)/" /FC
$(CXX_COMPILER_FLAGS: =
)
$<
<<$(BUILD_NOKEEP)

{}.cpp{$(O)\}.obj::
    @type <<$(ECHO_RSP)
$(ECHO_CXX_MSG)
<<$(BUILD_NOKEEP)
    @$(CXX_COMPILER_NAME) @<<$(CL_RSP) -Fo"$(MAKEDIR)\$(O)/" /FC
$(CXX_COMPILER_FLAGS: =
)
$<
<<$(BUILD_NOKEEP)

{$(TARGET_DIRECTORY)\}.cpp{$(O)\}.obj::
    @type <<$(ECHO_RSP)
$(ECHO_CXX_MSG)
<<$(BUILD_NOKEEP)
    @$(CXX_COMPILER_NAME) @<<$(CL_RSP) -Fo"$(MAKEDIR)\$(O)/" /FC
$(CXX_COMPILER_FLAGS: =
)
$<
<<$(BUILD_NOKEEP)

# Make sure LTCG is off
CXX_COD_COMPILER_FLAGS=$(CXX_COMPILER_FLAGS:/GL=/wd4652)
# Replace spaces with new lines
CXX_COD_COMPILER_FLAGS=$(CXX_COD_COMPILER_FLAGS: =^
)

# C++ COD file rules
{}.cxx{}.cod:
    $(CXX_COMPILER_NAME) @<<$(CLCOD_RSP) /FAsc /FC $<
$(CXX_COD_COMPILER_FLAGS)
<<$(BUILD_NOKEEP)

{}.cpp{}.cod:
    $(CXX_COMPILER_NAME) @<<$(CLCOD_RSP) /FAsc /FC $<
$(CXX_COD_COMPILER_FLAGS)
<<$(BUILD_NOKEEP)

{$(TARGET_DIRECTORY)\}.cxx{}.cod:
    $(CXX_COMPILER_NAME) @<<$(CLCOD_RSP) /FAsc /FC $<
$(CXX_COD_COMPILER_FLAGS)
<<$(BUILD_NOKEEP)

{$(TARGET_DIRECTORY)\}.cpp{}.cod:
    $(CXX_COMPILER_NAME) @<<$(CLCOD_RSP) /FAsc /FC $<
$(CXX_COD_COMPILER_FLAGS)
<<$(BUILD_NOKEEP)

{..\}.cxx{}.cod:
    $(CXX_COMPILER_NAME) @<<$(CLCOD_RSP) /FAsc /FC $<
$(CXX_COD_COMPILER_FLAGS)
<<$(BUILD_NOKEEP)

{..\}.cpp{}.cod:
    $(CXX_COMPILER_NAME) @<<$(CLCOD_RSP) /FAsc /FC $<
$(CXX_COD_COMPILER_FLAGS)
<<$(BUILD_NOKEEP)

{..\$(TARGET_DIRECTORY)\}.cxx{}.cod:
    $(CXX_COMPILER_NAME) @<<$(CLCOD_RSP) /FAsc /FC $<
$(CXX_COD_COMPILER_FLAGS)
<<$(BUILD_NOKEEP)

{..\$(TARGET_DIRECTORY)\}.cpp{}.cod:
    $(CXX_COMPILER_NAME) @<<$(CLCOD_RSP) /FAsc /FC $<
$(CXX_COD_COMPILER_FLAGS)
<<$(BUILD_NOKEEP)

# C++ .pp rule

{}.cxx{}.pp:
    $(CXX_COMPILER_NAME) @<<$(CL_RSP) /E /FC $< > $@
$(CXX_COMPILER_FLAGS: =
)
<<$(BUILD_NOKEEP)

{}.cpp{}.pp:
    $(CXX_COMPILER_NAME) @<<$(CL_RSP) /E /FC $< > $@
$(CXX_COMPILER_FLAGS: =
)
<<$(BUILD_NOKEEP)

{$(TARGET_DIRECTORY)\}.cxx{}.pp:
    $(CXX_COMPILER_NAME) @<<$(CL_RSP) /E /FC $< > $@
$(CXX_COMPILER_FLAGS: =
)
<<$(BUILD_NOKEEP)

{$(TARGET_DIRECTORY)\}.cpp{}.pp:
    $(CXX_COMPILER_NAME) @<<$(CL_RSP) /E /FC $< > $@
$(CXX_COMPILER_FLAGS: =
)
<<$(BUILD_NOKEEP)

{..\}.cxx{}.pp:
    $(CXX_COMPILER_NAME) @<<$(CL_RSP) /E /FC $< > $@
$(CXX_COMPILER_FLAGS: =
)
<<$(BUILD_NOKEEP)

{..\}.cpp{}.pp:
    $(CXX_COMPILER_NAME) @<<$(CL_RSP) /E /FC $< > $@
$(CXX_COMPILER_FLAGS: =
)
<<$(BUILD_NOKEEP)

{..\$(TARGET_DIRECTORY)\}.cxx{}.pp:
    $(CXX_COMPILER_NAME) @<<$(CL_RSP) /E /FC $< > $@
$(CXX_COMPILER_FLAGS: =
)
<<$(BUILD_NOKEEP)

{..\$(TARGET_DIRECTORY)\}.cpp{}.pp:
    $(CXX_COMPILER_NAME) @<<$(CL_RSP) /E /FC $< > $@
$(CXX_COMPILER_FLAGS: =
)
<<$(BUILD_NOKEEP)

{$(O)\}.cxx{}.pp:
    $(CXX_COMPILER_NAME) @<<$(CL_RSP) /E /FC $< > $@
$(CXX_COMPILER_FLAGS: =
)
<<$(BUILD_NOKEEP)

{$(O)\}.cpp{}.pp:
    $(CXX_COMPILER_NAME) @<<$(CL_RSP) /E /FC $< > $@
$(CXX_COMPILER_FLAGS: =
)
<<$(BUILD_NOKEEP)

# Expand spaces to newlines, replace double # signs with spaces.
EX_C_COMPILER_FLAGS=$(C_COMPILER_FLAGS: =^
)
EX_C_COMPILER_FLAGS=$(EX_C_COMPILER_FLAGS:^#^#= )

{..\}.c{$(O)\}.obj::
    @type <<$(ECHO_RSP)
$(ECHO_MSG)
<<$(BUILD_NOKEEP)
    @$(C_COMPILER_NAME) @<<$(CL_RSP) -Fo"$(MAKEDIR)\$(O)/" /FC $(USECXX_FLAG)
$(EX_C_COMPILER_FLAGS)
$<
<<$(BUILD_NOKEEP)

{..\$(TARGET_DIRECTORY)\}.c{$(O)\}.obj::
    @type <<$(ECHO_RSP)
$(ECHO_MSG)
<<$(BUILD_NOKEEP)
    @$(C_COMPILER_NAME) @<<$(CL_RSP) -Fo"$(MAKEDIR)\$(O)/" /FC $(USECXX_FLAG)
$(EX_C_COMPILER_FLAGS)
$<
<<$(BUILD_NOKEEP)

{$(O)\}.c{$(O)\}.obj::
    @type <<$(ECHO_RSP)
$(ECHO_MSG)
<<$(BUILD_NOKEEP)
    @$(C_COMPILER_NAME) @<<$(CL_RSP) -Fo"$(MAKEDIR)\$(O)/" /FC $(USECXX_FLAG)
$(EX_C_COMPILER_FLAGS)
$<
<<$(BUILD_NOKEEP)

{}.c{$(O)\}.obj::
    @type <<$(ECHO_RSP)
$(ECHO_MSG)
<<$(BUILD_NOKEEP)
    @$(C_COMPILER_NAME) @<<$(CL_RSP) -Fo"$(MAKEDIR)\$(O)/" /FC $(USECXX_FLAG)
$(EX_C_COMPILER_FLAGS)
$<
<<$(BUILD_NOKEEP)

{$(TARGET_DIRECTORY)\}.c{$(O)\}.obj::
    @type <<$(ECHO_RSP)
$(ECHO_MSG)
<<$(BUILD_NOKEEP)
    @$(C_COMPILER_NAME) @<<$(CL_RSP) -Fo"$(MAKEDIR)\$(O)/" /FC $(USECXX_FLAG)
$(EX_C_COMPILER_FLAGS)
$<
<<$(BUILD_NOKEEP)

# C .COD rules

{}.c{}.cod:
    $(C_COMPILER_NAME) @<<$(CLCOD_RSP) /FAsc /FC $(USECXX_FLAG) $<
$(EX_C_COMPILER_FLAGS:/GL=/wd4652)
<<$(BUILD_NOKEEP)

{$(TARGET_DIRECTORY)\}.c{}.cod:
    $(C_COMPILER_NAME) @<<$(CLCOD_RSP) /FAsc /FC $(USECXX_FLAG) $<
$(EX_C_COMPILER_FLAGS:/GL=/wd4652)
<<$(BUILD_NOKEEP)

{..\}.c{}.cod:
    $(C_COMPILER_NAME) @<<$(CLCOD_RSP) /FAsc /FC $(USECXX_FLAG) $<
$(EX_C_COMPILER_FLAGS:/GL=/wd4652)
<<$(BUILD_NOKEEP)

{..\$(TARGET_DIRECTORY)\}.c{}.cod:
    $(C_COMPILER_NAME) @<<$(CLCOD_RSP) /FAsc /FC $(USECXX_FLAG) $<
$(EX_C_COMPILER_FLAGS:/GL=/wd4652)
<<$(BUILD_NOKEEP)

{$(O)\}.c{}.cod:
    $(C_COMPILER_NAME) @<<$(CLCOD_RSP) /FAsc /FC $(USECXX_FLAG) $<
$(EX_C_COMPILER_FLAGS:/GL=/wd4652)
<<$(BUILD_NOKEEP)

# C .PP rules
{}.c{}.pp:
    $(C_COMPILER_NAME) @<<$(CL_RSP) /E /FC $(USECXX_FLAG) $< > $@
$(EX_C_COMPILER_FLAGS)
<<$(BUILD_NOKEEP)

{$(TARGET_DIRECTORY)\}.c{}.pp:
    $(C_COMPILER_NAME) @<<$(CL_RSP) /E /FC $(USECXX_FLAG) $< > $@
$(EX_C_COMPILER_FLAGS)
<<$(BUILD_NOKEEP)

{..\}.c{}.pp:
    $(C_COMPILER_NAME) @<<$(CL_RSP) /E /FC $(USECXX_FLAG) $< > $@
$(EX_C_COMPILER_FLAGS)
<<$(BUILD_NOKEEP)

{..\$(TARGET_DIRECTORY)\}.c{}.pp:
    $(C_COMPILER_NAME) @<<$(CL_RSP) /E /FC $(USECXX_FLAG) $< > $@
$(EX_C_COMPILER_FLAGS)
<<$(BUILD_NOKEEP)

{$(O)\}.c{}.pp:
    $(C_COMPILER_NAME) @<<$(CL_RSP) /E /FC $(USECXX_FLAG) $< > $@
$(EX_C_COMPILER_FLAGS)
<<$(BUILD_NOKEEP)

#
# C# compiler rules
#

EX_MANAGED_COMPILER_FLAGS=$(MANAGED_STD_FLAGS)
{..\}.cs{$O\}.dll::
    @type <<$(ECHO_RSP)
$(ECHO_MSG)

    @$(CS_COMPILER_NAME) @<<$(CS_RSP)
$(EX_MANAGED_COMPILER_FLAGS)
$<
<<$(BUILD_NOKEEP)

{..\}.vb{$O\}.dll::
    @type <<$(ECHO_RSP)
$(ECHO_MSG)
<<$(BUILD_NOKEEP)
    @$(VB_NET_COMPILER_NAME) @<<$(VB_RSP)
$(EX_MANAGED_COMPILER_FLAGS)
$<
<<$(BUILD_NOKEEP)

#
# resgen rules
#

DESCRIPTION=resxgen

{}.resz{$(O)}.resources:
    echo cl /EP _$(DESCRIPTION)_$(?)
    resxgen.exe $< $*.resx
    resgen.exe $*.resx $@

{}.resx{$(O)}.resources:
    echo cl /EP _$(DESCRIPTION)_$(?)
    resgen.exe $< $@

{}.txt{$(O)}.resources:
    echo cl /EP _$(DESCRIPTION)_$(?)
    resgen.exe $< $@

#
# SDL proxy generation rules
#
.sdl.cs::
    webserviceutil /c:proxy /path:$<


!if "$(NTNOFUZZYLOOKUP)"=="1"
LIBRARY_OBJS=
!else
LIBRARY_OBJS = $(LIBRARY_OBJS) $(HEADEROBJNAME)
!endif

!ifdef USE_INCREMENTAL_LINKING
IMPLIB_DEPEND =
!else
IMPLIB_DEPEND = $(LIBRARY_OBJS)
!endif

#
# inference rules for preprocessing manifests
# It would be nice to go from .manifest to .manifest.obj, but nmake doesn't work that way.
# There is some precedent for going from .src to .manifest, but I'd rather generated files
# end in obj. But we can't go from .manifest to .manifestobj either, because of the case
# of manifests not in resources.
#
# .manifest-src is needed only for the unusual case of multiple manifests resources,
# when you write the .rc file lines by hand instead of us doing it for you, and
# then the .rc is not pushed into the objdir and it picks up the unpreprocessed one.
# For example: \nt\base\win32\fusion\tests\sxstest\testdata\Hello\ExeMultiRes.
#
# .man is for fitting in 8.3
#
.SUFFIXES: .manifest-src .manifest .man .o_manifest

# This string is needed in at least four places in the tree, so factor it to here.
SYSTEM_COMPATIBLE_ASSEMBLY_NAME=Microsoft.Windows.SystemCompatible
DEFINE_SYSTEM_COMPATIBLE_ASSEMBLY_NAME=\
    -DSYSTEM_COMPATIBLE_ASSEMBLY_NAME="\"$(SYSTEM_COMPATIBLE_ASSEMBLY_NAME)\"" \
    -DLSYSTEM_COMPATIBLE_ASSEMBLY_NAME=L"\"$(SYSTEM_COMPATIBLE_ASSEMBLY_NAME)\""

SYSTEM_COMPATIBLE_ASSEMBLY_VERSION=5.2
SYSTEM_COMPATIBLE_ASSEMBLY_VERSION_PART_3=0
SYSTEM_COMPATIBLE_ASSEMBLY_VERSION_PART_4=0

!if "$(SXS_ASSEMBLY_NAME)" != ""
SXS_MANIFEST_DEFINES=-DSXS_ASSEMBLY_NAME="\"$(SXS_ASSEMBLY_NAME)\"" $(SXS_MANIFEST_DEFINES)
!endif
!if "$(SXS_ASSEMBLY_VERSION)" != ""
SXS_MANIFEST_DEFINES=-DSXS_ASSEMBLY_VERSION="\"$(SXS_ASSEMBLY_VERSION)\"" $(SXS_MANIFEST_DEFINES)
!endif
!if "$(SXS_ASSEMBLY_LANGUAGE)" != ""
SXS_MANIFEST_DEFINES=-DSXS_ASSEMBLY_LANGUAGE="\"$(SXS_ASSEMBLY_LANGUAGE)\"" $(SXS_MANIFEST_DEFINES)
!endif

SXS_MANIFEST_DEFINES= \
 -DSXS_PROCESSOR_ARCHITECTURE="\"$(SXS_PROCESSOR_ARCHITECTURE)\"" \
 -DSXS_TARGET="\"$(TARGETNAME).$(TARGETEXT:lib=dll)\"" \
 $(DEFINE_SYSTEM_COMPATIBLE_ASSEMBLY_NAME) \
 $(SXS_MANIFEST_DEFINES)

#MANIFEST_PREPROCESSOR_NAME=$(C_PREPROCESSOR_NAME)
# $(TARGET_CPP) does not include -FIwarning.h.
# Otherwise we have to filter the data through, like Perl:
# while (<>) {
#       if (!/^#pragma.+/ && !/^$/) {
#               print;
#       }
#}
!ifndef MANIFEST_PREPROCESSOR_NAME
MANIFEST_PREPROCESSOR_NAME=preprocessor.exe
!endif
!ifndef MANIFEST_VALIDATOR_SCHEMA
MANIFEST_VALIDATOR_SCHEMA=$(NTMAKEENV)\appschema.xml
!endif
!ifndef MANIFEST_VALIDATOR_NAME
MANIFEST_VALIDATOR_NAME=FusionManifestValidator /b /s:$(MANIFEST_VALIDATOR_SCHEMA)
!endif

#
# .manifest-src -> .man
#
{}.manifest-src{$(O)}.man:
    $(MANIFEST_PREPROCESSOR_NAME) -o $@ -i $< $(SXS_MANIFEST_DEFINES)
    $(MANIFEST_VALIDATOR_NAME) /m:$@

{..}.manifest-src{$(O)}.man:
    $(MANIFEST_PREPROCESSOR_NAME) -o $@ -i $< $(SXS_MANIFEST_DEFINES)
    $(MANIFEST_VALIDATOR_NAME) /m:$@

{..\..}.manifest-src{$(O)}.man:
    $(MANIFEST_PREPROCESSOR_NAME) -o $@ -i $< $(SXS_MANIFEST_DEFINES)
    $(MANIFEST_VALIDATOR_NAME) /m:$@

#
# .manifest-src -> .manifest
#
{}.manifest-src{$(O)}.manifest:
    $(MANIFEST_PREPROCESSOR_NAME) -o $@ -i $< $(SXS_MANIFEST_DEFINES)
    $(MANIFEST_VALIDATOR_NAME) /m:$@

{..}.manifest-src{$(O)}.manifest:
    $(MANIFEST_PREPROCESSOR_NAME) -o $@ -i $< $(SXS_MANIFEST_DEFINES)
    $(MANIFEST_VALIDATOR_NAME) /m:$@

{..\..}.manifest-src{$(O)}.manifest:
    $(MANIFEST_PREPROCESSOR_NAME) -o $@ -i $< $(SXS_MANIFEST_DEFINES)
    $(MANIFEST_VALIDATOR_NAME) /m:$@

#
# .manifest -> .man
#
{}.manifest{$(O)}.man:
    $(MANIFEST_PREPROCESSOR_NAME) -o $@ -i $< $(SXS_MANIFEST_DEFINES)
    $(MANIFEST_VALIDATOR_NAME) /m:$@

{..}.manifest{$(O)}.man:
    $(MANIFEST_PREPROCESSOR_NAME) -o $@ -i $< $(SXS_MANIFEST_DEFINES)
    $(MANIFEST_VALIDATOR_NAME) /m:$@

{..\..}.manifest{$(O)}.man:
    $(MANIFEST_PREPROCESSOR_NAME) -o $@ -i $< $(SXS_MANIFEST_DEFINES)
    $(MANIFEST_VALIDATOR_NAME) /m:$@

{$(SXS_MANIFEST_SOURCE)}.manifest{$(O)}.man:
    $(MANIFEST_PREPROCESSOR_NAME) -o $@ -i $< $(SXS_MANIFEST_DEFINES)
    $(MANIFEST_VALIDATOR_NAME) /m:$@

#
# .manifest -> .manifest
#
{}.manifest{$(O)}.manifest:
    $(MANIFEST_PREPROCESSOR_NAME) -o $@ -i $< $(SXS_MANIFEST_DEFINES)
    $(MANIFEST_VALIDATOR_NAME) /m:$@

{..}.manifest{$(O)}.manifest:
    $(MANIFEST_PREPROCESSOR_NAME) -o $@ -i $< $(SXS_MANIFEST_DEFINES)
    $(MANIFEST_VALIDATOR_NAME) /m:$@

{..\..}.manifest{$(O)}.manifest:
    $(MANIFEST_PREPROCESSOR_NAME) -o $@ -i $< $(SXS_MANIFEST_DEFINES)
    $(MANIFEST_VALIDATOR_NAME) /m:$@

{$(SXS_MANIFEST_SOURCE)}.manifest{$(O)}.manifest:
    $(MANIFEST_PREPROCESSOR_NAME) -o $@ -i $< $(SXS_MANIFEST_DEFINES)
    $(MANIFEST_VALIDATOR_NAME) /m:$@

#
# .manifest -> .o_manifest
#
{}.manifest{$(O)}.o_manifest:
    $(MANIFEST_PREPROCESSOR_NAME) -o $@ -i $< $(SXS_MANIFEST_DEFINES)
    $(MANIFEST_VALIDATOR_NAME) /m:$@

{..}.manifest{$(O)}.o_manifest:
    $(MANIFEST_PREPROCESSOR_NAME) -o $@ -i $< $(SXS_MANIFEST_DEFINES)
    $(MANIFEST_VALIDATOR_NAME) /m:$@

{..\..}.manifest{$(O)}.o_manifest:
    $(MANIFEST_PREPROCESSOR_NAME) -o $@ -i $< $(SXS_MANIFEST_DEFINES)
    $(MANIFEST_VALIDATOR_NAME) /m:$@

{$(SXS_MANIFEST_SOURCE)}.manifest{$(O)}.o_manifest:
    $(MANIFEST_PREPROCESSOR_NAME) -o $@ -i $< $(SXS_MANIFEST_DEFINES)
    $(MANIFEST_VALIDATOR_NAME) /m:$@

#
# Standard inference rule for generating machine specific def files.
#

.SUFFIXES: .def .src

{..\}.src{$(O)}.def:
    @type <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<$(BUILD_NOKEEP)
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $@
$(CPPXX: =
)
<<$(BUILD_NOKEEP)

{}.src{$(O)}.def:
    @type <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<$(BUILD_NOKEEP)
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $@
$(CPPXX: =
)
<<$(BUILD_NOKEEP)

{..\}.def{$(O)}.def:
    @type <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<$(BUILD_NOKEEP)
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $@
$(CPPXX: =
)
<<$(BUILD_NOKEEP)

{}.def{$(O)}.def:
    @type <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<$(BUILD_NOKEEP)
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $@
$(CPPXX: =
)
<<$(BUILD_NOKEEP)

# one more level down for HALS
{..\..\}.src{$(O)}.def:
    @type <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<$(BUILD_NOKEEP)
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< > $@
$(CPPXX: =
)
<<$(BUILD_NOKEEP)

!ifdef NO_BROWSER_FILE
BROWSERFILE=
!else
! ifdef BROWSER_INFO
!  ifndef BROWSERFILE
!   if "$(TARGETNAME)" == ""
BROWSERFILE=
!   else
BROWSERFILE=$(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).bsc
!   endif
!  endif
! else
BROWSERFILE=
! endif
!endif

!if defined (USE_LINT) && ("$(LINT_TYPE)" != "all")

{}.cxx{$(O)\}.lob:
! if "$(LINT_TYPE)" != "lob"
    @echo done >$@
! endif
    $(LINT_CMD) $<

{$(TARGET_DIRECTORY)\}.cxx{$(O)\}.lob:
! if "$(LINT_TYPE)" != "lob"
    @echo done >$@
! endif
    $(LINT_CMD) $<

{..\}.cxx{$(O)\}.lob:
! if "$(LINT_TYPE)" != "lob"
    @echo done >$@
! endif
    $(LINT_CMD) $<

{..\$(TARGET_DIRECTORY)\}.cxx{$(O)\}.lob:
! if "$(LINT_TYPE)" != "lob"
    @echo done >$@
! endif
    $(LINT_CMD) $<

{}.cpp{$(O)\}.lob:
! if "$(LINT_TYPE)" != "lob"
    @echo done >$@
! endif
    $(LINT_CMD) $<

{$(TARGET_DIRECTORY)\}.cpp{$(O)\}.lob:
! if "$(LINT_TYPE)" != "lob"
    @echo done >$@
! endif
    $(LINT_CMD) $<

{..\}.cpp{$(O)\}.lob:
! if "$(LINT_TYPE)" != "lob"
    @echo done >$@
! endif
    $(LINT_CMD) $<

{..\$(TARGET_DIRECTORY)\}.cpp{$(O)\}.lob:
! if "$(LINT_TYPE)" != "lob"
    @echo done >$@
! endif
    $(LINT_CMD) $<

{}.c{$(O)\}.lob:
! if "$(LINT_TYPE)" != "lob"
    @echo done >$@
! endif
    $(LINT_CMD) $<

{$(TARGET_DIRECTORY)\}.c{$(O)\}.lob:
! if "$(LINT_TYPE)" != "lob"
    @echo done >$@
! endif
    $(LINT_CMD) $<

{..\}.c{$(O)\}.lob:
! if "$(LINT_TYPE)" != "lob"
    @echo done >$@
! endif
    $(LINT_CMD) $<

{..\$(TARGET_DIRECTORY)\}.c{$(O)\}.lob:
! if "$(LINT_TYPE)" != "lob"
    @echo done >$@
!endif
    $(LINT_CMD) $<

!endif

#
# Standard list of targets: all, clean and loc.  all is the default target.
#

!IFNDEF PASS0ONLY
all: \
        $(O) \
        $(_OBJ_DIR)\_objects.mac \
! if defined(DO_LANGUAGE_NEUTRAL) 
        $(MUI_MANIFEST_OBJ1) \
! endif
!if defined(ASSEMBLY_MISCFILES)
        $(O)\_miscfiles.xml \
!endif
!if defined(ASSEMBLY_IDENTITY)
        $(O)\_asmid.inc \
        $(O)\_asmid.xml \
!endif
        $(_NTTREE_IDENTITIES_ASSEMBLY_KEY_FORM_TXT) \
        $(O_BINARY_METADATA) \
        $(MANIFEST_STRING_REPLACEMENTS) \
        $(NTTARGETFILE0)  \
        $(SOURCE_MANIFEST) \
        $(WOW64_SOURCE_MANIFEST) \
        $(WPP_TARGETS) \
        $(PASS0_OBJECTS) \
        PASS0_Pub    \
        PASS0_Binp   \
        $(PRECOMPILED_TARGET) \
        $(HEADEROBJNAME) \
        build_objects \
        $(SXS_MANIFEST_OBJ1) \
        $(SXS_MANIFEST_OBJ2) \
        $(SN_SIGN_SPEC) \
        $(TARGETLOBFILES1) \
        $(TARGETLIBFILES) \
        $(NTTARGETFILE1)  \
! if defined(DO_LANGUAGE_NEUTRAL) && !defined(NOLINK) && "$(MYMUILINK)" != ""
        $(TARGET).mui \
! endif
!if  defined(DO_LSBUILD) && !defined(NOLINK) && "$(LCX_DEPEND)" != ""
        $(LCX_TARGET) \
! endif
        $(TARGETEXEFILES) \
!if "$(BROWSERFILE)" != ""
        $(BROWSERFILE)   \
!endif
        $(TARGETLOBFILES2) \
        PASS1_Pub     \
        PASS1_Binp   \
        build_umobjects \
!ifndef NOLINK
        $(UMEXEFILES) \
!endif
!ifdef MANAGED_COVERAGE
        MANAGED_CODECOVER \
!endif
        $(NTTARGETFILES) \
!if "$(MAKEDLL)" != "" && !defined(NOLINK)
        $(O_ASMMETA) \
!endif
        PASS2_Pub     \
        PASS2_Binp    \
        $(OUTPUT_MANIFEST) \
! if !$(MISCFILES_DURING_LINK) || !defined(NOLINK)
!  if "$(MISCFILES: =)" != "" || defined(SXS_MISCFILES)
        $(MISCFILES) \
        $(SXS_MISCFILES) \
!   ifdef _NTTREE
        binplace_miscfiles \
!   endif
!  endif
!  if "$(ASSEMBLY_MISCFILES)" != ""
        $(ASSEMBLY_MISCFILES) \
!   ifdef _NTTREE
        binplace_assembly_miscfiles \
!   endif
!  endif
!endif
! if "$(LOC_MISCFILES: =)" != "" &&  !defined(NO_BINPLACE)
# "all" depends on : $(LOC_MISCFILES)
# what is the rule then? Phony. Let binplace.exe verify the timestamps
        $(LOC_MISCFILES) \
        binplace_loc_miscfiles \
!endif
!ifdef SXS_LOG_CMD
        sxs_log_cmd \
!endif
        BINARY_Pub  \
        LastStep
! if "$(BUILDMSG)" != ""
    @echo.
    @echo $(BUILDMSG)
! endif

LastStep:

!ifdef SXS_LOG_CMD
sxs_log_cmd:
    $(SXS_LOG_CMD)
!endif


binplace_loc_miscfiles: $(LOC_MISCFILES)
# using CMD to do the logic ...
!ifndef NO_BINPLACE
     for %F in ($**) do @(if exist %F.lci (\
     copy %F $(O) & \
     @echo $(LSBUILD_TOOL) parse /l $(LSBUILD_LANG) /c %F.lci  /o $(O)\%F.lcg  %F  & \
     $(LSBUILD_TOOL) parse /l $(LSBUILD_LANG) /c %F.lci  /o $(O)\%F.lcg  %F  & \
     $(BINPLACE_TOOL) $(BINPLACE_FLAGS) $(LOC_BINPLACE_FLAGS) $(O)\%F.lcg ))
     for %F in ($**) do @(if NOT exist %F.lci (\
     copy %F $(O) & \
     @echo $(LSBUILD_TOOL) parse /l $(LSBUILD_LANG) /o $(O)\%F.lcg  %F  & \
     $(LSBUILD_TOOL) parse /l $(LSBUILD_LANG) /o $(O)\%F.lcg  %F  & \
     $(BINPLACE_TOOL) $(BINPLACE_FLAGS) $(LOC_BINPLACE_FLAGS) $(O)\%F.lcg ))

!endif

binplace_miscfiles: $(MISCFILES) $(SXS_MISCFILES)
!ifndef NO_BINPLACE
    $(MAKE_PLACEFILE_CMD)
    $(BINPLACE_TOOL) $(BINPLACE_FLAGS) $(BINPLACE_MISC_FLAGS) $(BINPLACE_LC_MISCFLAGS) @<<
$**
<<$(BUILD_NOKEEP)
!endif

binplace_assembly_miscfiles: $(ASSEMBLY_MISCFILES)
!if !defined(NO_BINPLACE) && "$(ASSEMBLY_BINPLACE_DEST)" != ""
    $(MAKE_PLACEFILE_CMD)
    $(BINPLACE_TOOL) -:DEST $(ASSEMBLY_BINPLACE_DEST) $(BINPLACE_FLAGS) $(BINPLACE_MISC_FLAGS) $(BINPLACE_LC_MISCFLAGS) @<<
$**
<<$(BUILD_NOKEEP)
!endif

build_objects: $(TARGETOBJFILES)

build_umobjects: $(UMOBJFILES)

!ELSE   # PASS0ONLY

all: \
        $(O) \
!if defined(ASSEMBLY_MISCFILES)
        $(O)\_miscfiles.xml \
!endif
!if defined(ASSEMBLY_IDENTITY)
        $(O)\_asmid.inc \
        $(O)\_asmid.xml \
!endif
        $(_NTTREE_IDENTITIES_ASSEMBLY_KEY_FORM_TXT) \
        $(O_BINARY_METADATA) \
        $(MANIFEST_STRING_REPLACEMENTS) \
        $(NTTARGETFILE0)  \
        $(WPP_TARGETS) \
        $(PASS0_OBJECTS) \
    PASS0_Pub \
    PASS0_Binp
! IF "$(BUILDMSG)" != ""
    @echo.
    @echo $(BUILDMSG)
! ENDIF

!ENDIF  # PASS0ONLY

!if defined(DO_LSBUILD) && !defined(NOLINK) && "$(LCX_DEPEND)" != ""

$(LCX_TARGET): $(LCX_DEPEND)
    @echo MUI_DEPEND=$(MUI_DEPEND)
    @echo LCX_DEPEND=$(LCX_DEPEND)
    @<<$(LCX_TARGET).cmd    
    @IF NOT EXIST $(MUI_DEPEND) goto :EOF
    @SETLOCAL
    @echo Building $(LCX_TARGET)
    @SET _L=
    @FOR /f %%. IN ('perl $(RAZZLETOOLPATH)\cklang.pm -o:LCID -l $(LANGUAGE)') DO @SET L_=%%.
    @FOR %%. IN ($(MUI_DEPEND)) DO @$(LCX_BUILD_CMD) /l %L_% $(LCX_FLAGS) /basepath %%~dp. %%~nx.
# call additional binplace command line causing lcg file be binplaced
!ifdef NO_BINPLACE
    @$(BINPLACE_TOOL) $(BINPLACE_FLAGS) $(LCX_BINPLACE_FLAGS) $(LCX_TARGET)
!endif #  NO_BINPLACE
    @ENDLOCAL
<<NOKEEP

!endif # DO_LSBUILD

$(O):
    if not exist $(@)\ mkdir $(@)
    if not exist $(@)\ echo $(BUILD_MSG_ERROR) unable to make $(@).

update:
    @echo Updating library.

$(_OBJ_DIR)\_objects.mac: $(SOURCES_USED)
    @echo Rebuilding $(_OBJ_DIR)\_objects.mac from $(SOURCES_USED).
    @build -OZf >nul 2>&1
    @echo $(_OBJ_DIR)\_objects.mac was rebuilt, please reinvoke NMAKE
    @REM The following line is intended to produce an error -- access denied.
    @mkdir \ >nul 2>nul

!ifdef NO_BINPLACE
PASS0_BINP:

PASS1_BINP:

PASS2_BINP:

!else
PASS0_BINP:
!if defined(PASS0_BINPLACE) && "$(BUILD_PASS)" != "PASS1" && "$(BUILD_PASS)" != "PASS2"
    $(MAKE_PLACEFILE_CMD)
    $(BINPLACE_TOOL) @<<
$(BINPLACE_FLAGS)
$(PASS0_BINPLACE)
<<$(BUILD_NOKEEP)
!endif

PASS1_BINP:
!if defined(PASS1_BINPLACE) && "$(BUILD_PASS)" != "PASS0" && "$(BUILD_PASS)" != "PASS2"
    $(MAKE_PLACEFILE_CMD)
    $(BINPLACE_TOOL) @<<
$(BINPLACE_FLAGS)
$(PASS1_BINPLACE)
<<$(BUILD_NOKEEP)
!endif

PASS2_BINP:
!if defined(PASS2_BINPLACE) && "$(BUILD_PASS)" != "PASS0" && "$(BUILD_PASS)" != "PASS1"
    $(MAKE_PLACEFILE_CMD)
    $(BINPLACE_TOOL) @<<
$(BINPLACE_FLAGS)
$(PASS2_BINPLACE)
<<$(BUILD_NOKEEP)
!endif

!endif  # else for !ifdef NO_BINPLACE

PASS0_Pub:
!if defined(PASS0_PUBLISH) && "$(BUILD_PASS)" != "PASS1" && "$(BUILD_PASS)" != "PASS2"
    $(PUBLISH_CMD) -F <<
$(PASS0_PUBLISH:}=}
)
<<$(BUILD_NOKEEP)
!endif

PASS1_Pub:
!if defined(PASS1_PUBLISH) && "$(BUILD_PASS)" != "PASS0" && "$(BUILD_PASS)" != "PASS2" && !defined(NOLIB)
    $(PUBLISH_CMD) -F <<
$(PASS1_PUBLISH:}=}
)
<<$(BUILD_NOKEEP)
!endif

PASS2_Pub:
!if defined(PASS2_PUBLISH) && "$(BUILD_PASS)" != "PASS0" && "$(BUILD_PASS)" != "PASS1"
    $(PUBLISH_CMD) -F <<
$(PASS2_PUBLISH:}=}
)
<<$(BUILD_NOKEEP)
!endif

#
# Binary drop runs only during the link phase
#

BINARY_Pub:
!ifdef BINARY_PUBLISH
! if "$(BINPUBLISH)" == "1"
    $(BINDROP_CMD) -F <<
$(BINARY_PUBLISH:}=}
)
<<$(BUILD_NOKEEP)
! else
    @echo BINARY_PUBLISH_PROJECTS in environment doesn't contain $(_PROJECT_) -
    @echo binaries will not be published.
! endif
!else if defined(BINARY_PUBLISH_FILES)
! if "$(BINPUBLISH)" == "1"
    @cmd /v:on /c make_publish_spec.cmd $(BINARY_PUBLISH_ROOT) $(O) $(BINARY_PUBLISH_FILES) | $(BINDROP_CMD) -I
! else
    @echo BINARY_PUBLISH_PROJECTS in environment doesn't contain $(_PROJECT_) -
    @echo binaries will not be published.
! endif
!endif

!if defined(SOURCE_MANIFEST) || defined(WOW64_SOURCE_MANIFEST) || defined(CMI_COMPILE_MANIFESTS)

!ifndef MANIFEST_COMPILER_ARGUMENTS

!if $(FREEBUILD)
MANIFEST_BUILD_TYPE=release
!else
MANIFEST_BUILD_TYPE=debug
!endif

MANIFEST_HASH_ALGORITHM=SHA1

MANIFEST_VERSION=$(VER_PRODUCTVERSION_STR)

!ifdef CMI_MANIFEST_LANGUAGE
MANIFEST_LANGUAGE=$(CMI_MANIFEST_LANGUAGE)
!else
MANIFEST_LANGUAGE=neutral
!endif

#
# MUI related substitutions
#

!ifdef CMI_MANIFEST_CULTURE_NAME_STRING
MANIFEST_CULTURE_NAME_STRING=$(CMI_MANIFEST_CULTURE_NAME_STRING)
!else
MANIFEST_CULTURE_NAME_STRING=en-US
!endif

!ifdef CMI_MANIFEST_CULTURE_NEUTRAL_NAME_STRING
MANIFEST_CULTURE_NEUTRAL_NAME_STRING=$(CMI_MANIFEST_CULTURE_NEUTRAL_NAME_STRING)
!else
MANIFEST_CULTURE_NEUTRAL_NAME_STRING=en
!endif

!ifdef CMI_MANIFEST_CULTURE_SPECIFIC_NAME_STRING
MANIFEST_CULTURE_SPECIFIC_NAME_STRING=$(CMI_MANIFEST_CULTURE_SPECIFIC_NAME_STRING)
!else
MANIFEST_CULTURE_SPECIFIC_NAME_STRING=en-US
!endif

!ifdef CMI_MANIFEST_CULTURE_LANG_ID_HEX
MANIFEST_CULTURE_LANG_ID_HEX=$(CMI_MANIFEST_CULTURE_LANG_ID_HEX)
!else
MANIFEST_CULTURE_LANG_ID_HEX=0409
!endif

!ifdef CMI_MANIFEST_CULTURE_PRIMARY_LANG_ID_HEX
MANIFEST_CULTURE_PRIMARY_LANG_ID_HEX=$(CMI_MANIFEST_CULTURE_PRIMARY_LANG_ID_HEX)
!else
MANIFEST_CULTURE_PRIMARY_LANG_ID_HEX=0009
!endif

!ifdef CMI_MANIFEST_CULTURE_FULL_LANG_ID_HEX
MANIFEST_CULTURE_FULL_LANG_ID_HEX=$(CMI_MANIFEST_CULTURE_FULL_LANG_ID_HEX)
!else
MANIFEST_CULTURE_FULL_LANG_ID_HEX=0409
!endif

#
# URT related substitutions
#

#
# MANIFEST_CLR_VERSION_STR is expected to have this format: v(\d+)\.(\d+)\.(\d+)
# for example v1.0.3705
#

!if (!defined(URT_VER) || "$(URT_VER)" == "1.2") && defined(URT_VER_1_2)
MANIFEST_CLR_VERSION_STR=$(URT_VER_1_2)
!endif
!if "$(URT_VER)" == "1.1" && defined(URT_VER_1_2)
MANIFEST_CLR_VERSION_STR=$(URT_VER_1_1)
!endif
!if "$(URT_VER)" == "1.0" && defined(URT_VER_1_2)
MANIFEST_CLR_VERSION_STR=$(URT_VER_1_0)
!endif

#
# in case nothing is defined
#
!if !defined(MANIFEST_CLR_VERSION_STR)
MANIFEST_CLR_VERSION_STR=v1.0.0
!endif

MANIFEST_CLR_PATH=$$(runtime.windows)\Microsoft.NET\Framework\$(MANIFEST_CLR_VERSION_STR)


MANIFEST_COMPILER_ARGUMENTS=\
    $$(build.version) $(MANIFEST_VERSION) \
    $$(build.majorVersion),$$(build.minorVersion),$$(build.buildNumber),$$(build.revision):(\d+)\.(\d+)\.(\d+)\.(\d+) $(MANIFEST_VERSION) \
    $$build.version $(MANIFEST_VERSION) \
    $$(build.language) $(MANIFEST_LANGUAGE) \
    $$build.language $(MANIFEST_LANGUAGE) \
    $$(build.buildType) $(MANIFEST_BUILD_TYPE) \
    $$build.buildType $(MANIFEST_BUILD_TYPE) \
    $$(build.processorArchitecture) $(SXS_PROCESSOR_ARCHITECTURE) \
    $$(build.hashAlgorithmType) $(MANIFEST_HASH_ALGORITHM) \
    $$build.processor $(SXS_PROCESSOR_ARCHITECTURE) \
    $$(build.hostarch) $(PROCESSOR_ARCHITECTURE) \
    $$(build.cultureNameString) $(MANIFEST_CULTURE_NAME_STRING) \
    $$(build.cultureNeutralNameString) $(MANIFEST_CULTURE_NEUTRAL_NAME_STRING) \
    $$(build.cultureSpecificNameString) $(MANIFEST_CULTURE_SPECIFIC_NAME_STRING) \
    $$(build.cultureLangIdHex) $(MANIFEST_CULTURE_LANG_ID_HEX) \
    $$(build.culturePrimaryLangIdHex) $(MANIFEST_CULTURE_PRIMARY_LANG_ID_HEX) \
    $$(build.cultureFullLangIdHex) $(MANIFEST_CULTURE_FULL_LANG_ID_HEX) \
    $$(build.clrVersionStr) $(MANIFEST_CLR_VERSION_STR) \
    $$(build.clrPath) $(MANIFEST_CLR_PATH) \
    $$(build.publicKeyToken) "" \
    $$(build.clrVersion):v(.+) $(MANIFEST_CLR_VERSION_STR)
!endif


#
# CMI_MANIFEST_COMPILER_EXTRA_ARGUMENTS must be a list of name-value pairs.
#
# 1. The name must either of format $(build.*) or $build.*
# 2. The value must not be spaces or empty.
# 3. If name or value contains space, it must be quoted.
# 4. name and value must be delimited by a space
# 5. each pair must be delimited by a space
# 6. a name specified here can NOT override any default name specified in
#    this makefile.def
#
# N.B. name is case-censitive.
#
# e.g.
#
# CMI_MANIFEST_COMPILER_EXTRA_ARGUMENTS=\
#    $$(build.myTargetName) $(TARGETNAME) \
#    $$(build.myTargetPath) $(TARGETPATH)
#
!ifdef CMI_MANIFEST_COMPILER_EXTRA_ARGUMENTS
MANIFEST_COMPILER_ARGUMENTS=$(CMI_MANIFEST_COMPILER_EXTRA_ARGUMENTS) $(MANIFEST_COMPILER_ARGUMENTS)
!endif


!ifdef CMI_MANIFEST_BINPLACE
MANIFEST_DIRECTORY=$(CMI_MANIFEST_BINPLACE)
!undef MANIFEST_DIRECTORY2
!else
MANIFEST_DIRECTORY=cmicomponents
MANIFEST_DIRECTORY2=cmiconverted
!undef MANIFEST_DIRECTORY2
!endif

!ifdef CMI_MANIFEST_LANGUAGE
MANIFEST_DIRECTORY=$(MANIFEST_DIRECTORY)\$(LANGUAGE)
!ifdef MANIFEST_DIRECTORY2
MANIFEST_DIRECTORY2=$(MANIFEST_DIRECTORY2)\$(LANGUAGE)
!endif
!endif

!ifdef SOURCE_MANIFEST
$(SOURCE_MANIFEST): $(CMI_MANIFESTS)
    !$(MANIFEST_COMPILER_CMD) $? $(O)\$(?F) $(MANIFEST_COMPILER_ARGUMENTS) $$(build.arch) $(SXS_PROCESSOR_ARCHITECTURE)
!ifdef CMI_USE_VERSION_XML
    !nmake -nologo -f $(NTMAKEENV)\makefile.def replace_in_xml REPLACE_IN_XML_INPUT=$(O)\$(?F) REPLACE_IN_XML_OUTPUT=$(O)\$(?F) NO_GENERATED_STRING_REPLACEMENTS_XML=1
!endif
    !echo $(O)\$(?F) >> $(SOURCE_MANIFEST)
    $(BINPLACE_CMD) -:DEST $(MANIFEST_DIRECTORY) @$(SOURCE_MANIFEST)
!ifdef MANIFEST_DIRECTORY2
    $(BINPLACE_CMD) -:DEST $(MANIFEST_DIRECTORY2) @$(SOURCE_MANIFEST)
!endif
!endif

!ifdef WOW64_SOURCE_MANIFEST
$(WOW64_SOURCE_MANIFEST): $(CMI_WOW64_MANIFESTS)
    @setlocal
    set build.arch=wow64
    !$(MANIFEST_COMPILER_CMD) $? $(O)\wow64_$(?F) $(MANIFEST_COMPILER_ARGUMENTS) $$(build.arch) wow64
!ifdef CMI_USE_VERSION_XML
    !nmake -nologo -f $(NTMAKEENV)\makefile.def replace_in_xml REPLACE_IN_XML_INPUT=$(O)\wow64_$(?F) REPLACE_IN_XML_OUTPUT=$(O)\wow64_$(?F) NO_GENERATED_STRING_REPLACEMENTS_XML=1
!endif
    !echo $(O)\wow64_$(?F) >> $(WOW64_SOURCE_MANIFEST)
    $(BINPLACE_CMD) -:DEST $(MANIFEST_DIRECTORY)\wow6432 @$(WOW64_SOURCE_MANIFEST)
!ifdef MANIFEST_DIRECTORY2
    $(BINPLACE_CMD) -:DEST $(MANIFEST_DIRECTORY2)\wow6432 @$(WOW64_SOURCE_MANIFEST)
!endif
    @endlocal
!endif

!ifdef CMI_COMPILE_MANIFESTS

cmi_compile_manifests:
    $(MANIFEST_COMPILER_CMD) $(CMI_COMPILE_MANIFESTS_INPUT) $(CMI_COMPILE_MANIFESTS_OUTPUT) $(MANIFEST_COMPILER_ARGUMENTS) $$(build.arch) $(SXS_PROCESSOR_ARCHITECTURE)

!endif


!endif

!IF DEFINED(NTTARGETFILES) || DEFINED(NTTARGETFILE0) || DEFINED(NTTARGETFILE1) || DEFINED(USE_MAKEFILE_INC)
! INCLUDE .\makefile.inc
!ENDIF

!if defined(COM_VISIBLE)

!if "$(COM_VISIBLE)" == "0"
COM_VISIBLE=false
!endif
!if "$(COM_VISIBLE)" == "1"
COM_VISIBLE=true
!endif

!if defined(MANAGED_CODE) # C#

SOURCES=$(SOURCES) $(O)\_comvisible.cs

$(O)\_comvisible.cs: $(SOURCES_USED)
    @echo BUILDMSG2: making $(@F)
    @REM <<$(@)
[assembly:System.Runtime.InteropServices.ComVisible($(COM_VISIBLE))]
<<KEEP

!elseif defined(MANAGED_CXX)

OBJECTS=$(OBJECTS) $(O)\_comvisible.obj

$(O)\_comvisible.cpp: $(SOURCES_USED)
    @echo BUILDMSG2: making $(@F)
    @REM <<$(@)
!if "$(PRECOMPILED_INCLUDE)" != "" && "$(PRECOMPILED_CXX)" != "" && "$(NTNOPCH)" != "1"
#include "$(PRECOMPILED_INCLUDE:\=\\)"
!endif
#using <mscorlib.dll>
[assembly:System::Runtime::InteropServices::ComVisible($(COM_VISIBLE))];
<<KEEP

!elseif defined(MANAGED_VB)

!message $(BUILD_ERROR_MSG) COM_VISIBLE not implemented for Visual Basic

!else

!message $(BUILD_ERROR_MSG) COM_VISIBLE unknown language

!endif # MANAGED_CODE, MANAGED_CXX, MANAGED_VB
!endif # COM_VISIBLE

#
# MUI Manifest
#
.SUFFIXES: .muimanifest .mmf 
#
# .muimanifest -> .mmf
#       

{$(MUI_MANIFEST_ROOT)}.muimanifest{$(O)}.mmf:    
    $(MUI_MANIFEST_PREPROCESSOR_NAME) -o $@ -i $< $(MUI_MANIFEST_DEFINES)

{..\..}.muimanifest{$(O)}.mmf:
    $(MUI_MANIFEST_PREPROCESSOR_NAME) -o $@ -i $< $(MUI_MANIFEST_DEFINES)   
       
{..}.muimanifest{$(O)}.mmf:
    $(MUI_MANIFEST_PREPROCESSOR_NAME) -o $@ -i $< $(MUI_MANIFEST_DEFINES)
   
{}.muimanifest{$(O)}.mmf:
    $(MUI_MANIFEST_PREPROCESSOR_NAME) -o $@ -i $< $(MUI_MANIFEST_DEFINES)
    

#
# generate ntassemblyinfo.cs, ntassemblyinfo.cpp
#
.SUFFIXES: .muimanifest .mmf 
#
# .muimanifest -> .mmf
#       

{$(MUI_MANIFEST_ROOT)}.muimanifest{$(O)}.mmf:    
    $(MUI_MANIFEST_PREPROCESSOR_NAME) -o $@ -i $< $(MUI_MANIFEST_DEFINES)

{..\..}.muimanifest{$(O)}.mmf:
    $(MUI_MANIFEST_PREPROCESSOR_NAME) -o $@ -i $< $(MUI_MANIFEST_DEFINES)   
       
{..}.muimanifest{$(O)}.mmf:
    $(MUI_MANIFEST_PREPROCESSOR_NAME) -o $@ -i $< $(MUI_MANIFEST_DEFINES)
   
{}.muimanifest{$(O)}.mmf:
    $(MUI_MANIFEST_PREPROCESSOR_NAME) -o $@ -i $< $(MUI_MANIFEST_DEFINES)
    

# Generate assembly info in ntassemblyinfo.cs, ntassemblyinfo.cpp.
# Valid values for GENERATE_NT_ASSEMBLY_INFO:
#    1 - Only apply the AssemblyVersion attribute.
#    2 - Apply the AssemblyProduct, AssemblyCopyright, and AssemblyTrademark
#        attributes as well.
#

!if "$(GENERATE_NT_ASSEMBLY_INFO)" == "1" || "$(GENERATE_NT_ASSEMBLY_INFO)" == "2"

!if defined(MANAGED_CODE) # C#

SOURCES=$(SOURCES) $(O)\_ntassemblyinfo.cs

$(O)\_ntassemblyinfo.cs: $(SOURCES_USED)
    @echo BUILDMSG2: making $(@F)
!if !defined(ASSEMBLY_IDENTITY_VERSION)
    echo $(BUILD_ERROR_MSG) makefile.def unable to make _ntassemblyinfo.cs
!endif
    @REM <<$(@)
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!if "$(GENERATE_NT_ASSEMBLY_INFO)" == "2"
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
[assembly:System.Reflection.AssemblyTrademark("$(VER_PRODUCTNAME_STR)")]
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif # GENERATE_NT_ASSEMBLY_INFO == 2
<<KEEP

!elseif defined(MANAGED_CXX)

OBJECTS=$(OBJECTS) $(O)\_ntassemblyinfo.obj

$(O)\_ntassemblyinfo.cpp: $(SOURCES_USED)
    @echo BUILDMSG2: making $(@F)
!if !defined(ASSEMBLY_IDENTITY_VERSION)
    echo $(BUILD_ERROR_MSG) makefile.def unable to make _ntassemblyinfo.cpp
!endif
    @REM <<$(@)
!if "$(PRECOMPILED_INCLUDE)" != "" && "$(PRECOMPILED_CXX)" != "" && "$(NTNOPCH)" != "1"
#include "$(PRECOMPILED_INCLUDE:\=\\)"
!endif
#using <mscorlib.dll>
[assembly:System::Reflection::AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")];
!if "$(GENERATE_NT_ASSEMBLY_INFO)" == "2"
[assembly:System::Reflection::AssemblyProduct("$(VER_PRODUCTNAME_STR)")];
[assembly:System::Reflection::AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")];
[assembly:System::Reflection::AssemblyTrademark("$(VER_PRODUCTNAME_STR)")];
[assembly:System::Reflection::AssemblyCompany("$(VER_COMPANYNAME_STR)")];
!endif # GENERATE_NT_ASSEMBLY_INFO == 2
<<KEEP

!elseif defined(MANAGED_VB)

!message $(BUILD_ERROR_MSG) GENERATE_NT_ASSEMBLY_INFO not implemented for Visual Basic

!else

!message $(BUILD_ERROR_MSG) GENERATE_NT_ASSEMBLY_INFO unknown language

!endif # MANAGED_CODE, MANAGED_CXX, MANAGED_VB
!endif # GENERATE_NT_ASSEMBLY_INFO

#
# HACK FOR ERROR CS0122 METHOD PROTECTION LEVEL
#

!if "$(URT_VER)" != "1.0" && "$(URT_VER)" != "1.1"
!if "$(URT_VER_1_2)" >= "v2.0.31104"
USER_CS_FLAGS=$(USER_CS_FLAGS) /test:AllowBadRetTypeAccess
!endif
!endif


#
# Disable warning CS1699 to use _keyfile.cs
#

!if "$(URT_VER)" != "1.0" && "$(URT_VER)" != "1.1"
!if "$(URT_VER_1_2)" >= "v2.0.31104"
USER_CS_FLAGS=$(USER_CS_FLAGS) /nowarn:1699
!endif
!endif


#
# Include keyfile information in a managed assembly
#

!if "$(BUILD_PRODUCT)" == "NT" && $(PROJECT_BUILDS_MANAGED_CODE) && ("$(MANAGED_DELAYSIGN_KEYFILE)" == "1" || "$(MANAGED_DELAYSIGN_KEYFILE)" == "$(NTMAKEENV)\keypair.snk")
MANAGED_DELAYSIGN_KEYFILE=$(NTMAKEENV)\publickey.snk
!endif

!if defined( MANAGED_DELAYSIGN_KEYFILE ) || defined( SN_SIGN_TARGET )

!if "$(MANAGED_DELAYSIGN_KEYFILE)" != "1"

!if defined( MANAGED_DELAYSIGN_KEYFILE ) && ! defined(ASSEMBLY_IDENTITY)
!message $(BUILD_WARNING_MSG) MANAGED_DELAYSIGN_KEYFILE defined without ASSEMBLY_IDENTITY - change to use ASSEMBLY_IDENTITY and SN_SIGN_TARGET
!endif

ASMID_TO_ATTRIBS_CMD=cscript /E:jscript /nologo $(RAZZLETOOLPATH)\asmIdToAttribs.js

!if defined(MANAGED_CODE)

SOURCES=$(SOURCES) $(O)\_keyfile.cs

# As we no longer know explicitly what the keyfile is in macro form, hence cannot form a dependency on it,
# re-generate the _keyfile.cs each time, to be sure

$(O)\_keyfile.cs: $(SOURCES_USED)
    @echo BUILDMSG2: making $(@F)
    @REM <<$(@)
!if ! (  ( ("$(MANAGED_DELAYSIGN_KEYFILE)" == "$(NTMAKEENV)\publickey.snk") || defined(SN_SIGN_TARGET) ) && defined(ASSEMBLY_IDENTITY)  )
[assembly:System.Reflection.AssemblyKeyFile("$(MANAGED_DELAYSIGN_KEYFILE:\=\\)")]
[assembly:System.Reflection.AssemblyDelaySign(true)]
!endif
<<KEEP
!if ( ("$(MANAGED_DELAYSIGN_KEYFILE)" == "$(NTMAKEENV)\publickey.snk") || defined(SN_SIGN_TARGET) ) && defined(ASSEMBLY_IDENTITY)
    $(ASMID_TO_ATTRIBS_CMD) $(ASSEMBLY_IDENTITY) $(@) csharp SN_SIGN_TARGET=$(SN_SIGN_TARGET)
!endif

!elseif defined(MANAGED_CXX)

OBJECTS=$(OBJECTS) $(O)\_keyfile.obj

# As we no longer know explicitly what the keyfile is in macro form, hence cannot form a dependency on it,
# re-generate the _keyfile.cs each time, to be sure

$(O)\_keyfile.cpp: $(SOURCES_USED)
    @echo BUILDMSG2: making $(@F)
    @REM <<$(@)
!if "$(PRECOMPILED_INCLUDE)" != "" && "$(PRECOMPILED_CXX)" != "" && "$(NTNOPCH)" != "1"
#include "$(PRECOMPILED_INCLUDE:\=\\)"
!endif
#using <mscorlib.dll>
!if ! (  ( ("$(MANAGED_DELAYSIGN_KEYFILE)" == "$(NTMAKEENV)\publickey.snk") || defined(SN_SIGN_TARGET) ) && defined(ASSEMBLY_IDENTITY)  )
[assembly:System::Reflection::AssemblyKeyFile("$(MANAGED_DELAYSIGN_KEYFILE:\=\\)")];
[assembly:System::Reflection::AssemblyDelaySign(true)];
!endif
<<KEEP
!if ( ("$(MANAGED_DELAYSIGN_KEYFILE)" == "$(NTMAKEENV)\publickey.snk") || defined(SN_SIGN_TARGET) ) && defined(ASSEMBLY_IDENTITY)
    $(ASMID_TO_ATTRIBS_CMD) $(ASSEMBLY_IDENTITY) $(@) c SN_SIGN_TARGET=$(SN_SIGN_TARGET)
!endif

!elseif defined(MANAGED_VB)

!message $(BUILD_ERROR_MSG) MANAGED_DELAYSIGN_KEYFILE not implemented for Visual Basic

!else

!message $(BUILD_ERROR_MSG) MANAGED_DELAYSIGN_KEYFILE unknown language

!endif # MANAGED_CODE, MANAGED_CXX, MANAGED_VB

!endif # != 1 (prevent error when BUILD_PRODUCT != NT)

!endif # Managed Key File

#
# Output strongname signing file with data for strongname signing
#

!ifdef NO_BINPLACE
SN_SIGN_BINPLACE_CMD=
!else
SN_SIGN_BINPLACE_CMD=$(BINPLACE_TOOL) -:DEST $(SN_SIGN_DIR) -R $(_NTTREE) $@
!endif #  NO_BINPLACE

!if defined( SN_SIGN )

!if defined(PROJECT_BUILDS_MANAGED_CODE)

# Output contents of SN_SIGN macro to a file within the $(O) directory
$(SN_SIGN_SPEC) : $(SOURCES_USED)
    @echo BUILDMSG2: making $(@F) with strongname signing data
    @REM <<$(@)
$(SN_SIGN)
<<KEEP
    $(SN_SIGN_BINPLACE_CMD)

!else
!message $(BUILD_ERROR_MSG) SN_SIGN macro can only be used for a project building managed code
!message $(BUILD_ERROR_MSG) using MANAGED_CODE=1 or MANAGED_CXX=1 or MANAGED_VB=1
!endif

!endif

!if defined( SN_SIGN_TARGET )

!if defined(PROJECT_BUILDS_MANAGED_CODE)

# Output the whole ASSEMBLY_IDENTITY macro, if available, for figuring out on the back end
# If the ASSEMBLY_IDENTITY macro is not available, error
!if ! defined( ASSEMBLY_IDENTITY )
!message $(BUILD_ERROR_MSG) SN_SIGN_TARGET can only be used when using the ASSEMBLY_IDENTITY macro.
! else

$(SN_SIGN_SPEC) : $(SOURCES_USED)
    @echo BUILDMSG2: making $(@F) with strongname signing data for target
    @echo ^<strongnamesign sourcebin="$(MAKEDIR)\$(_OBJ_DIR)\$(TARGET_DIRECTORY)\$(TARGETNAME).$(TARGETEXT)" assemblyIdentity="$(ASSEMBLY_IDENTITY)" /^>  > $@
    $(SN_SIGN_BINPLACE_CMD)

!endif  # else of: if ! defined(ASSEMBLY_IDENTITY)

!else
!message $(BUILD_ERROR_MSG) SN_SIGN_TARGET macro can only be used for a project building managed code
!message $(BUILD_ERROR_MSG) using MANAGED_CODE=1 or MANAGED_CXX=1 or MANAGED_VB=1
!endif

!endif



#
# Include Win32 resource file
#

!ifdef MANAGED_WIN32_RESOURCE_FILE

$(O)\$(MANAGED_WIN32_RESOURCE_FILE:.rc=.res): $(MANAGED_WIN32_RESOURCE_FILE)
    set _oldinclude=$(include)
    set include=$(INCPATHRC)
    $(RC_COMPILER) -r -fo $(@R).tmp $(CDEFINERC) $(MANAGED_WIN32_RESOURCE_FILE)
    set include=$(_oldinclude)
    set _oldinclude=
    cvtres -machine:$(TARGET_DIRECTORY:i386=ix86) -readonly -out:$@ $(@R).tmp
    erase $(@R).tmp

$(O)\_win32resources.foo: $(O)\$(MANAGED_WIN32_RESOURCE_FILE:.rc=.res)
    echo // This is a trick to get the win32 resources file to build. > $@

SOURCES=$(SOURCES) $(O)\_win32resources.foo

USER_CS_FLAGS=$(USER_CS_FLAGS) /win32res:$(O)\$(MANAGED_WIN32_RESOURCE_FILE:.rc=.res)

!endif # Win32 resource file


!IF "$(PRECOMPILED_INCLUDE)" != ""
! ifdef PRECOMPILED_SOURCEFILE
!  ifdef PRECOMPILED_INCLUDE_BASENAME
$(PRECOMPILED_TARGET) $(HEADEROBJNAME): $(PRECOMPILED_INCLUDE) $(PRECOMPILED_SOURCEFILE)
!  else
PRECOMPILED_INCLUDE_BASENAME=$(?F)
$(PRECOMPILED_TARGET) $(HEADEROBJNAME): $(PRECOMPILED_INCLUDE)
!  endif
    @type <<
$(ECHO_PRECOMPILED_MSG1)
<<$(BUILD_NOKEEP)
    @$(C_COMPILER_NAME) @<< $(PRECOMPILED_FLAG) $(PRECOMPILED_SOURCEFILE)
$(EX_C_COMPILER_FLAGS)
/Yl$(TARGETNAME) /Yc$(PRECOMPILED_INCLUDE_BASENAME) $(HEADERFILE) $(HEADEROBJ)
<<$(BUILD_NOKEEP)
! else
!  ifndef PRECOMPILED_INCLUDE_BASENAME
PRECOMPILED_INCLUDE_BASENAME=$(?F)
!  endif
$(PRECOMPILED_TARGET) $(HEADEROBJNAME): $(PRECOMPILED_INCLUDE)
    @type <<
$(ECHO_PRECOMPILED_MSG2)

#include "$(PRECOMPILED_INCLUDE_BASENAME)"

<<$(BUILD_NOKEEP)
    @$(C_COMPILER_NAME) @<< $(PRECOMPILED_FLAG)<<$(O)\pch_hdr.src
$(EX_C_COMPILER_FLAGS)
/Yl$(TARGETNAME) /Yc$(PRECOMPILED_INCLUDE_BASENAME) $(HEADERFILE) $(HEADEROBJ)
<<$(BUILD_NOKEEP)
#include "$(PRECOMPILED_INCLUDE_BASENAME)"
<<KEEP
! endif
!ENDIF

!if !defined(NOLINK) && "$(UMAPPL)" != ""

#
# Standard inference rule for User Mode object files that produce User Mode
# image files
#

$(UMEXEFILES): $(UMOBJS) $(BO_LIB) $(UMLIBS) $(CRTLIBS) $(MACHINE_TARGETLIBS) $(LINKLIBS)
    $(LINKER) @<<
$(LINKER_FLAGS: =
)
$(LINKER_STACKSIZE)
$(TSLINKER_FLAG)
$(ORDER: =
)
$(LINKGPSIZE: =
)
$(HEADEROBJNAME: =
)
$(LINKER_OPTIDATA)
-subsystem:$(SUBSYSTEM)
-base:$(UMBASE)
$(UMENTRY)
$(UMRES: =
)
$(*R).obj
$(**: =
)
<<$(BUILD_NOKEEP)
    $(POST_BUILD_CMD)
    $(SCP_CMD)
    $(SIGNCODE_CMD)
    $(MAKE_PLACEFILE_CMD)
    $(BINPLACE_CMD)
    $(BINPLACE_TO_COMPONENT_STORE_CMD)
!endif

!if "$(BROWSERFILE)" != ""

! ifndef BSCMAKE_FLAGS
BSCMAKE_FLAGS = -nologo
! endif

$(BROWSERFILE) : \
! if "$(OBJECTS)" != "" || "$(OTHER_SBR_FILES)" != ""
                $(O)\*.sbr $(OTHER_SBR_FILES)
    -bscmake $(BSCMAKE_FLAGS) -o "$(BROWSERFILE)" @<<$(O)\bscmake.rsp
$(**: =
)
<<$(BUILD_NOKEEP)
! endif
!endif

#
# These dependencies produce the target binaries from the object files.
# These will trigger the sources to object inference rules to generate the
# object files.
#

!IF "$(TARGET)" != ""
! IF "$(TARGETTYPE)"=="PROGLIB"
$(TARGET:.exe=.lib) $(TARGET:.exe=.exp): \
!  if "$(BUILD_PASS)" != "PASS2"
                                         $(IMPLIB_DEPEND) \
!  endif
                                         $(DLLDEF)
    -$(LIB_NAME) -out:$(@R).lib @<<
$(LIBRARIAN_FLAGS: =
)
-def:$(DLLDEF)
$(LIBRARY_OBJS: =
)
<<$(BUILD_NOKEEP)
    $(LINT_CMD2)

$(TARGET): $(OBJECTS) $(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).exp $(UMRES) $(BO_LIB) $(UMLIBS) $(CRTLIBS) $(MACHINE_TARGETLIBS) $(LINKLIBS)
    $(LINKER) @<<
$(LINKER_FLAGS: =
)
$(LINKER_STACKSIZE)
$(TSLINKER_FLAG)
$(ORDER: =
)
$(LINKGPSIZE: =
)
$(HEADEROBJNAME: =
)
$(LINKER_OPTIDATA)
-subsystem:$(SUBSYSTEM)
-base:$(UMBASE)
$(UMENTRY: =
)
$(**: =
)
<<$(BUILD_NOKEEP)
    $(POST_BUILD_CMD)
    $(SCP_CMD)
    $(SIGNCODE_CMD)
    $(MAKE_PLACEFILE_CMD)
    $(BINPLACE_CMD)
    $(BINPLACE_TO_COMPONENT_STORE_CMD)

! ELSEIF "$(TARGETTYPE)"=="PROGRAM"

!    if (!defined(MANAGED_CODE) && !defined(MANAGED_VB))
$(TARGET): $(UMRES) $(OBJECTS) $(BO_LIB) $(CRTLIBS) $(UMLIBS) $(MACHINE_TARGETLIBS) $(LINKLIBS)
    $(LINKER) @<<
$(LINKER_FLAGS: =
)
$(LINKER_STACKSIZE)
$(TSLINKER_FLAG)
-subsystem:$(SUBSYSTEM)
-base:$(UMBASE)
$(ORDER: =
)
$(LINKGPSIZE: =
)
$(UMENTRY: =
)
$(LINKER_OPTIDATA)
$(HEADEROBJNAME: =
)
$(**: =
)
<<$(BUILD_NOKEEP)
    $(POST_BUILD_CMD)
    $(SCP_CMD)
    $(SIGNCODE_CMD)
    $(MAKE_PLACEFILE_CMD)
    $(BINPLACE_CMD)
    $(BINPLACE_TO_COMPONENT_STORE_CMD)
    $(LANGUAGE_NEUTRAL_STATUS_CMD)
    $(LINT_CMD2)

!  ELSE  # MANAGED_CODE or MANAGED_VB is set

$(TARGET) : $(SOURCES)
    @type <<
$(MANAGED_CODE_BUILD_CMD)
<<$(BUILD_NOKEEP)
    @$(MANAGED_CODE_BUILD_TOOL) @<<
$(MANAGED_CODE_BUILD_SWITCHES)
$(SOURCES)
<<$(BUILD_NOKEEP)
    $(POST_MANAGED_BUILD_CMD)
    $(MAKE_PLACEFILE_CMD)
    $(BINPLACE_CMD)
    $(BINPLACE_TO_COMPONENT_STORE_CMD)
    $(LANGUAGE_NEUTRAL_STATUS_CMD)

!  ENDIF # MANAGED_CODE || MANAGED_VB

! ELSEIF "$(TARGETTYPE)"=="DYNLINK"

!  ifdef NO_DLL_EXPORTS
DYNLINK_EXP=
!  elseif (!defined(MANAGED_CODE) && !defined(MANAGED_VB))
$(DYNLINK_LIB) $(DYNLINK_EXP) : \
!   if "$(BUILD_PASS)" != "PASS2"
                                $(IMPLIB_DEPEND) $(DLLLIBOBJECTS) \
!   endif
                                $(DLLDEF)
    -$(LIB_NAME) -out:$(DYNLINK_LIB) @<<
$(LIBRARIAN_FLAGS: =
)
-def:$(DLLDEF)
$(LIBRARY_OBJS: =
)
<<$(BUILD_NOKEEP)
!   IF "$(DLLLIBOBJECTS)" != " "
    -$(LIB_NAME) -out:$(DYNLINK_LIB) @<<
$(LIBRARIAN_FLAGS: =
)
$(@R).lib
$(DLLLIBOBJECTS)
<<$(BUILD_NOKEEP)
!   ENDIF
    $(LINT_CMD2)
!  endif # NO_DLL_EXPORTS

!  IF "$(MAKEDLL)" != ""

!    if (!defined(MANAGED_CODE) && !defined(MANAGED_VB))

$(TARGET): $(DYNLINK_EXP) $(OBJECTS) $(BO_LIB) $(LINKLIBS) $(CRTLIBS) $(MACHINE_TARGETLIBS)
    $(LINKER) @<<
$(LINKER_FLAGS: =
)
$(LINKER_STACKSIZE_DLL)
-dll
$(ORDER: =
)
$(LINKER_OPTIDATA)
-base:$(DLLBASE)
-subsystem:$(SUBSYSTEM)
$(DLLENTRY: =
)
$(HEADEROBJNAME: =
)
$(**: =
)
<<$(BUILD_NOKEEP)
    $(POST_BUILD_CMD)
    $(SCP_CMD)
    $(SIGNCODE_CMD)
    $(MAKE_PLACEFILE_CMD)
    $(BINPLACE_CMD)
    $(BINPLACE_TO_COMPONENT_STORE_CMD)
    $(LANGUAGE_NEUTRAL_STATUS_CMD)
    $(MAPDUMP_CMD)

!  ELSE  # MANAGED_CODE || MANAGED_VB is set

$(TARGET) : $(SOURCES)
    @type <<
$(MANAGED_CODE_BUILD_CMD)
<<$(BUILD_NOKEEP)
!ifdef MANAGED_CODE_BUILD_SWITCH_CUSTOM
    @$(MANAGED_CODE_BUILD_CMD)
!else
    @$(MANAGED_CODE_BUILD_TOOL) @<<
$(MANAGED_CODE_BUILD_SWITCHES)
$(SOURCES)
!endif
<<$(BUILD_NOKEEP)
!  IF "$(SERVICEPROXY)" != ""
    copy /y $(TARGET) $(REFERENCE_DIR)\tempproxy.dll
    webserviceutil /base:$(SERVICEBASE) /command:makeSDL /assembly:$(REFERENCE_DIR)\tempproxy.dll /out:$(PROXYPATH)
    del $(REFERENCE_DIR)\tempproxy.dll
!  ENDIF
    $(POST_MANAGED_BUILD_CMD)
    $(MAKE_PLACEFILE_CMD)
    $(BINPLACE_CMD)
    $(BINPLACE_TO_COMPONENT_STORE_CMD)
    $(LANGUAGE_NEUTRAL_STATUS_CMD)

!  ENDIF # MANAGED_CODE || MANAGED_VB

!  ENDIF # "$(MAKEDLL)" != ""

! ELSEIF "$(TARGETTYPE)"=="LIBRARY"

$(TARGET): $(OBJECTS) $(OBJLIBFILES)
    @-erase $@ >nul 2>nul
    -$(LIBRARIAN) @<<
$(HEADEROBJNAME: =
)
$(OBJECTS: =
)
$(OBJLIBFILES: =
)
<<$(BUILD_NOKEEP)

    $(LINT_CMD2)
! ELSEIF "$(TARGETTYPE)"=="DRIVER" || \
    "$(TARGETTYPE)"=="MINIPORT"

$(TARGET): $(OBJECTS) $(BO_LIB) $(MACHINE_TARGETLIBS) $(CRTLIBS)
    $(LINKER) @<<
$(LINKER_FLAGS: =
)
$(LINKER_STACKSIZE_DLL)
$(ORDER: =
)
$(SECTION_INFO1)
$(SECTION_INFO2)
$(LINKER_OPTIDATA)
$(DRIVER_SWITCH)
-base:$(DRIVERBASE)
!  IF "$(DRIVERTYPE)" == "VXD"
-def:$(DLLDEF)
!  ELSE
$(DRIVER_ALIGN_SWITCH)
-subsystem:native$(SUBSYSTEM_NATVER)
-entry:$(DRIVER_ENTRY)$(ENTRY_SUFFIX)
!  ENDIF
-out:$(TARGET)
$(HEADEROBJNAME: =
)
$(**: =
)
<<$(BUILD_NOKEEP)
    $(POST_BUILD_CMD)
    $(SCP_CMD)
    $(SIGNCODE_CMD)
    $(COMPRESS_CMD)
    $(MAKE_PLACEFILE_CMD)
    $(BINPLACE_CMD)
    $(BINPLACE_TO_COMPONENT_STORE_CMD)
    $(LANGUAGE_NEUTRAL_STATUS_CMD)
    $(MAPDUMP_CMD)
    $(LINT_CMD2)

! ELSEIF "$(TARGETTYPE)"=="GDI_DRIVER"

$(TARGET): $(OBJECTS) $(BO_LIB) $(MACHINE_TARGETLIBS) $(CRTLIBS) $(GDI_DRIVER_LIBS)
    $(LINKER) @<<
$(LINKER_FLAGS: =
)
$(LINKER_STACKSIZE_DLL)
-dll
$(ORDER: =
)
$(SECTION_INFO1)
$(SECTION_INFO2)
$(LINKER_OPTIDATA)
$(DRIVER_SWITCH)
$(DRIVER_ALIGN_SWITCH)
-subsystem:native$(SUBSYSTEM_NATVER)
-base:$(DRIVERBASE)
-entry:$(GDI_DRIVER_ENTRY)$(GDI_ENTRY_SUFFIX)
-out:$(TARGET)
$(HEADEROBJNAME: =
)
$(**: =
)
<<$(BUILD_NOKEEP)
    $(POST_BUILD_CMD)
    $(SCP_CMD)
    $(SIGNCODE_CMD)
    $(COMPRESS_CMD)
    $(MAKE_PLACEFILE_CMD)
    $(BINPLACE_CMD)
    $(BINPLACE_TO_COMPONENT_STORE_CMD)
    $(LANGUAGE_NEUTRAL_STATUS_CMD)
    $(MAPDUMP_CMD)
    $(LINT_CMD2)

! ELSEIF "$(TARGETTYPE)"=="EXPORT_DRIVER"

$(DYNLINK_EXP) $(DYNLINK_LIB) : \
!  if "$(BUILD_PASS)" != "PASS2"
                                $(BO_LIB) $(LINKLIBS) $(DLLLIBOBJECTS) \
!  endif
                                $(DLLDEF) $(OBJECTS)
    -$(LIB_NAME) -out:$(DYNLINK_LIB) @<<
$(LIBRARIAN_FLAGS: =
)
-def:$(DLLDEF)
$(OBJECTS)
$(LINKLIBS)
<<$(BUILD_NOKEEP)
!  if "$(DLLLIBOBJECTS)" != " "
    -$(LIB_NAME) -out:$(DYNLINK_LIB) @<<
$(LIBRARIAN_FLAGS: =
)
$(DYNLINK_LIB)
$(DLLLIBOBJECTS)
<<$(BUILD_NOKEEP)
!  endif
    $(LINT_CMD2)

!  IF "$(MAKEDLL)" != ""
$(TARGET): $(DYNLINK_EXP) $(OBJECTS) $(BO_LIB) $(CRTLIBS) $(MACHINE_TARGETLIBS) $(LINKLIBS)
    $(LINKER) @<<
$(LINKER_FLAGS: =
)
$(ORDER: =
)
$(LINKER_STACKSIZE_DLL)
$(LINKER_OPTIDATA)
$(DRIVER_SWITCH)
$(DRIVER_ALIGN_SWITCH)
-subsystem:native$(SUBSYSTEM_NATVER)
-base:$(DRIVERBASE)
-entry:$(DRIVER_ENTRY)$(ENTRY_SUFFIX)
-out:$(TARGET)
$(HEADEROBJNAME: =
)
$(**: =
)
<<$(BUILD_NOKEEP)
    $(POST_BUILD_CMD)
    $(SCP_CMD)
    $(SIGNCODE_CMD)
    $(COMPRESS_CMD)
    $(MAKE_PLACEFILE_CMD)
    $(BINPLACE_CMD)
    $(BINPLACE_TO_COMPONENT_STORE_CMD)
    $(LANGUAGE_NEUTRAL_STATUS_CMD)
!  ENDIF

! ELSEIF "$(TARGETTYPE)"=="HAL"

!  IF "$(MAKEDLL)" == ""
$(TARGET) $(TARGET:.lib=.exp): $(DLLDEF) $(O)\*.obj $(LINKLIBS)
    -$(LIB_NAME) -out:$(@R).lib @<<
$(LIBRARIAN_FLAGS: =
)
-def:$(DLLDEF)
$(O)\*.obj
$(LINKLIBS)
<<$(BUILD_NOKEEP)
!  ELSE
$(TARGET:.dll=.lib) $(TARGET:.dll=.exp): $(DLLDEF) $(O)\*.obj $(LINKLIBS)
    -$(LIB_NAME) -out:$(@R).lib @<<
$(LIBRARIAN_FLAGS: =
)
-def:$(DLLDEF)
$(O)\*.obj
$(LINKLIBS)
<<$(BUILD_NOKEEP)

$(TARGET): $(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).exp $(OBJECTS) $(CRTLIBS) $(MACHINE_TARGETLIBS) $(LINKLIBS)
    $(LINKER) @<<
$(LINKER_FLAGS: =
)
$(LINKER_STACKSIZE_DLL)
$(LINKER_OPTIDATA)
$(DRIVER_SWITCH)
$(HAL_ALIGN_SWITCH)
-subsystem:$(SUBSYSTEM)
-base:$(HALBASE)
-dll
-entry:HalInitSystem$(ENTRY_SUFFIX)
-out:$(TARGET)
$(**: =
)
<<$(BUILD_NOKEEP)
    $(POST_BUILD_CMD)
    $(SCP_CMD)
    $(SIGNCODE_CMD)
    $(MAKE_PLACEFILE_CMD)
    $(BINPLACE_CMD)
    $(BINPLACE_TO_COMPONENT_STORE_CMD)
    $(LANGUAGE_NEUTRAL_STATUS_CMD)
    $(MAPDUMP_CMD)
    $(LINT_CMD2)
!  ENDIF
! ENDIF
!ENDIF

! if defined(DO_LANGUAGE_NEUTRAL) && !defined(NOLINK) && "$(MYMUILINK)" != ""
$(TARGET).mui: $(MYMUILINK)
   if exist $(TARGET).muilnk @del $(TARGET).muilnk
   for %k in ($**) do  if exist %~dpnk.muires ( if exist $(TARGET).muilnk (@echo %~dpnk.muires>>$(TARGET).muilnk) else (@echo %~dpnk.muires>>$(TARGET).muilnk))
   if exist $(TARGET).muilnk echo Build_Status Generating : Creating MUI file: LN_MUI_STS: LGNSTS_MUIED $(@F)
   if not exist $(TARGET).muilnk @echo notloc>$(TARGET).mui.notloc
   if not exist $(TARGET).muilnk echo Build_Status  LN_MUI_STS: LGNSTS_NOLOCRESOURCE $(@B)
   if exist $(TARGET).muilnk ($(LINKER) /noentry /dll /nologo /nodefaultlib /machine:$(TARGET_DIRECTORY:i386=ix86)  /out:$@ @$(TARGET).muilnk &  @del $(TARGET).muilnk)
!  if defined(SIGNCODE_CMD)
   if exist $@ $(SIGNCODE_CMD)
!  endif
!  if !defined(NO_BINPLACE)
      if exist $@ @echo $(@F) $(LANGUAGE_NEUTRAL_RESDIR) >$(TARGET).binplace
      if exist $@  $(BINPLACE_TOOL) -P  $(TARGET).binplace -R $(_NTTREE) $(TARGET).mui
      if exist $(TARGET).binplace del $(TARGET).binplace
!  endif
!ENDIF





!IFNDEF NOLINK

! IF "$(NTTEST)" != ""

$(O)\$(NTTEST).exe: $(NTRES) $(O)\$(NTTEST).obj  \
                        $(BO_LIB) $(KERNEL_LIBS) \
                        $(LINKLIBS)
    $(LINKER) @<<
$(LINKER_FLAGS: =
)
$(LINKER_STACKSIZE)
$(ORDER: =
)
$(LINKGPSIZE: =
)
$(NTTEST_LINK_OPTIONS: =
)
$(LINKER_OPTIDATA)
$(DRIVER_SWITCH)
$(KERNEL_ALIGN_SWITCH)
-subsystem:$(SUBSYSTEM)
$(**: =
)
<<$(BUILD_NOKEEP)
    $(POST_BUILD_CMD)
    $(SCP_CMD)
    $(SIGNCODE_CMD)
    $(MAKE_PLACEFILE_CMD)
    $(BINPLACE_CMD)
    $(BINPLACE_TO_COMPONENT_STORE_CMD)
    $(MAPDUMP_CMD)
    $(LINT_CMD2)
! ENDIF
!ENDIF

!if !defined(XML_STRING_REPLACEMENT_SOURCE_EXTENSION)
XML_STRING_REPLACEMENT_SOURCE_EXTENSION=source_manifest
!endif

!if !defined(XML_STRING_REPLACEMENT_TARGET_EXTENSION)
XML_STRING_REPLACEMENT_TARGET_EXTENSION=manifest
!endif

REPLACE_IN_XML_INPUT=$<
REPLACE_IN_XML_OUTPUT=$@

REPLACE_STRINGS_IN_XML_CMD1=\
    @if exist $(REPLACE_IN_XML_INPUT) echo BUILDMSG2: Replacing in Xml (replace_in_xml.js)

REPLACE_STRINGS_IN_XML_CMD2=\
    if exist $(REPLACE_IN_XML_INPUT) \
    cscript /E:jscript /nologo $(RAZZLETOOLPATH)\replace_in_xml.js \
        /out:$(REPLACE_IN_XML_OUTPUT) \
        /in:$(REPLACE_IN_XML_INPUT) \
        /replacements:$(MANIFEST_STRING_REPLACEMENTS: =,) || \
    @echo $(BUILD_ERROR_MSG) replace_in_xml.js error

!if "$(ALLOW_DOLLAR_LPAREN_BUILD_DOT_IN_OUTPUT_XML)" != "1"
REPLACE_STRINGS_IN_XML_CMD3=\
    if exist $(REPLACE_IN_XML_INPUT) \
    findstr $$(Build. $(REPLACE_IN_XML_OUTPUT) && ( \
        @echo $(BUILD_ERROR_MSG) unreplaced $$(Build. in $(REPLACE_IN_XML_OUTPUT) & \
        findstr $$(Build. $(REPLACE_IN_XML_OUTPUT) | perl -pi -e "s/^(.)/$(BUILD_ERROR_MSG_MULTIPLE_LINES) \1/g")
!endif

REPLACE_STRINGS_IN_XML_CMD4=\
    if not exist $(REPLACE_IN_XML_INPUT) echo $(BUILD_ERROR_MSG) skipping replace_in_xml.js due to earlier errors

replace_in_xml:
    $(REPLACE_STRINGS_IN_XML_CMD1)
    $(REPLACE_STRINGS_IN_XML_CMD2)
    -$(REPLACE_STRINGS_IN_XML_CMD3)
    $(REPLACE_STRINGS_IN_XML_CMD4)

.SUFFIXES: .$(XML_STRING_REPLACEMENT_SOURCE_EXTENSION) .$(XML_STRING_REPLACEMENT_TARGET_EXTENSION)

{}.$(XML_STRING_REPLACEMENT_SOURCE_EXTENSION){$(O)}.$(XML_STRING_REPLACEMENT_TARGET_EXTENSION):
    $(REPLACE_STRINGS_IN_XML_CMD1)
    $(REPLACE_STRINGS_IN_XML_CMD2)
    -$(REPLACE_STRINGS_IN_XML_CMD3)
    $(REPLACE_STRINGS_IN_XML_CMD4)

{..}.$(XML_STRING_REPLACEMENT_SOURCE_EXTENSION){$(O)}.$(XML_STRING_REPLACEMENT_TARGET_EXTENSION):
    $(REPLACE_STRINGS_IN_XML_CMD1)
    $(REPLACE_STRINGS_IN_XML_CMD2)
    -$(REPLACE_STRINGS_IN_XML_CMD3)
    $(REPLACE_STRINGS_IN_XML_CMD4)

{$(O)}.$(XML_STRING_REPLACEMENT_SOURCE_EXTENSION){$(O)}.$(XML_STRING_REPLACEMENT_TARGET_EXTENSION):
    $(REPLACE_STRINGS_IN_XML_CMD1)
    $(REPLACE_STRINGS_IN_XML_CMD2)
    -$(REPLACE_STRINGS_IN_XML_CMD3)
    $(REPLACE_STRINGS_IN_XML_CMD4)

{$(TARGET_DIRECTORY)}.$(XML_STRING_REPLACEMENT_SOURCE_EXTENSION){$(O)}.$(XML_STRING_REPLACEMENT_TARGET_EXTENSION):
    $(REPLACE_STRINGS_IN_XML_CMD1)
    $(REPLACE_STRINGS_IN_XML_CMD2)
    -$(REPLACE_STRINGS_IN_XML_CMD3)
    $(REPLACE_STRINGS_IN_XML_CMD4)

!if "$(OUTPUT_MANIFEST)" != "" # {

!if ("$(TARGETTYPE)" == "NOTARGET" || \
        ("$(MAKEDLL)" != "" && "$(NOLINK)" != "1") || \
        "$(BUILD_PASS)" == "PASS2" || \
        "$(BUILD_PASS)" == "PASSALL") # {

$(OUTPUT_MANIFEST): $(O)\_asmid.xml $(MANIFESTS) $(MANIFEST_STRING_REPLACEMENTS) $(GENMAN_INPUT)
    @REM
    @REM Generate manifest from managed metadata.
    @REM
!if "$(RUN_GENMAN)" == "1"
    @if exist $(GENMAN_INPUT) echo BUILDMSG2: Generating manifest pieces (genman.js)
    if exist $(GENMAN_INPUT) cscript /E:jscript /nologo $(RAZZLETOOLPATH)\genman.js \
        $(GENMAN_INPUT) \
        /nologo \
        $(SLASH_DEPENDENT_ASSEMBLIES) \
!  if "$(ASSEMBLY_IN_MINWIN)" == "" || "$(ASSEMBLY_IN_MINWIN)" == "1"
        /OneUnstableGuidWarningPerType \
!  else
        /OneUnstableGuidWarningPerAssembly \
!  endif
        /out:$(OUTPUT_MANIFEST)_temp1 || \
    @echo $(BUILD_ERROR_MSG) genman error
    @if not exist $(GENMAN_INPUT) echo $(BUILD_ERROR_MSG) skipping genman.js due to earlier errors
!endif

!if "$(MANIFESTS)" != "" && defined(CMI_COMPILE_MANIFESTS)

    @REM
    @REM Merge the generated manifest with misc files
    @REM
    cscript /E:jscript /nologo $(RAZZLETOOLPATH)\manmerge.js \
        /out:$(OUTPUT_MANIFEST)_temp2 \
        /replacements:$(MANIFEST_STRING_REPLACEMENTS: =,) \
        $(MANIFEST_TEMP1) \
        $(O_MISCFILES_XML) || \
    @echo $(BUILD_ERROR_MSG) manmerge.js error


    @REM
    @REM Do CMI manifest compilation on each hand written manifest snippet,
    @REM which for example describe services, and accumulate the cmi output
    @REM with the overall output
    @REM

    for %m in ($(MANIFESTS)) do ( \
        nmake -nologo -f $(NTMAKEENV)\makefile.def cmi_compile_manifests CMI_COMPILE_MANIFESTS=1 CMI_COMPILE_MANIFESTS_INPUT=%m CMI_COMPILE_MANIFESTS_OUTPUT=$(O)\_temp_cmi_%~nxm && \
        cscript /E:jscript /nologo $(RAZZLETOOLPATH)\manmerge.js \
            /out:$(OUTPUT_MANIFEST)_temp2 \
            /replacements:$(MANIFEST_STRING_REPLACEMENTS: =,) \
            $(OUTPUT_MANIFEST)_temp2 \
            $(O)\_temp_cmi_%~nxm || \
        @echo $(BUILD_ERROR_MSG) manmerge.js error \
    )

!else

    @REM
    @REM Merge the generated manifest and the hand written manifest snippets, which for example describe services.
    @REM
    @REM $(MANIFEST_TEMP1) must be first as it is the generated manifest that manmerge.js does a reasonable
    @REM of merging into.
    @REM
    cscript /E:jscript /nologo $(RAZZLETOOLPATH)\manmerge.js \
        /out:$(OUTPUT_MANIFEST)_temp2 \
        /replacements:$(MANIFEST_STRING_REPLACEMENTS: =,) \
        $(MANIFEST_TEMP1) \
!if defined(INSTRUMENTATION_MANIFEST)
        $(O)\_asmid.xml \
!endif
!if defined(ASSEMBLY_MISCFILES)
        $(O)\_miscfiles.xml \
!endif
        $(MANIFESTS) || \
    @echo $(BUILD_ERROR_MSG) manmerge.js error

!endif

    @REM
    @REM Do string replacements.
    @REM
    nmake -nologo -f $(NTMAKEENV)\makefile.def replace_in_xml REPLACE_IN_XML_INPUT=$(OUTPUT_MANIFEST)_temp2 REPLACE_IN_XML_OUTPUT=$@

    @REM
    @REM Binplace the manifest.
    @REM
    @REM %_nttree%\components\keyform\keyform.manifest tends to be too long for cmd/copy/xcopy/dir, so instead:
    @REM   %_nttree%\components\keyform\asssemblyname.manifest
    @REM but still
    @REM   %_nttree%\cmicomponents\keyform.manifest
    @REM
!if "$(DO_BINPLACE_MANIFEST)" == "1" && !defined(NO_BINPLACE)
!  if "$(ASSEMBLY_BINPLACE_DEST)" != ""
    if exist $(OUTPUT_MANIFEST) $(BINPLACE_TOOL) -:DEST $(ASSEMBLY_BINPLACE_DEST) $(BINPLACE_FLAGS) $(BINPLACE_LC_MISCFLAGS) $(OUTPUT_MANIFEST)
!  endif
    if exist $(OUTPUT_MANIFEST2) del $(OUTPUT_MANIFEST2)
    if exist $(OUTPUT_MANIFEST) copy $(OUTPUT_MANIFEST) $(OUTPUT_MANIFEST2)
    if exist $(OUTPUT_MANIFEST2) $(BINPLACE_TOOL) -:DEST cmicomponents $(BINPLACE_FLAGS) $(BINPLACE_LC_MISCFLAGS) $(OUTPUT_MANIFEST2)
    @if not exist $(OUTPUT_MANIFEST) @echo $(BUILD_ERROR_MSG) binplace manifest skipped due to earlier errors
!endif

    @REM
    @REM Run makeimage over just this one component.
    @REM This parses the manifest to see if it is valid and
    @REM generates a hivewin.inf that we can run inftest.exe on.
    @REM
!if "$(DO_MAKEIMAGE)" == "1"
    @echo BUILDMSG2: makeimage.exe
    if exist $@ makeimage.exe \
        -assemblyIdentity $(ASSEMBLY_IDENTITY) \
        -temp $(O) \
        -manifest $@ \
        -nofiles \
        -clrVersion $(BUILD_COMPLUS_VERSION) \
        -BuildMachineTag "$(BUILD_MACHINE_TAG)" \
        -BuildNumber $(VER_PRODUCTVERSION_STR) \
        -nomachineconfig \
        -components_xml $(BASE_LIB_PATH)\minwin.xml \
!if "$(ASSEMBLY_IN_MINWIN)" == "" || "$(ASSEMBLY_IN_MINWIN)" == "1"
        -minwinWarningV1 || \
!else
        -NoMinwinWarning || \
!endif
        @echo $(BUILD_ERROR_MSG) makeimage.exe error
    -for /f %%i in ('dir /b/ad $(O)\makeimage-temp-*') do rd /q/s $(O)\%%i
    @if not exist $@ @echo $(BUILD_ERROR_MSG) makeimage.exe skipped due to earlier errors
!endif

    @REM
    @REM Run inftest.exe over the hivewin.inf that makeimage.exe produced.
    @REM
!if "$(DO_INFTEST)" == "1"
    @echo BUILDMSG2: inftest.exe
    if exist $(O)\hivewin.inf inftest.exe $(O)\hivewin.inf /B /W || \
        @echo $(BUILD_ERROR_MSG) inftest.exe error
    @if not exist $(O)\hivewin.inf @echo $(BUILD_ERROR_MSG) inftest.exe skipped due to earlier errors
!endif

!else # } {

$(OUTPUT_MANIFEST):

!endif # }
!endif # }

!IF DEFINED(USE_LINT) && ("$(LINT_TYPE)" == "all")

$(O)\$(LINT_OUTPUT).$(LINT_EXT): $(TARGETOBJFILES)
    $(LINT_ALL_CMD) $(SOURCES)
!ENDIF

$(O)\*.res : $(MASTER_VERSION_FILE)

!if defined(SXS_MANIFEST_OBJ2)
$(SXS_MANIFEST_OBJ2) : $(SXS_MANIFEST_OBJ1)
    copy $(SXS_MANIFEST_OBJ1) $(SXS_MANIFEST_OBJ2)
!endif

#
# Preprocess .src to .cs.
#
.SUFFIXES: .src .cs

{}.src{$(O)}.cs:
    echo cl /EP $<
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$< | findstr /v pragma > $@
$(CPPXX: =
)
<<$(BUILD_NOKEEP)

#
# disassemble code .dll to metadata source with versions with asmmeta.exe
# remove versions with asmmeta.js /removeversions
# compare/copy to source directory with asmmeta.js /feedback
#

!if defined(O_ASMMETA) && defined(O_ASMMETA_OUTPUT) && defined(SOURCE_ASMMETA) && defined(ASMMETA_INPUT)

$(O_ASMMETA): $(O_ASMMETA_OUTPUT)
    @if exist $** echo BUILDMSG2: Removing versions from metadata disassembly (asmmeta.js /remove...)
    if exist $** $(ASMMETA_JS) /remove_versions:$** /out:$@
    @if exist $** echo BUILDMSG2: Comparing metadata disassembly (asmmeta.js /Feedback...)
    if exist $** $(ASMMETA_JS) /FeedbackAsmmetaBuiltFromDll:$@ /out:$(SOURCE_ASMMETA)
    @if not exist $** @echo $(BUILD_ERROR_MSG) skipping asmmeta.js /remove... and /feedback... due to earlier errors

$(O_ASMMETA_OUTPUT): $(ASMMETA_INPUT)
    @if exist $** echo BUILDMSG2: Disassembling metadata (asmmeta.exe)
    if exist $** urtrun.bat asmmeta.exe "/spaces=2" /1 /output:$@ $** || @echo $(BUILD_ERROR_MSG) asmmeta.exe error
    @if not exist $** @echo $(BUILD_ERROR_MSG) skipping asmmeta.exe due to earlier errors

!endif

#
# Add versions to public metadata managed il-assembly and then assemble.
#

!if defined(O_BINARY_METADATA) && defined(SOURCE_ASMMETA)

#
# Move the code .pdb around because ilasm.exe deletes it when building
# the metadata .dll.
#
$(O_BINARY_METADATA): $(O)\$(TARGETNAME).asmmeta_ver_pass0
    @if exist $(O)\$(TARGETNAME).pdb move $(O)\$(TARGETNAME).pdb $(O)\c00057ce4b4d42a68370d9ccc49ce200.pdb
    ilasm.exe /nologo /quiet /dll /output:$@ $** || @echo $(BUILD_ERROR_MSG) ilasm.exe error
    @if exist $(O)\c00057ce4b4d42a68370d9ccc49ce200.pdb move $(O)\c00057ce4b4d42a68370d9ccc49ce200.pdb $(O)\$(TARGETNAME).pdb

$(O)\$(TARGETNAME).asmmeta_ver_pass0: $(SOURCE_ASMMETA)
    $(ASMMETA_JS) /insert_versions:$** /out:$@

!endif

#
# Make the individual pieces and the keyform of the assembly identity available.
#
$(O)\_asmid.inc: $(SOURCES_USED)
    @echo BUILDMSG2: making $(@F) with idtool.exe
    idtool.exe -id $(ASSEMBLY_IDENTITY) -GenerateMakefileInc > $(@) || @echo $(BUILD_ERROR_MSG) idtool error

#
# Make a file per assembly identity in $(_nttree).
#
!if defined(_NTTREE_IDENTITIES_ASSEMBLY_KEY_FORM_TXT)
$(_NTTREE_IDENTITIES_ASSEMBLY_KEY_FORM_TXT): $(SOURCES_USED)
    @echo BUILDMSG2: making $(@F)
    if not exist $(@D)\ mkdir $(@D)
    if not exist $(@D)\ echo $(BUILD_MSG_ERROR) unable to make $(@D).
    @REM <<$(@)
ASSEMBLY_IDENTITY=$(ASSEMBLY_IDENTITY)
POLICY_MAX=$(POLICY_MAX)
POLICY_MIN=$(POLICY_MIN)
<<KEEP
!endif

$(O)\_asmid.xml: $(SOURCES_USED)
    @echo BUILDMSG2: making $(@F)
!if !defined(ASSEMBLY_IDENTITY_NAME) || !defined(ASSEMBLY_IDENTITY_VERSION)
    echo $(BUILD_ERROR_MSG) makefile.def unable to make _asmid.xml
!endif
    @REM <<$(@)
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
<assemblyIdentity
    name="$(ASSEMBLY_IDENTITY_NAME)"
    version="$(ASSEMBLY_IDENTITY_VERSION)"
!if "$(ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN)" != ""
    publicKeyToken="$(ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN)"
!endif
!if "$(ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE)" != ""
    processorArchitecture="$(ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE)"
!endif
/>
</assembly>
<<KEEP

#
# Generate a manifest for manmerge to merge into the one that genman generates.
#
$(O)\_miscfiles.xml: $(SOURCES_USED)
    @echo BUILDMSG2: making $(@F)
    (echo ^<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0"^> & \
    (for %i in ($(ASSEMBLY_MISCFILES)) do echo ^<file name="%~nxi"/^>) & \
    echo ^</assembly^> \
        )> $(@)

#
# TargetName and TargetExtension might be nice, but instead we deliberately
# stay closer to the long standing build.exe/makefile.def identifiers.
#
# Note that TARGETEXT is .lib in some passes for PROGLIB and DYNLINK, but we
# provide .exe and .dll always for those.
#
$(O)\_generated_string_replacements.xml: $(SOURCES_USED)
    @echo BUILDMSG2: making $(@F)
    @if exist $(@) del $(@)
    @REM <<$(@)
<replacements>
<replacement from="$$(Build.TARGETNAME)" to="$(TARGETNAME)"/>
<replacement from="$$(Build.TARGETEXT)" to="$(LINK_TARGETEXT)"/>
<replacement from="$$(Build.AssemblyIdentity)" to="$(ASSEMBLY_IDENTITY:"=)"/>
<replacement from="$$(build.version)" to="$(ASSEMBLY_IDENTITY_VERSION)"/>
<replacement from="$$(build.WindowsPublicKeyToken)" to="$(WINDOWS_PUBLIC_KEY_TOKEN)"/>
<replacement from="$$(build.processorArchitecture)" to="$(_BUILDARCH)"/>
<replacement from="$$(build.buildType)" to="$(FUSION_MANIFEST_BUILD_TYPE)"/>
</replacements>
<<KEEP

#
# [GorN] 3/30/2000
#
#    WPP. extra rules. Can't have them before the rule to build "all"
#

!if defined(RUN_WPP) && exist(obj\_tracewpp.mac)
WPP_DEFINE_RULES=1
!  include obj\_tracewpp.mac
!endif

!ifdef MANAGED_COVERAGE
!include $(MANAGED_COVERAGE)
!endif

!if [set O=$(O)]
!endif
!if [set _OBJ_DIR=$(_OBJ_DIR)]
!endif

