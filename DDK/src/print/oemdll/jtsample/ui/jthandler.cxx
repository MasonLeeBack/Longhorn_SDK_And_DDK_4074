//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2003  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:   jthandler.cxx
//    
//
//  PURPOSE:  Helper Class that handles all functionality related to processing of input 
//              Job Ticket/Devcaps XML documents.
//
//
//  Functions: Public and Private functions of class JobTicketHandler.          
//
//
//


#include "precomp.h"




//PREFAST
//Disable the warnings generated by PFEFAST for conversion between wchar_t * and BSTR
//because MSXML defines all its interfaces parameters as BSTR but officially declares itself
//to be wchar_t safe.

#pragma prefast(disable:307)


/*++
Routine Name:
    JobTicketHandler
Routine Description: 
    Job Ticket Handler Constructor
    

Arguments:
    None    

Return Value:
    None
    
--*/
ihvjthandler::JobTicketHandler::JobTicketHandler()
{   
    m_pRootDocument = NULL; 
    m_pRootElement = NULL; 
    m_pNSManager = NULL;
}


/*++
Routine Name:
    ~JobTicketHandler(
Routine Description: 
    Job Ticket Handler Destructor

Arguments:
    None
    
Return Value:
    None
    
--*/
ihvjthandler::JobTicketHandler::~JobTicketHandler()
{           
    if(m_pRootDocument)
    {
        m_pRootDocument->Release();
        m_pRootDocument = NULL;
    }
    if(m_pRootElement)
    {
        m_pRootElement->Release();
        m_pRootElement = NULL;
    }
    if(m_pNSManager)
    {
        m_pNSManager->Release();
        m_pNSManager = NULL;
    }   
}

 

/*++
Routine Name:
    GetXML
Routine Description:
    Get the xml content of the DOM document
    

Arguments:
    pbstrXml - OUT pointer to XML string to be filled in by the routine 
                with XML contents of the DOM document
    

Return Value:
    HRESULT Completion status code
    
--*/
HRESULT 
ihvjthandler::JobTicketHandler::GetXML(
    OUT BSTR * pbstrXml
    )
{
    HRESULT hr = S_OK;
    
    if( !pbstrXml )
    {
        return E_INVALIDARG;
    }
    
    hr = m_pRootDocument->get_xml(pbstrXml);
    
    return hr;

}






/*++
Routine Name:
    GetRoot

Routine Description:
    Get the root of XML DOM tree that current job ticket handler instance holds
    

Arguments:
    ppRoot - double pointer to XML DOM document interface 
    

Return Value:
    HRESULT Completion status code
    
--*/
HRESULT 
ihvjthandler::JobTicketHandler::GetRoot(
    OUT IXMLDOMDocument2 **ppRoot
    )
{
    HRESULT hr = S_OK;
    
    if(!ppRoot)
    {
        return E_INVALIDARG;
    }
    
    *ppRoot = m_pRootDocument;
    
    (*ppRoot)->AddRef();
    
    return hr;

}




/*++
Routine Name:
    SetRoot

Routine Description:

    Initialization routine. Sets root of the DOM tree. Alos creates an instance of xml namespace manager
    using plug-in helper interface method.
    
    Note:  This routine MUST BE called before any other xml handling routines are called.
    Note also that it is not necessary to call CoInitializeEx because Unidrv has already
    made that call while creating the DOM tree with appropriate arguments passed on to it
    and when Unidrv makes a call to one of plug-in interface routines, since plug-in is 
    running in the same thread, it does not need to make that call again
    Infact plug-in SHOULD NOT make that call to CoInitializeEx , because Unidrv must have made 
    that call with some particular concurrency model settings which plug-in can not find out,
    so th eplug-in might end up changing the concurrency setting made by Unidrv.

Arguments:
    pRoot - Root of the input DOM tree.
    

Return Value:
    HRESULT Completion status code
    
--*/
HRESULT 
ihvjthandler::JobTicketHandler::SetRoot(
    IN IXMLDOMDocument2 *pRoot,
    IN IPrintJobTicketPluginHelperUI * pCoreDriverJTHelp
    )
{
    HRESULT hr = S_OK;  
    
    
    //check if input paramters are not NULL

    if( !pRoot || !pCoreDriverJTHelp )
    {
        return E_INVALIDARG;
    }

    m_pRootDocument = pRoot;

    m_pRootDocument->AddRef();


        
    //Make Use of Plug-in Helper Interface method provided by Unidrv to create an Instance of MSXML Namespace Manager.
    //The plug-in must make use of Helper Interface provided by Unidrv while creating instance of namespacemanager
    //of MSXML DOM document, the plug-in should not load MSXML6.DLL by itself but should rely on Unidrv for
    //doing that
    
    if(SUCCEEDED(hr))
    {
        //Note: Current versions of Unidrv support MSXML6 hence plug-in should also support that and write its
        // code in cimpliance with MSXML6
        
           hr  = pCoreDriverJTHelp->CreateInstanceOfMSXMLObject(NULL,CLSID_MXNamespaceManager60, NULL,NULL ,IID_IMXNamespaceManager, (void**)&m_pNSManager);        
    }       
    
    //Get the Root Element of the document and store it in pRootElement.

    if(SUCCEEDED(hr))
    {
        hr = m_pRootDocument->get_documentElement(&m_pRootElement);
    }
    if(SUCCEEDED(hr))
    {
        m_pRootElement->AddRef();
    }

        
    
    if(FAILED(hr))
    {
        if(m_pRootDocument)
        {
            m_pRootDocument->Release();
            m_pRootDocument = NULL;
        }

        if(m_pRootElement)
        {
            m_pRootElement->Release();
            m_pRootElement = NULL;
        }

        if(m_pNSManager)
        {
            m_pNSManager->Release();
            m_pNSManager = NULL;
        }
    }
    return hr;
}




/*++
Routine Name:
    CreateXMLElement

Routine Description:
    Generic method to create new XML element node
    

Arguments:

    pParent - pointer to the parent node of the new nod eto be created, if NULL root of DOM tree is considered as parent
    pszElementName - local name of the newly created element
    pszNamespaceURI - namespace URI that the new element belongs to, the caller can only specify the namespace URI
                      and not the prefix
    ppCreatedElement - double pointer to the newly created element returned by the procedure

Return Value:
    HRESULT Completion status code
    S_OK - If the new element node is created successfully
    E_* -  on failure
    
--*/

HRESULT ihvjthandler::JobTicketHandler::CreateXMLElement(
    IN IXMLDOMElement *pParent,
    IN BSTR pszElementName,
    IN BSTR pszNamespaceURI,
    OUT IXMLDOMElement **ppCreatedElement OPTIONAL
    )
{
    HRESULT hr = S_OK;
    IXMLDOMNode * pNewNode = NULL;
    BSTR bstrQName = NULL;

    if( !pParent || !pszElementName || !pszNamespaceURI )
    {
        return E_INVALIDARG;
    }

    

    //create XML Qname
    hr = CreateQName(pParent,pszNamespaceURI,pszElementName,&bstrQName );

    if(SUCCEEDED(hr))
    {   
        VARIANT nodeType;
        VariantInit(&nodeType);
        V_VT(&nodeType) = VT_I4;
        V_I4(&nodeType) = NODE_ELEMENT;
        hr  = m_pRootDocument->createNode(nodeType,bstrQName,pszNamespaceURI,&pNewNode);
        VariantClear(&nodeType);
    }

    if( SUCCEEDED(hr))
        hr  = pParent->appendChild(pNewNode,NULL);
    

    if( SUCCEEDED(hr))
    {
        if( ppCreatedElement)
        {
            // we need to return Interface ptr to IXMLDOMElement
            hr  = pNewNode->QueryInterface(IID_IXMLDOMElement,(void **)ppCreatedElement);
            //if interface is not supported, E_* will be returned in hr, we simply return that to the caller
        }
    }
    

    if( pNewNode)
    {
        //release reference to local node Created since it is no longer being used
        pNewNode->Release();
    }

    return hr;

}



/*++
Routine Name:
    CreateQName

Routine Description:

    Creates XML qname for given local name and namespace URI
    Note: It is asuumed that a prefix for given URI is already defined in root of DOM document
    either by Unidrv or by plug-in itself.
    Routine fails if it doesnot find a predefined prefix for given URI.

Arguments:
    pElement -  context node
    pszUri - Uri
    pszLocalName - local name 
    pQName - a pointer to resultant qname string defined by the routine

Return Value:
    HRESULT Completion status code
    
    S_OK - On success
    E_FAIL - on failure to create Qname

    
--*/
HRESULT ihvjthandler::JobTicketHandler::CreateQName(
    IN IXMLDOMElement * pElement,
    LPTSTR pszUri,
    LPTSTR pszLocalName,
    BSTR * pQName   
    )
{
    HRESULT hr = S_OK;
    BSTR bstrPrefixString = NULL;
    INT cchPrefixLength = 0;

    if(!pszUri || !pszLocalName || !pQName)
    {
        return E_INVALIDARG;
    }

    *pQName = NULL;

    //see if a prefix is already defined for the given URI

    hr = getPrefix(pElement,pszUri,&bstrPrefixString);
    
    // getPrefix returns S_FALSE if prefix is not already defined for given URI in context of given element
    // The prefix should ideally be defined in the root of DOM document, for all public namespace URIs
    // by Unidrv and for plug-in private namespace URI by plug-in in setroot method
    // so if we donot get a defined prefix, treat it as an error

     if( hr == S_FALSE )
    {       
        hr = E_FAIL;
    } 

    if( SUCCEEDED(hr) )
    {
        
        // Is it the default namespace?  If so, don't stick a semicolon in the string
        INT localNameLen = 0;

        //
        // StrSafe function StringCchLength checks if the length of string is less than
        // maximum length specified, and returns S_OK if the input string is non NULL and
        // length is less that maximum length specified.
        // It returns length of string EXCLUDING null terminator
        //
        hr = StringCchLength( pszLocalName , STR_MAX_CCH , (size_t*)&localNameLen );
        
        if( SUCCEEDED(hr) )
        {                                   
            INT prefixLen = 0;

            if( bstrPrefixString )
            {
                hr = StringCchLength( bstrPrefixString, STR_MAX_CCH , (size_t*)&prefixLen );
            }
            

            if( SUCCEEDED(hr) )
            {
                
                if( prefixLen > 0 )
                {
                    // non-default namespace 
                                        
                    LONG cchLength = prefixLen + localNameLen + 2;
                    
                    *pQName = SysAllocStringLen( NULL, cchLength );
                    
                    if(*pQName) 
                    {
                        // we got a terminator character as part of SysAllocString.
                        hr = StringCchPrintf( *pQName, cchLength, L"%s:%s", bstrPrefixString, pszLocalName );
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;      
                    }
                }
                else
                {
                   
                    // Default namepace...                                      
                    
                    LONG cchLength = localNameLen + 1;
                    
                    *pQName = SysAllocStringLen( NULL, cchLength );
                    
                    if( *pQName ) 
                    {
                        // we got a terminator character as part of SysAllocString.
                        hr = StringCchPrintf( *pQName, cchLength, L"%s", pszLocalName);
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
        }
    }
    
    if( bstrPrefixString )
    {
        SysFreeString( bstrPrefixString );
    }

    if( FAILED(hr) )
    {
        if( *pQName ) 
        {
            SysFreeString( *pQName );
            *pQName = NULL;
        }
    }
    
    return hr;
}



/*++
Routine Name:
    CreateXMLAttribute

Routine Description:
    Creates an attribute for the given XML element.
    

Arguments:

    pElement - pointer to the element node to which an attribute is to be added
    pszAttributeName - local name of the attribute
    pszNamespaceURI - namespace URI to which the attribute belongs
    pszAttributeValue - value of the attribute
    ppAttribute - if successful the routine returns pointer to newly created attribute node

Return Value:
    HRESULT Completion status code
    S_OK - on success
    E_* - on failure
    
--*/
//adds attributes to existing XML element
HRESULT ihvjthandler::JobTicketHandler::CreateXMLAttribute(
    IN IXMLDOMElement *pElement,
    IN LPTSTR pszAttributeName, //"name ="
    IN LPTSTR pszNamespaceURI, //"jt:"
    IN LPTSTR pszAttributeValue, //"prn:StapleLocation"
    OUT IXMLDOMAttribute **ppAttribute OPTIONAL
    )
{
    HRESULT hr = S_OK;
    IXMLDOMAttribute *pNewAttribute = NULL ;
    IXMLDOMNode *pNewNode = NULL ;


    if( !pElement || !pszAttributeName || ! pszNamespaceURI || !pszAttributeValue)
    {
        return E_INVALIDARG;
    }

    
    if(ppAttribute)
    {
        *ppAttribute = NULL;
    }
    

    VARIANT nodeType;
    VariantInit(&nodeType);
    V_VT(&nodeType) = VT_I4;
    V_I4(&nodeType) = NODE_ATTRIBUTE;
    hr  = m_pRootDocument->createNode(nodeType,pszAttributeName,pszNamespaceURI,&pNewNode);
    VariantClear(&nodeType);
    
    if( SUCCEEDED(hr))
    {
        hr  = pNewNode->QueryInterface(IID_IXMLDOMAttribute, (void **)&pNewAttribute);
    }

    if( SUCCEEDED(hr))
    {
        VARIANT attrType;
        VariantInit(&attrType);
        V_VT(&attrType) = VT_BSTR;
        V_BSTR(&attrType) = SysAllocString(pszAttributeValue);
        hr  = pNewAttribute->put_value(attrType);
        VariantClear(&attrType);
    }

    if( SUCCEEDED(hr))
    {
        hr  = pElement->setAttributeNode(pNewAttribute,NULL);
    }

    if( SUCCEEDED(hr))
    {
        if(ppAttribute)
        {
            *ppAttribute = pNewAttribute;
        }
        else if( pNewAttribute)
        {
                pNewAttribute->Release();
        }

    }
    else if(pNewAttribute)
        pNewAttribute->Release();

    if(pNewNode)
        pNewNode->Release();
    
    return hr;

} //End function





/*++
Routine Name:
    CreateFeatureNode

Routine Description:

    Creates a new Feature Node

Arguments:
    pParent - parent node of the new feature node, if NULL, root is considered as parent
    pszNamespaceURI - namesapce URI to which new node belongs
    pszFeatureName - local name of the new feature node
    ppFeatureNode - out pointer to newly created node

Return Value:
    HRESULT Completion status code
    S_OK on success
    E_* on failure
    
--*/
HRESULT ihvjthandler::JobTicketHandler::CreateFeatureNode(
    IN IXMLDOMElement *pParent,
    IN LPTSTR pszNamespaceURI,
    IN LPTSTR pszFeatureName,
    OUT IXMLDOMElement **ppFeatureNode OPTIONAL
    )
{
    HRESULT hr = S_OK;
    IXMLDOMElement * pNewElement = NULL;
    BSTR qName = NULL;

    if( !pszFeatureName)
    {
        return E_INVALIDARG;
    }

    if( !pParent)
    {
        pParent = m_pRootElement;
    }   
    
    
    hr  = CreateXMLElement(pParent,printschema::FEATURE_ELEMENT_NAME,printschema::JOBTICKET_URI,&pNewElement);  

    if(SUCCEEDED(hr))
    {
        hr   = CreateQName(pNewElement,pszNamespaceURI,pszFeatureName,&qName);              
    }
    
    if(SUCCEEDED(hr))
    {   
        hr  = CreateXMLAttribute(pNewElement,printschema::NAME_ATTRIBUTE_NAME,printschema::JOBTICKET_URI,qName,NULL);
    }
    

    if ( qName )
    {
        SysFreeString(qName);
    }
    
    if( SUCCEEDED(hr) && ppFeatureNode)
    {
        *ppFeatureNode = pNewElement;
    }
    else if(pNewElement)
    {
        pNewElement->Release();
    }

    return hr;

}//End function




/*++
Routine Name:
    CreateOptionNode

Routine Description:

    Creates a new Option Node

Arguments:
    pParent - parent node of the new Option node
    ppOptionElement - out pointer to newly created node

Return Value:
    HRESULT Completion status code
    S_OK on success
    E_* on failure
    
--*/

HRESULT ihvjthandler::JobTicketHandler::CreateOptionNode(
    IN IXMLDOMElement *pParent,
    OUT IXMLDOMElement **ppOptionElement OPTIONAL
    )
{
    HRESULT hr = S_OK;

    hr  = CreateXMLElement(pParent,printschema::OPTION_ELEMENT_NAME,printschema::JOBTICKET_URI,ppOptionElement);
    
    return hr;
}


/*++
Routine Name:
    CreateOptionNode

Routine Description:

    Creates a new Option Node

Arguments:
    pParent - parent node of the new Option node
    pszNamespaceURI - namesapce URI to which new node belongs
    pszFeatureName - local name of the new Option node
    ppOptionElement - out pointer to newly created node

Return Value:
    HRESULT Completion status code
    S_OK on success
    E_* on failure
    
--*/

HRESULT ihvjthandler::JobTicketHandler::CreateOptionNode(
    IN IXMLDOMElement *pParent,
    IN LPTSTR pszNamespaceURI, //print schema URI that corresponds to prefix "prn:"
    IN LPTSTR pszOptionName, //"TopLeft" etc
    OUT IXMLDOMElement **ppOptionElement OPTIONAL
    )
{
    HRESULT hr = S_OK;
    IXMLDOMElement * pNewElement = NULL;    
    BSTR qName = NULL;

    if( !pParent )
    {
        return E_INVALIDARG;
    }

    hr  = CreateXMLElement(pParent,printschema::OPTION_ELEMENT_NAME,printschema::JOBTICKET_URI,&pNewElement);

    if(SUCCEEDED(hr))
    {   
        hr  = CreateQName(pNewElement,pszNamespaceURI,pszOptionName,&qName);        
    }

    if(SUCCEEDED(hr))
    {       
        hr  = CreateXMLAttribute(pNewElement,printschema::NAME_ATTRIBUTE_NAME,printschema::JOBTICKET_URI,qName,NULL);
    }
    
    if(qName)
    {
        SysFreeString(qName);
    }

    if(SUCCEEDED(hr) && ppOptionElement)
    {
        *ppOptionElement = pNewElement;
    }
    else if(pNewElement)
    {   
        pNewElement->Release();
    }

    return hr;
}




/*++
Routine Name:
    CreateOptionNode

Routine Description:

    Creates a new Option Node

Arguments:
    pParent - parent node of the new Option node
    pszNamespaceURI - namesapce URI to which new node belongs
    pszFeatureName - local name of the new Option node
    ppOptionElement - out pointer to newly created node

Return Value:
    HRESULT Completion status code
    S_OK on success
    E_* on failure
    
--*/

HRESULT ihvjthandler::JobTicketHandler::CreateOptionNode(
    IN IXMLDOMElement *pParent,
    IN LPTSTR pszNamespaceURI, //print schema URI that corresponds to prefix "prn:"
    IN LPTSTR pszOptionName, // name attribute, "TopLeft" etc
    IN LPTSTR pszConstrainNamespaceURI, //print schema URI that corresponds to prefix "prn:" etc
    IN LPTSTR pszConstrainName, //constrained attribute "none" etc
    OUT IXMLDOMElement **ppOptionElement OPTIONAL
    )
{
    HRESULT hr = S_OK;
    IXMLDOMElement * pNewElement = NULL;    
    BSTR qName = NULL;

    if( !pParent )
    {
        return E_INVALIDARG;
    }

    hr  = CreateXMLElement(pParent,printschema::OPTION_ELEMENT_NAME,printschema::JOBTICKET_URI,&pNewElement);

    //
    // Create "name" attribute
    //
    if(SUCCEEDED(hr))
    {   
        hr  = CreateQName(pNewElement,pszNamespaceURI,pszOptionName,&qName);        
    }

    if(SUCCEEDED(hr))
    {       
        hr  = CreateXMLAttribute(pNewElement,printschema::NAME_ATTRIBUTE_NAME,printschema::JOBTICKET_URI,qName,NULL);
    }
    
    if(qName)
    {
        SysFreeString(qName);
    }


    //
    // Create "constrained" attribute
    //
    if(SUCCEEDED(hr) && pszConstrainName )
    {   
        hr  = CreateQName(pNewElement,pszConstrainNamespaceURI,pszConstrainName,&qName);        
    

        if(SUCCEEDED(hr))
        {       
            hr  = CreateXMLAttribute(pNewElement,printschema::CONSTRAINED_ATTRIBUTE_NAME,printschema::JOBTICKET_URI,qName,NULL);
        }
        
        if(qName)
        {
            SysFreeString(qName);
        }
    }


    if(SUCCEEDED(hr) && ppOptionElement)
    {
        *ppOptionElement = pNewElement;
    }
    else if(pNewElement)
    {   
        pNewElement->Release();
    }

    return hr;
}












/*++
Routine Name:
    CreatePropertyNode

Routine Description:

    Creates a new Property Node

Arguments:
    pParent - parent of the new node
    pszNamespaceURI - namesapce URI to which new node belongs
    pszPropertyName - local name of the new node
    pszValueAttrUri - namesapce URI to which value attribute of the new node belongs
    pszValueAttrName - local name of the value attribute of the new node
    value - Double value for the new property
    isScored - specifies if scored property or property node is to be created
    ppPropertyNode - out pointer to newly created node

Return Value:
    HRESULT Completion status code
    S_OK on success
    E_* on failure
    
--*/
HRESULT ihvjthandler::JobTicketHandler::CreatePropertyNode( 
    IN IXMLDOMElement *pParent, OPTIONAL  // default is document scope
    IN LPTSTR pszNamespaceUri, 
    IN LPTSTR pszPropertyName,
    IN LPTSTR pszValueAttrUri,
    IN LPTSTR pszValueAttrName,
    IN DOUBLE value,
    IN BOOL isScored,
    OUT IXMLDOMElement **ppPropertyNode OPTIONAL
    )
{
    HRESULT hr = S_OK;
    VARIANT v;

    VariantInit( &v );
    V_VT(&v) = VT_R8;
    V_R8(&v) = value;

    hr  = VariantChangeType( &v, &v, VARIANT_NOUSEROVERRIDE, VT_BSTR );

    if( SUCCEEDED(hr) )
    {
        hr  = CreatePropertyNode( pParent, pszNamespaceUri, pszPropertyName, pszValueAttrUri, pszValueAttrName, V_BSTR(&v), isScored, ppPropertyNode );
    }

    VariantClear( &v );

    return hr;
}



/*++
Routine Name:
    CreatePropertyNode

Routine Description:

    Creates a new Property Node

Arguments:
    pParent - parent of the new node
    pszNamespaceURI - namesapce URI to which new node belongs
    pszPropertyName - local name of the new node
    pszValueAttrUri - namesapce URI to which value attribute of the new node belongs
    pszValueAttrName - local name of the value attribute of the new node
    value - Integer value for the new property
    isScored - specifies if scored property or property node is to be created
    ppPropertyNode - out pointer to newly created node

Return Value:
    HRESULT Completion status code
    S_OK on success
    E_* on failure
    
--*/
HRESULT ihvjthandler::JobTicketHandler::CreatePropertyNode( 
    IN IXMLDOMElement *pParent, OPTIONAL  // default is document scope
    IN LPTSTR pszNamespaceUri, 
    IN LPTSTR pszPropertyName,
    IN LPTSTR pszValueAttrUri,
    IN LPTSTR pszValueAttrName,
    IN INT value,
    IN BOOL isScored,
    OUT IXMLDOMElement **ppPropertyNode OPTIONAL
    )
{
    HRESULT hr = S_OK;
    VARIANT v;

    VariantInit( &v );
    V_VT(&v) = VT_INT;
    V_INT(&v) = value;

    hr  = VariantChangeType( &v, &v, VARIANT_NOUSEROVERRIDE, VT_BSTR );

    if( SUCCEEDED(hr) )
    {
        hr  = CreatePropertyNode( pParent, pszNamespaceUri, pszPropertyName, pszValueAttrUri,pszValueAttrName,V_BSTR(&v), isScored, ppPropertyNode );
    }

    VariantClear( &v );

    return hr;
}



/*++
Routine Name:   
    CreatePropertyNode

Routine Description:

    Creates a new Property Node

Arguments:
    pParent - parent of the new node
    pszNamespaceURI - namesapce URI to which new node belongs
    pszPropertyName - local name of the new node
    pszValueUri - namespace URI for the value
    pszValueName - string value
    pszValueAttrUri - namesapce URI to which value attribute of the new node belongs
    pszValueAttrName - local name of the value attribute of the new node
    value - Integer value for the new property
    isScored - specifies if scored property or property node is to be created
    ppPropertyNode - out pointer to newly created node

Return Value:
    HRESULT Completion status code
    S_OK on success
    E_* on failure
    
--*/
HRESULT ihvjthandler::JobTicketHandler::CreatePropertyNode( 
    IN IXMLDOMElement *pParent, OPTIONAL  
    IN LPTSTR pszUri,
    IN LPTSTR pszName,
    IN LPTSTR pszValueUri,
    IN LPTSTR pszValueName,
    IN LPTSTR pszValueAttrUri,
    IN LPTSTR pszValueAttrName,
    IN BOOL isScored,
    OUT IXMLDOMElement **ppPropertyNode OPTIONAL
    )

{
    HRESULT hr = S_OK;
    BSTR bstrNewValue = NULL;

    
    if( !pszUri || !pszName || !pszValueUri || !pszValueName )
    {
        return E_INVALIDARG;        
    }

        
    if( !pParent ) 
    {
        pParent = m_pRootElement;
    }

    hr  = CreateQName(pParent,  pszValueUri, pszValueName,&bstrNewValue);

    //
    // Now just create it like a normal string property.
    //
    if( SUCCEEDED(hr) )
    {
    
        hr  = CreatePropertyNode( pParent, pszUri, pszName, pszValueAttrUri, pszValueAttrName, bstrNewValue, isScored, ppPropertyNode );
    }
    
    if( bstrNewValue )
    {
        SysFreeString( bstrNewValue );
    }

    return hr;
}


/*++
Routine Name:
    CreatePropertyNode

Routine Description:

    Creates a new Property Node

Arguments:
    pParent - parent of the new node
    pszNamespaceURI - namesapce URI to which new node belongs
    pszPropertyName - local name of the new node
    pszValueAttrUri - namesapce URI to which value attribute of the new node belongs
    pszValueAttrName - local name of the value attribute of the new node
    value - String value for the new property
    isScored - specifies if scored property or property node is to be created
    ppPropertyNode - out pointer to newly created node

Return Value:
    HRESULT Completion status code
    S_OK on success
    E_* on failure
    
--*/
HRESULT ihvjthandler::JobTicketHandler::CreatePropertyNode( 
    IN IXMLDOMElement *pParent, OPTIONAL  // default is document scope
    IN LPTSTR pszUri, 
    IN LPTSTR pszName,
    IN LPTSTR pszValueAttrUri,
    IN LPTSTR pszValueAttrName,
    IN LPTSTR pszValue, OPTIONAL
    IN BOOL isScored,
    OUT IXMLDOMElement **ppPropertyNode OPTIONAL
    )
{

    
    // Output:
    //   <Property name="urins:pszName"><Value xsi:type="CDATA">valuetext</Value></Property>
    
    HRESULT hr = S_OK;
    IXMLDOMElement *pCurrentElement = NULL;
    IXMLDOMNode *pCurrentNode = NULL;

    if( pParent == NULL && isScored )
    {
        return E_UNEXPECTED;
    }

    if( pParent == NULL )
    {
        pParent = m_pRootElement;
    }

    
    // Create the <Property> or <ScoredProperty> element
    
    if( isScored )
    {
        hr  = CreateXMLElement( pParent, printschema::SCORED_PROPERTY_ELEMENT_NAME, printschema::JOBTICKET_URI, &pCurrentElement );
    }
    else
    {
        hr  = CreateXMLElement( pParent, printschema::PROPERTY_ELEMENT_NAME, printschema::JOBTICKET_URI, &pCurrentElement );
    }

    
    // Create the attribute 'name="nsof(pszUri):pszName"'
    
    BSTR bstrQname = NULL;

    if( SUCCEEDED(hr) )
    {
        hr  = CreateQName( pCurrentElement,  pszUri,pszName, &bstrQname );
    }

    if( SUCCEEDED(hr) )
    {
            hr  = CreateXMLAttribute( pCurrentElement, printschema::NAME_ATTRIBUTE_NAME, printschema::JOBTICKET_URI, bstrQname, NULL );
    }

    if(bstrQname)
    {
        SysFreeString( bstrQname );
        bstrQname = NULL;
    }

    if( SUCCEEDED(hr) && pszValue )
    {       
            hr  = CreateValueNode( pCurrentElement, pszValueAttrUri, pszValueAttrName,pszValue, NULL );
    }
   
    // Only give the client back the new element if we succeed.
    
    if( SUCCEEDED(hr) && ppPropertyNode )
    {
        *ppPropertyNode = pCurrentElement;
    } 
    else if( pCurrentElement )
    {
        pCurrentElement->Release();
    }

    return hr;
}


/*++

Routine Name:
    CreateValueNode

Routine Description:
    Creates a new value node
    

Arguments:
    pTargetContext - parent node of the new value node to be created
    pszValueAttrUri - namespace URI for the attribute node of new value node
    pszValueAttrName -  local name of attribute
    value - Integer value to be converted to string to be stored in value node
    ppValueElement - OUT pointer to value element created to be returned

Return Value:
    HRESULT Completion status code
    S_OK - On Success
    E_* - On Failure
    
--*/
HRESULT ihvjthandler::JobTicketHandler::CreateValueNode(
    IN IXMLDOMElement *pTargetContext,
    IN LPTSTR pszValueAttrUri,
    IN LPTSTR pszValueAttrName,
    IN INT value,
    OUT IXMLDOMElement **ppValueElement OPTIONAL
    )
{
    HRESULT hr = S_OK;
    VARIANT v;

    VariantInit( &v );
    V_VT(&v) = VT_INT;
    V_INT(&v) = value;

    hr  = VariantChangeType( &v, &v, VARIANT_NOUSEROVERRIDE, VT_BSTR );

    if( SUCCEEDED(hr) )
    {
        hr  = CreateValueNode( pTargetContext, pszValueAttrUri, pszValueAttrName, V_BSTR(&v), ppValueElement );
    }

    VariantClear( &v );
    return hr;
}



/*++
Routine Name:
    CreateValueNode

Routine Description:
    Creates a new value node
    

Arguments:
    pTargetContext - parent node of the new value node to be created
    pszValueAttrUri - namespace URI for the attribute node of new value node
    pszValueAttrName -  local name of attribute
    ppValueElement - OUT pointer to value element created to be returned

Return Value:
    HRESULT Completion status code
    S_OK - On Success
    E_* - On Failure
    
--*/
HRESULT ihvjthandler::JobTicketHandler::CreateValueNode(
    IN IXMLDOMElement *pTargetContext,
    IN LPTSTR pszValueAttrUri,
    IN LPTSTR pszValueAttrName,
    IN LPTSTR pszValue,
    OUT IXMLDOMElement **ppValueElement OPTIONAL
    )

{
    HRESULT hr;
    BSTR bstrQname = NULL;


    if( !( pszValue && pTargetContext ) )
    {
        hr  = E_INVALIDARG;
        return hr;
    }

    IXMLDOMElement *pCurrentElement = NULL;
    IXMLDOMNode *pCurrentNode = NULL;

    //
    // Create the <Value> element
    //
    hr  = CreateXMLElement( pTargetContext, printschema::VALUE_ELEMENT_NAME, printschema::JOBTICKET_URI, &pCurrentElement );

    //
    // Create the attr 'xsi:type="..."' if it was provided.  If it wasn't we don't want to 
    // try to guess what the type is.
    //
    if( SUCCEEDED(hr) && pszValueAttrUri && pszValueAttrName )
    {
        
        hr  = CreateQName( pCurrentElement,  pszValueAttrUri,pszValueAttrName, &bstrQname );
        if(SUCCEEDED(hr))
            hr  = CreateXMLAttribute( pCurrentElement, L"xsi:type", L"http://www.w3.org/2001/XMLSchema-instance", bstrQname, NULL );
        if(bstrQname)
            SysFreeString(bstrQname);
    }

    //
    // Add the content of the value element
    //
    if(SUCCEEDED(hr))
    {
        hr  = pCurrentElement->put_text( pszValue );
    }

    //
    // Only give the client back the new value element if we succeed.
    // 
    if( SUCCEEDED(hr) && ppValueElement )
    {
        *ppValueElement = pCurrentElement;
    } 
    else if( pCurrentElement )
    {
        pCurrentElement->Release();
    }

    return hr;
}




//Get Methods

/*++
Routine Name:
    GetXMLElement
Routine Description:
    Returns an XML element with given namespace URI and given attribute    

Arguments:

    pParent - Parent of node to be found
    pszElementNamespaceURI -  Namespace URI to which the element belongs
    pszElementName - Local Name of the element
    pszAttrNamespaceURI - Namespace URI to which the attribute of the element belongs
    pszAttrName - local name of the element attribute    
    ppElement - out pointer to xml element so retrieved

Return Value:
    HRESULT Completion status code
    S_OK - On Successfully locating XML node specified
    S_FALSE - If the specified XML node is not found
    E_* - On Failure
    
    Note: Since the module returns S_FALSE if the specified node is not found, the caller must be 
    careful to check hr status to be S_OK before proceeding, just checking for SUCCEEDED(hr) might
    give wrong results

--*/
HRESULT ihvjthandler::JobTicketHandler::GetXMLElement(
    IN IXMLDOMElement *pParent,
    IN LPTSTR pszElementNamespaceURI,
    IN LPTSTR pszElementName, 
    IN LPTSTR pszAttrNamespaceURI, 
    IN LPTSTR pszAttrName, 
    OUT BSTR * ppConstrainName, //can be NULL
    OUT IXMLDOMElement **ppElement
    )
{
    HRESULT hr = S_OK;
    LONG cChildren = 0;
    IXMLDOMNodeList * pChildren = NULL;

    
    if( !pParent || !pszElementNamespaceURI || !pszElementName || !pszAttrNamespaceURI || !pszAttrName)
    {
        return E_INVALIDARG;
    }

    *ppElement = NULL;  

    //
    // Get a list of child nodes for the current DOM node
    //
    hr  = pParent->get_childNodes(&pChildren);

    //
    // Get number of child nodes
    //
    if(SUCCEEDED(hr))
    {   
        hr  = pChildren->get_length(&cChildren);
    }

    if(SUCCEEDED(hr))
    {
        LONG i = 0;
        BOOL bFound = FALSE;

        for(i=0; i<cChildren && !bFound; i++)
        {
            IXMLDOMNode * pCurNode;
            IXMLDOMElement * pCurElement;
            
            hr  = pChildren->get_item(i,&pCurNode);
            
            if(SUCCEEDED(hr))
            {
                hr  = pCurNode->QueryInterface(IID_IXMLDOMElement, (void **)&pCurElement);
            }
            if( hr == S_OK)
            {
                BSTR bstrElementName = NULL;
                BSTR bstrElementNamespaceURI = NULL;
    
                //
                // retrieve element name and namespace URI
                //
                hr  = pCurElement->get_baseName(&bstrElementName);

                if(SUCCEEDED(hr))
                {           
                    hr  = pCurElement->get_namespaceURI(&bstrElementNamespaceURI);
                }

                if(SUCCEEDED(hr))
                {
                
                    if( wcscmp(bstrElementName,pszElementName) == 0 && wcscmp(bstrElementNamespaceURI,pszElementNamespaceURI)==0)
                    {
                        //
                        //check if elelemt name matches
                        //
                        BSTR bstrAttrName;
                        BSTR bstrAttrNamespaceURI;
                        hr  = GetXMLAttribute(pCurElement,&bstrAttrNamespaceURI,&bstrAttrName);
                        if(SUCCEEDED(hr))
                        {
                            if(wcscmp(bstrAttrName,pszAttrName) == 0 && wcscmp(pszAttrNamespaceURI,bstrAttrNamespaceURI)==0)
                            {
                                if( ppConstrainName != NULL )
                                {
                                        *ppConstrainName = NULL;

                                        SysFreeString( bstrAttrNamespaceURI );
                                        
                                        //
                                        // GetXMLConstrain returns S_FALSE if required constrain attribute is not found
                                        // Hence use hrTemp, even if constrain attribute is not found, its not error

                                        HRESULT hrTemp  = GetXMLConstrain(pCurElement,&bstrAttrNamespaceURI,ppConstrainName);
                                        
                                        if( hrTemp == S_OK )
                                        {
                                                if( wcscmp( printschema::PRINTSCHEMA_URI,bstrAttrNamespaceURI ) !=0 )   
                                                {
                                                    //
                                                    // If there is a constrain attribute and it does not belong to 
                                                    // printschema URI then its an error
                                                    //
                                                    hr = S_FALSE;
                                                }
                                        }

                                }

                                bFound = TRUE;
                                *ppElement = pCurElement;
                                (*ppElement)->AddRef();
                                
                            }
                            else
                            {
                                hr = S_FALSE;

                            } //end wcscmp

                        }//end succeeded hr

                        SysFreeString(bstrAttrName);
                        SysFreeString(bstrAttrNamespaceURI);
                    }   
                }
                
                SysFreeString(bstrElementName);
                SysFreeString(bstrElementNamespaceURI);
                
                if(pCurElement)
                {
                    pCurElement->Release();
                }

            }//End hr == S_OK
            
            if(pCurNode)
            {
                pCurNode->Release();
            }

        }//End for

    }//End if


    if(pChildren)
        pChildren->Release();

    if(SUCCEEDED(hr) && (*ppElement) )
    {
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }
    
    if( FAILED(hr) )
    {
        if( ppConstrainName != NULL )
        {
            if( *ppConstrainName )
            {
                SysFreeString( *ppConstrainName );
                *ppConstrainName = NULL;
            }
        }
    }

    return hr;

} // End function




/*++
Routine Name:
    GetXMLElementWithoutAttribute

Routine Description:
    Returns an XML element with given namespace URI. 

Arguments:

    pParent - Parent of node to be found
    pszElementNamespaceURI -  Namespace URI to which the element belongs
    pszElementName - Local Name of the element
    ppChildElement - out pointer to xml element so retrieved

Return Value:
    HRESULT Completion status code
    S_OK - On Successfully locating XML node specified
    S_FALSE - If the specified XML node is not found
    E_* - On Failure

    Note: Since the module returns S_FALSE if the specified node is not found, the caller must be 
    careful to check hr status before proceeding, just checking for SUCCEEDED(hr) might
    give wrong results
    
--*/
HRESULT ihvjthandler::JobTicketHandler::GetXMLElementWithoutAttribute(
    IN IXMLDOMElement *pContext,
    IN LPTSTR pszElementNamespace,
    IN LPTSTR pszElementName,    
    OUT IXMLDOMElement **ppChildElement
    )
{
    if(!pContext || !pszElementName || !pszElementNamespace || !ppChildElement )
    {
        return E_INVALIDARG;
    }
    
    HRESULT hr = S_OK;
    LONG cChildren;
    IXMLDOMNodeList * pContextChildren;
    *ppChildElement = NULL;

    //
    // Get the list of child nodes
    //
    hr  = pContext->get_childNodes( &pContextChildren );

    if( SUCCEEDED(hr) )
        hr = pContextChildren->get_length( &cChildren );

    if( SUCCEEDED(hr) )
    {
        for( LONG i = 0; i < cChildren && !(*ppChildElement); i++ )
        {
    
            IXMLDOMNode *pCurrentNode;
            IXMLDOMElement *pCurrentElement;
            hr = pContextChildren->get_item( i, &pCurrentNode );
            
            //
            // See if its a DOM Element.  Don't set hr here because we 
            // fully expect that not everything in the context is an element.
            //
            if( SUCCEEDED(hr) && pCurrentNode->QueryInterface( IID_IXMLDOMElement, (void**)&pCurrentElement ) == S_OK )
            {
                BSTR pbstrBaseName = NULL;
                BSTR pbstrNamespaceURI = NULL;

                hr  = pCurrentElement->get_baseName( &pbstrBaseName );

                if( SUCCEEDED(hr) )
                {
                    hr  = pCurrentElement->get_namespaceURI( &pbstrNamespaceURI );
                }
                if( SUCCEEDED(hr) &&
                    wcscmp( pbstrNamespaceURI, pszElementNamespace ) == 0 &&
                    wcscmp( pbstrBaseName, pszElementName ) == 0 )
                {
                    *ppChildElement = pCurrentElement;
                    (*ppChildElement)->AddRef();
                }

                pCurrentElement->Release();
                SysFreeString( pbstrBaseName );
                SysFreeString( pbstrNamespaceURI );
            }

            if( pCurrentNode )
            {
                pCurrentNode->Release();
            }
        }
    }

    if( pContextChildren )
    {
        pContextChildren->Release();
    }

    if( SUCCEEDED(hr) )
    {
        if( *ppChildElement )
        {
            hr  = S_OK;
        }
        else
        {
            hr  = S_FALSE;
        }
    }

    return hr;
}




/*++
Routine Name:
    GetXMLAttribute

Routine Description:
    Returns an XML Attribute node with given namespace URI. 

Arguments:

    pParent - Parent of node to be found
    pszAttrNamespaceURI -  Namespace URI to which the attribute belongs
    pszAttrName - Local Name of the attribute
    ppChildElement - out pointer to xml node so retrieved

Return Value:
    HRESULT Completion status code
    S_OK - On Success
    E_* - On Failure
    
--*/
HRESULT ihvjthandler::JobTicketHandler::GetXMLAttribute(
    IN IXMLDOMElement *pElement,
    OUT BSTR *ppAttrNamespaceURI, 
    OUT BSTR *ppAttrName
    )
{
    HRESULT hr = S_OK;
    IXMLDOMNamedNodeMap *pAttrMap = NULL;
    IXMLDOMNode *pAttrNode = NULL;
        
    if(!pElement || !ppAttrNamespaceURI || !ppAttrName)
    {
        return E_INVALIDARG;
    }

    *ppAttrNamespaceURI = NULL; 
    *ppAttrName = NULL;

    hr  = pElement->get_attributes(&pAttrMap);  

    if(SUCCEEDED(hr))
    {
        hr  = pAttrMap->getNamedItem(printschema::NAME_ATTRIBUTE_NAME,&pAttrNode);
    }

    if(hr == S_OK)
    {
        BSTR bstrAttrQName = NULL;
        IXMLDOMAttribute * pAttribute = NULL;
        
        hr  = pAttrNode->QueryInterface(IID_IXMLDOMAttribute,(void **)&pAttribute);

        if(SUCCEEDED(hr))
            hr  = pAttribute->get_text(&bstrAttrQName);
        
        if(SUCCEEDED(hr))
            hr  = getUri(pElement,bstrAttrQName,ppAttrNamespaceURI);
        
        if(SUCCEEDED(hr))
            hr  = getLocalName(bstrAttrQName,ppAttrName);
        
        if(pAttribute)
            pAttribute->Release();
    
    }//End if hr == S_OK

    if(pAttrMap)
        pAttrMap->Release();
    if(pAttrNode)
        pAttrNode->Release();

    if(FAILED(hr))
    {
        if(*ppAttrNamespaceURI)
            SysFreeString( *ppAttrNamespaceURI);
        if(*ppAttrName)
            SysFreeString( *ppAttrName);
    }
    return hr;
}




/*++
Routine Name:
    GetXMLConstrain

Routine Description:
    Returns an XML Attribute node for constrain attribute with given namespace URI. 

Arguments:

    pParent - Parent of node to be found
    pszAttrNamespaceURI -  Namespace URI to which the attribute belongs
    pszAttrName - Local Name of the attribute
    ppChildElement - out pointer to xml node so retrieved

Return Value:
    HRESULT Completion status code
    S_OK - On Successfully finding attribute
    S_FALSE - If the attribute is not found
    E_* - On Failure
    
--*/
HRESULT ihvjthandler::JobTicketHandler::GetXMLConstrain(
    IN IXMLDOMElement *pElement,
    OUT BSTR *ppAttrNamespaceURI, 
    OUT BSTR *ppAttrName
    )
{
    HRESULT hr = S_OK;
    IXMLDOMNamedNodeMap *pAttrMap = NULL;
    IXMLDOMNode *pAttrNode = NULL;
        
    if(!pElement || !ppAttrNamespaceURI || !ppAttrName)
    {
        return E_INVALIDARG;
    }

    *ppAttrNamespaceURI = NULL; 
    *ppAttrName = NULL;

    hr  = pElement->get_attributes(&pAttrMap);  

    if(SUCCEEDED(hr))
    {
        hr  = pAttrMap->getNamedItem(printschema::CONSTRAINED_ATTRIBUTE_NAME,&pAttrNode);
    }
    //
    // getNamedItem returns S_FALSE if specified attribute is not found
    //
    if(hr == S_OK)
    {
        BSTR bstrAttrQName = NULL;
        IXMLDOMAttribute * pAttribute = NULL;
        
        hr  = pAttrNode->QueryInterface(IID_IXMLDOMAttribute,(void **)&pAttribute);

        if(SUCCEEDED(hr))
            hr  = pAttribute->get_text(&bstrAttrQName);
        
        if(SUCCEEDED(hr))
            hr  = getUri(pElement,bstrAttrQName,ppAttrNamespaceURI);
        
        if(SUCCEEDED(hr))
            hr  = getLocalName(bstrAttrQName,ppAttrName);
        
        if(pAttribute)
            pAttribute->Release();
    
    }//End if hr == S_OK

    if(pAttrMap)
        pAttrMap->Release();
    if(pAttrNode)
        pAttrNode->Release();

    if(FAILED(hr))
    {
        if(*ppAttrNamespaceURI)
            SysFreeString( *ppAttrNamespaceURI);
        if(*ppAttrName)
            SysFreeString( *ppAttrName);
    }
    return hr;
}








/*++
Routine Name:
    GetFeatureNode

Routine Description:

    Returns the feature node with specified attribute under printschema namespace

Arguments:
    pParent - parent node of the feature node to be located
    pszAttrNamespaceURI - namespace URI for the attribute node of given feature node
    pszAttrName - attribute name for given feature node
    ppElement - OUT pointer to feature node to be returned

Return Value:
    HRESULT Completion status code
    S_OK - On Successfully locating Feature node
    S_FALSE - If Feature node is not found
    E_* - On Failure

    
--*/
HRESULT ihvjthandler::JobTicketHandler::GetFeatureNode(
    IN IXMLDOMElement *pParent,
    IN LPTSTR pszAttrNamespaceURI, 
    IN LPTSTR pszAttrName, 
    OUT IXMLDOMElement **ppElement
    )
{
    HRESULT hr = S_OK;

    //
    // If no parent is specified, set root of DOM tree as parent
    //
    if( !pParent )
    {
        pParent = m_pRootElement;
    }
    
    hr = GetXMLElement(pParent,printschema::JOBTICKET_URI,printschema::FEATURE_ELEMENT_NAME,pszAttrNamespaceURI,pszAttrName,NULL, ppElement);

    return hr;
}


/*++
Routine Name:
    GetOptionNode

Routine Description:

    Returns the option node under printschema namespace

Arguments:
    pParent - parent node of the option node to be located
    ppElement - OUT pointer to option node to be returned

Return Value:
    HRESULT Completion status code
    S_OK - On Successfully locating Option node
    S_FALSE - If Option node is not found
    E_* - On Failure
    
--*/
HRESULT 
ihvjthandler::JobTicketHandler::GetOptionNode(
    IN IXMLDOMElement *pParent, 
    OUT IXMLDOMElement **ppElement
    )
{
    return GetXMLElementWithoutAttribute(pParent,printschema::JOBTICKET_URI,printschema::OPTION_ELEMENT_NAME,ppElement);
}


/*++

Routine Name:
    GetOptionNode

Routine Description:

    Returns the option node with specified attribute and under printschema namespace

Arguments:
    pParent - parent node of the option node to be located
    pszAttrNamespaceURI - namespace URI for the attribute node of given option node
    pszAttrName - attribute name for given option node
    ppElement - OUT pointer to option node to be returned

Return Value:
    HRESULT Completion status code
    S_OK - On Success
    E_* - On Failure
    
--*/
HRESULT ihvjthandler::JobTicketHandler::GetOptionNode(
    IN IXMLDOMElement *pParent,
    IN LPTSTR pszAttrNamespaceURI, 
    IN LPTSTR pszAttrName, 
    OUT IXMLDOMElement **ppElement
    )
{
    return GetXMLElement(pParent,printschema::JOBTICKET_URI,printschema::OPTION_ELEMENT_NAME,pszAttrNamespaceURI,pszAttrName,NULL,ppElement);
}



/*++

Routine Name:
    GetOptionNode

Routine Description:

    Returns the option node with specified attribute and under printschema namespace

Arguments:
    pParent - parent node of the option node to be located
    pszAttrNamespaceURI - namespace URI for the attribute node of given option node
    pszAttrName - attribute name for given option node
    ppElement - OUT pointer to option node to be returned

Return Value:
    HRESULT Completion status code
    S_OK - On Success
    E_* - On Failure
    
--*/
HRESULT ihvjthandler::JobTicketHandler::GetOptionNode(
    IN IXMLDOMElement *pParent,
    IN LPTSTR pszAttrNamespaceURI, 
    IN LPTSTR pszAttrName, 
    OUT BSTR * ppConstrainName,
    OUT IXMLDOMElement **ppElement
    )
{
    return GetXMLElement(pParent,printschema::JOBTICKET_URI,printschema::OPTION_ELEMENT_NAME,pszAttrNamespaceURI,pszAttrName,ppConstrainName, ppElement);
}


/*++
Routine Name:
    GetPropertyNode

Routine Description:

    Returns the option node with specified attribute and under printschema namespace

Arguments:
    pParent - parent node of the option node to be located
    pszAttrNamespaceURI - namespace URI for the attribute node of given option node
    pszAttrName - attribute name for given option node
    ppElement - OUT pointer to option node to be returned

Return Value:
    HRESULT Completion status code
    S_OK - On Success
    E_* - On Failure

    
--*/
HRESULT 
ihvjthandler::JobTicketHandler::GetPropertyNode(
    IN IXMLDOMElement *pParent,
    IN LPTSTR pszAttrNamespaceURI, 
    IN LPTSTR pszAttrName, 
    BOOL bIsScored,
    OUT IXMLDOMElement **ppElement
    )
{
    if(bIsScored)
        return GetXMLElement(pParent,printschema::JOBTICKET_URI,printschema::SCORED_PROPERTY_ELEMENT_NAME,pszAttrNamespaceURI,pszAttrName,NULL, ppElement);
    else
        return GetXMLElement(pParent,printschema::JOBTICKET_URI,printschema::PROPERTY_ELEMENT_NAME,pszAttrNamespaceURI,pszAttrName,NULL, ppElement);
}


//
// There should be a return code for these routines to indicate the value is of the wrong type
//
/*++

Routine Name:
    GetValueAsQName

Routine Description:
    Returns the text of XML value element in the form of XML QName ie namespace URI and local name.    

Arguments:
    pContext - Parent of the node from which we need to extract the value
    pValueUri   - OUT pointer to the namespace URI string to be returned
    pValueLocalName - OUT pointer to local name string to be returned
    ppElement - XML DOM Element from which value string is to be obtained   

Return Value:
    HRESULT Completion status code
    S_OK - On Success
    E_* - On Failure
    
--*/
HRESULT 
ihvjthandler::JobTicketHandler::GetValueAsQName(
    IN IXMLDOMElement *pContext, // Property, ScoredProperty, Attribute, or Parameter
    OUT BSTR *pValueUri,
    OUT BSTR *pValueLocalName,
    OUT IXMLDOMElement **ppElement
    )
{
    HRESULT hr;
    IXMLDOMElement *pValueElement = NULL;;
    BSTR bstrQName = NULL;

    if( !(pContext && pValueUri && pValueLocalName) )
    {
        hr  = E_INVALIDARG;
        return hr;
    }

    *pValueUri = NULL;
    *pValueLocalName = NULL;

    hr  = GetXMLElementWithoutAttribute( 
        pContext, 
        printschema::JOBTICKET_URI, 
        printschema::VALUE_ELEMENT_NAME,         
        &pValueElement );
    
    if( hr == S_OK )
    {
        hr  = pValueElement->get_text( &bstrQName );
    }

    if( SUCCEEDED(hr) )
    {
        hr  = this->getLocalName( bstrQName, pValueLocalName );
    }

    if( SUCCEEDED(hr) )
    {
        hr  = this->getUri( pValueElement, bstrQName, pValueUri );
    }

    if(SUCCEEDED(hr) && ppElement)
    {
        *ppElement = pValueElement;
        (*ppElement)->AddRef();
    }
    if( pValueElement )
        pValueElement->Release();

    if( FAILED(hr) )
    {
        SysFreeString( *pValueLocalName );
        SysFreeString( *pValueUri );

        pValueLocalName = NULL;
        pValueUri = NULL;
    }

    return hr;
}


/*++
Routine Name: 
    GetValueAsBSTR
Routine Description:

    Returns value text of given value element as BSTR 

Arguments:
    pContext - Parent of the node from which we need to extract the value
    ppbstrValue - OUT pointer to the value string to be returned
    ppElement - XML DOM Element from which value string is to be obtained   

Return Value:
    HRESULT Completion status code
    S_OK - On Success
    E_* - On Failure
    
--*/
HRESULT 
ihvjthandler::JobTicketHandler::GetValueAsBSTR(
    IN IXMLDOMElement *pContext, // Property, ScoredProperty, Attribute, or Parameter
    OUT BSTR *ppbstrValue,
    OUT IXMLDOMElement **ppElement
    )
{
    
    HRESULT hr;

    if( ! pContext || ! ppbstrValue  )
    {
        hr  = E_INVALIDARG;
        return hr;
    }

    IXMLDOMElement * pValueElement = NULL;
    
    *ppbstrValue = NULL;

    hr  = GetXMLElementWithoutAttribute( 
        pContext, 
        printschema::JOBTICKET_URI, 
        printschema::VALUE_ELEMENT_NAME,         
        &pValueElement );
    
    if( hr == S_OK && pValueElement )
    {       
        hr  = pValueElement->get_text( ppbstrValue );   
    }
    

    if(SUCCEEDED(hr) && ppElement)
    {
        *ppElement = pValueElement;
    
        (*ppElement)->AddRef();

    }

    if(pValueElement)
        pValueElement->Release();

    return hr;
}


/*++
Routine Name:
    GetValueAsInt
Routine Description:
    Returns the value text for the input node as integer.    

Arguments:
    pContext - parent node 
    pValue  - integer value
    ppElement - XML element whose value is to be obtained
Return Value:
    HRESULT Completion status code
    
--*/
HRESULT 
ihvjthandler::JobTicketHandler::GetValueAsInt(
    IN IXMLDOMElement *pContext, // Property, ScoredProperty, Attribute, or Parameter
    OUT INT *pValue,
    OUT IXMLDOMElement **ppElement
    )

{
    HRESULT hr;

    if( !( pContext && pValue ) )
    {
        hr  = E_INVALIDARG;
        return hr;
    }
    *pValue = -1;

    BSTR pbstrValue = NULL;
    hr  = GetValueAsBSTR( pContext, &pbstrValue ,ppElement);

    if( SUCCEEDED(hr) )
    {               
        VARIANT varValue;

        VariantInit(&varValue);
        V_VT(&varValue) = VT_BSTR;
        V_BSTR(&varValue) = pbstrValue;

        //
        // The VARIANT_NOUSEROVERRIDE indicates don't base the conversion on the locale... Doing 
        // so would mean that driver configuration files would have to be localized (not just 
        // their public resources)
        //
        // The change type is also going to clean up the BSTR.
        //
        hr  = VariantChangeType( &varValue, &varValue, VARIANT_NOUSEROVERRIDE, VT_INT );

        if(SUCCEEDED(hr))
        {
            
            *pValue = V_INT(&varValue);
        }

        //
        // if the conversion succeeded, the bstr was freed 
        // then.  Otherwise, the bstr will be freed here.
        //
        VariantClear( &varValue );
    }

    return hr;
}



/*++

Routine Name:
    getLocalName
Routine Description:
    Returns Local name for input XML Qname.

Arguments:
    pszQName - Qname for which local name is to be found out
    ppbstrLocalName - OUT pointer to local name

Return Value:
    HRESULT Completion status code
    S_OK - On Success
    E_* - On Failure
    
--*/
HRESULT 
ihvjthandler::JobTicketHandler::getLocalName( 
    IN LPTSTR pszQName, 
    OUT BSTR *ppbstrLocalName 
    )
{
    HRESULT hr = S_OK;

    if(!pszQName || !ppbstrLocalName) 
    {
            return E_INVALIDARG;
    }

    *ppbstrLocalName = NULL;
    
    LPTSTR pszStartPos = wcschr(pszQName,L':');
    
    if( pszStartPos )
    {
            pszStartPos++; 
    }
    else
    {
            pszStartPos = pszQName;
    }

    *ppbstrLocalName = SysAllocString( pszStartPos );

    if(!(*ppbstrLocalName)) 
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


/*++
Routine Name:
    getUri
Routine Description:
    Returns namespace URI for given input Qname and in context of given XML DOM node.
Arguments:
    pContext - Input XML DOM node for current context
    pszQName - input qname
    pbstrURI - OUT pointer to URI to be returned
Return Value:

    S_OK if found
    S_FALSE if not found
    E_OUTOFMEMORY if the string could not be allocated
    E_INVALIDARG if a non-optional param is null.

Notes: 

    This routine assumes that the string has already been 
    validated, which should have happened in the managed code base.
    The string should either be of the form "prefix:localname", 
    or "localname"

--*/
HRESULT 
ihvjthandler::JobTicketHandler::getUri( 
    IXMLDOMElement *pContext,
    IN LPWSTR pszQName, 
    OUT BSTR *pbstrURI 
    )

{
    HRESULT hr = S_OK;
    BOOL bNodePushed = FALSE;

    if( !(pContext && pbstrURI && pszQName) )
    {
        return E_INVALIDARG;
    }

    LPTSTR pszSplitPos = wcschr(pszQName, L':');
    INT cchUri = 0;
    *pbstrURI = NULL;

    //
    // if splitpos is null, then there is no namespace 
    // prefix, which means return the default namespace.
    //
    wchar_t wchSwapChar;
    if( pszSplitPos )
    {
        wchSwapChar = *pszSplitPos;
        *pszSplitPos = (wchar_t)0;
    }
    else
    {
        pszQName = L"";
    }

    hr = m_pNSManager->pushNodeContext( pContext, TRUE );

    if( SUCCEEDED(hr) )
    {
        bNodePushed = TRUE;
        // get the length first, then alloc the string
        hr = m_pNSManager->getURI( pszQName, NULL, NULL, &cchUri );
    }

    if( hr == S_OK )
    {
        if( SUCCEEDED(hr) )
        {
            // account for null terminator
            cchUri += 1;

            *pbstrURI = SysAllocStringLen( NULL, cchUri );
            if( !(*pbstrURI) )
            {
                hr  = E_OUTOFMEMORY;
            }
        }

        if( SUCCEEDED(hr) )
        {
            hr  = m_pNSManager->getURI( pszQName, NULL, *pbstrURI, &cchUri );
        }

        if( pszSplitPos )
        {
            *pszSplitPos = wchSwapChar;
        }

        if( FAILED(hr) && (*pbstrURI) )
        {
            SysFreeString(*pbstrURI);
            *pbstrURI = NULL;
        }
    }

    if( bNodePushed )
    {
        hr = m_pNSManager->popContext();
    }

    return hr;
}




/*++

Routine Name:
    getPrefix
Routine Description:

    Returns predefined Prefix for the input namespace URI if one already exists

Arguments:
    pContext - Current context node
    pszUri - namespace URI for which prefix is to be obtained
    pbstrPrefix - prefix string to be returned, if NULL routine just checks for 
                    existence of prefix

Return Value:
    HRESULT Completion status code
    S_OK - on success
    S_FALSE - on failure
    
--*/
HRESULT 
ihvjthandler::JobTicketHandler::getPrefix(
    IN IXMLDOMElement *pContext,
    IN LPWSTR pszUri,
    OUT BSTR *pbstrPrefix OPTIONAL
    )
{
    HRESULT hr = S_OK;
    BOOL bNodePushed = FALSE;
    INT cchPrefix = 0;

    if(!pContext || !pszUri)
            return E_INVALIDARG;
    
    //Push context "Deep" to get info abt all URI prefix mappings defined so far in the current DOM document
    hr  = m_pNSManager->pushNodeContext( pContext, TRUE );

    if( SUCCEEDED(hr) )
    {       
        bNodePushed = TRUE;

        // get the length first, then alloc the string        
        
        hr = m_pNSManager->getPrefix( pszUri, 0, NULL, &cchPrefix );
    }

    
    if( hr == S_OK && pbstrPrefix )
    {
        
        *pbstrPrefix = NULL;
        cchPrefix++;

        if( SUCCEEDED(hr) )
        {
            *pbstrPrefix = SysAllocStringLen( NULL, cchPrefix );

            if( !(*pbstrPrefix) )
                hr  = E_OUTOFMEMORY;
     
        }

        if( SUCCEEDED(hr) )
        {
            hr  = m_pNSManager->getPrefix( pszUri, 0, *pbstrPrefix, &cchPrefix );
            
        }

        if( FAILED(hr) && (*pbstrPrefix) )
        {
            SysFreeString(*pbstrPrefix);
            *pbstrPrefix = NULL;
        }
    }

    
    // Note: MSXML NSManager returns S_FALSE for an undeclared URI, and E_FAIL for an undeclared 
    // prefix (based on testing) , hence it is safe to check for both here.
    // Result of getPrefix isn't clearly documented for the case that the prefix not declared.
    

    if( E_FAIL == hr || S_FALSE == hr )
    {
        // NS manager didn't find the prefix.  tweak the result to S_FALSE
        hr  = S_FALSE;
    }

    if( bNodePushed )
    {
        m_pNSManager->popContext();
    }

    return hr;
}







/*++

Routine Name:
    ChangeOption
Routine Description:
    Changes the name attribute of old option node to the new option string specified

Arguments:
    pszNewOption - New option string
    pOld    Old node

Return Value:
    HRESULT Completion status code
    
--*/

HRESULT 
ihvjthandler::JobTicketHandler::ChangeOption(    
    IN LPTSTR pszNewOption,
    IN IXMLDOMElement *pOld
    )
{
    HRESULT hr = S_OK;
    VARIANT option;
    
    if( !pszNewOption || !pOld )
    {   
        return E_INVALIDARG;
    }

    //
    // Get namespace URI for previous attribute
    //
    BSTR bstrAttrNamespaceUri;
    BSTR bstrAttrName;
    BSTR bstrQName = NULL;

    hr  = GetXMLAttribute( pOld , &bstrAttrNamespaceUri , &bstrAttrName );

    if( SUCCEEDED(hr) )
    {
        //
        // Now create new QName with old namespace URI but new Option name
        //
        hr = CreateQName( pOld, bstrAttrNamespaceUri, pszNewOption , &bstrQName );
    }

    if( SUCCEEDED(hr) )
    {
        VariantInit(&option);
        V_VT(&option) = VT_BSTR;
        V_BSTR(&option) = SysAllocString( bstrQName );  
        hr = pOld->setAttribute(printschema::NAME_ATTRIBUTE_NAME,option);
        VariantClear(&option);  
    }

    if( bstrAttrNamespaceUri )
    {
        SysFreeString( bstrAttrNamespaceUri );
    }

    if( bstrAttrName )
    {
        SysFreeString( bstrAttrName );
    }

    if( bstrQName )
    {
        SysFreeString( bstrQName );
    }

    return hr;  
    
}//End function




/*++
Routine Name:
    ChangeOption
Routine Description:
    Changes the name attribute of old option node to that of the new node

Arguments:
    pNew - New node
    pOld    Old node

Return Value:
    HRESULT Completion status code
    
--*/
HRESULT 
ihvjthandler::JobTicketHandler::ChangeOption(       
    IN IXMLDOMElement * pNew,
    IN IXMLDOMElement *pOld
    )
{
    HRESULT hr = S_OK;
    VARIANT value;

    if( !pNew || !pOld)
    {
        return E_INVALIDARG;    
    }

    hr = pNew->getAttribute( printschema::NAME_ATTRIBUTE_NAME, &value );

    if( SUCCEEDED(hr) && V_VT( &value) != VT_NULL )
    {
        hr = pOld->setAttribute( printschema::NAME_ATTRIBUTE_NAME, value );
    }//End if

    return hr;  
    
}//End function


/*++
Routine Name:
    ChangeValue
Routine Description:
    Changes the value text of the Old node to that of the new node

Arguments:
    pNew - New node
    pOld    Old node

Return Value:
    HRESULT Completion status code
    S_OK - On Success
    E_* - On failure

--*/
HRESULT 
ihvjthandler::JobTicketHandler::ChangeValue(    
    IN IXMLDOMElement * pNew,
    IN IXMLDOMElement *pOld     
    )
{
    HRESULT hr = S_OK;
    BSTR text = NULL;

    if( !pNew || !pOld )
    {
        return E_INVALIDARG;
    }

    hr = pNew->get_text(&text);

    if( SUCCEEDED(hr) && text )
    {
        hr = pOld->put_text( text );
    }

    return hr;

}//End function





/*++
Routine Name:
    ChangeValue
Routine Description:
    Changes the value text of the Old node to the string equivalent of newly specified integer value

Arguments:
    newValue - INTEGER new value
    pOld - Old node whose value is to bechanged

Return Value:
    HRESULT Completion status code
    S_OK - On Success
    E_* - On failure

--*/
HRESULT 
ihvjthandler::JobTicketHandler::ChangeValue(    
    IN INT newValue,
    IN IXMLDOMElement *pOld     
    )
{
    HRESULT hr = S_OK;
    

    if( !pOld )
    {
        return E_INVALIDARG;
    }

    VARIANT v;

    VariantInit( &v );
    V_VT(&v) = VT_INT;
    V_INT(&v) = newValue;

    hr  = VariantChangeType( &v, &v, VARIANT_NOUSEROVERRIDE, VT_BSTR );

    if( SUCCEEDED(hr) )
    {
        hr = pOld->put_text( V_BSTR(&v) );
    }

    return hr;

}//End function









/*++
Routine Name:
    DeleteFeatureNode
Routine Description:

    Deletes given input Feature node and all its children from DOM tree

Arguments:

    pParent - Parent node of the XML DOM node to be deleted
    pElement - XML DOM node to be deleted

Return Value:
    HRESULT Completion status code
    S_OK - On Success
    E_* - On failure    
--*/
HRESULT 
ihvjthandler::JobTicketHandler::DeleteFeatureNode(
    IN IXMLDOMNode * pParent,
    IN IXMLDOMNode * pElement
)
{
    return DeleteNodeAndAllChildren( pParent,pElement );

}//End function




/*++
Routine Name:
    DeleteNodeAndAllChildren
Routine Description:

    Deletes given input Feature node and all its children from DOM tree

Arguments:
    pParent - Parent node of the XML DOM node to be deleted
    pElement - XML DOM node to be deleted    

Return Value:
    HRESULT Completion status code
    S_OK - On Success
    E_* - On failure
    
--*/
HRESULT 
ihvjthandler::JobTicketHandler::DeleteNodeAndAllChildren(
    IN IXMLDOMNode * pParent,
    IN IXMLDOMNode * pElement
)
{
    HRESULT hr = S_OK;
    
    VARIANT_BOOL bHasChild = FALSE;
    IXMLDOMNode * pRemovedElement = NULL;

    if( !pElement )
    {
        return E_INVALIDARG;
    }

    //
    //if no parent node specified assume root of DOM tree as parent
    //
    if(!pParent)
    {
        pParent = m_pRootElement;
    }

    //
    // MSXML function removeChild removes the given child of the XML element and all its children,
    // even the Attribute nodes defined for given element node if any are removed
    // Hence we do not need to worry about recursively removing all the children of the given node
    // before removing it
    //
    
    hr = pParent->removeChild( pElement, &pRemovedElement );
    

    if( pRemovedElement )
    {
        pRemovedElement->Release();
    }

    return hr ;

}//End function










