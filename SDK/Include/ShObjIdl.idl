//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  File: shobjidl.idl
//
//  Contents: This interface definition contains shell objects that can be remoted
//


import "objidl.idl";
import "oleidl.idl";
import "oaidl.idl";
import "shtypes.idl";
import "servprov.idl";
import "comcat.idl";        // for IEnumGUID
import "propidl.idl";
import "prsht.idl";
import "msxml.idl";
import "wtypes.idl";

cpp_quote("#ifndef _WINRESRC_")
cpp_quote("#ifndef _WIN32_IE")
cpp_quote("#define _WIN32_IE 0x0501")
cpp_quote("#else")
cpp_quote("#if (_WIN32_IE < 0x0400) && defined(_WIN32_WINNT) && (_WIN32_WINNT >= 0x0500)")
cpp_quote("#error _WIN32_IE setting conflicts with _WIN32_WINNT setting")
cpp_quote("#endif")
cpp_quote("#endif")
cpp_quote("#endif")

cpp_quote("#ifndef SHSTDAPI")
cpp_quote("#if defined(_SHELL32_)")
cpp_quote("#define SHSTDAPI          STDAPI")
cpp_quote("#define SHSTDAPI_(type)   STDAPI_(type)")
cpp_quote("#else")
cpp_quote("#define SHSTDAPI          EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE")
cpp_quote("#define SHSTDAPI_(type)   EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE")
cpp_quote("#endif")
cpp_quote("#endif // SHSTDAPI")

// IPersistFolder
[
    object,
    uuid(000214EA-0000-0000-C000-000000000046),  // IID_IPersistFolder
    pointer_default(unique),
]
interface IPersistFolder : IPersist
{
    // IShellFolder::BindToObject when it is initializing a shell folder object.")
    // called when the explorer is initializing a shell folder object.
    // pidl -- Specifies the absolute location of the folder
    HRESULT Initialize([in] PCIDLIST_ABSOLUTE pidl);
};

typedef IPersistFolder *LPPERSISTFOLDER;

cpp_quote("#if (_WIN32_IE >= 0x0400)")

// IRunnableTask
//
//  IRunnable task is a *free threaded* interface.  It is used for creating
//  objects to be asynchronously executed on a background thread by a task
//  scheduler.  The task scheduler is free to call any method on the
//  IRunnable task on any thread as it sees fit (i.e. a task scheduler is not
//  guaranteed to only have a single background worker thread, nor is it
//  restricted to not call the IRunnableTask methods on the original queuing
//  thread).
//
// Note:
//
//  The Run() member is called by the scheduler to start the task executing.
//  If the task supports being suspended and has been signalled to do so
//  (via receiving a call from the scheduler to Suspend()), it should return
//  from Run() with a value of E_PENDING.  The task will then be held and
//  resumed by the scheduler at a later time by receiving a call to Resume()
//  (assuming it's not destroyed for some reason first).

// IRunnableTask convenient state values
cpp_quote("#define IRTIR_TASK_NOT_RUNNING   0")
cpp_quote("#define IRTIR_TASK_RUNNING       1")
cpp_quote("#define IRTIR_TASK_SUSPENDED     2")
cpp_quote("#define IRTIR_TASK_PENDING       3")
cpp_quote("#define IRTIR_TASK_FINISHED      4")

[
    uuid(85788d00-6807-11d0-b810-00c04fd706ec), // IID_IRunnableTask
    object,
    local
]
interface IRunnableTask : IUnknown
{
    HRESULT Run();
    HRESULT Kill(BOOL bWait);
    HRESULT Suspend();
    HRESULT Resume();
    ULONG   IsRunning();
};

// IPersistFolder2
[
    object,
    uuid(1AC3D9F0-175C-11d1-95BE-00609797EA4F),  // IID_IPersistFolder2
    pointer_default(unique),
]
interface IPersistFolder2 : IPersistFolder
{
    HRESULT GetCurFolder([out] PIDLIST_ABSOLUTE *ppidl);
};

typedef IPersistFolder2 *LPPERSISTFOLDER2;

cpp_quote("#endif")

cpp_quote("#if (_WIN32_IE >= 0x0500)")

cpp_quote("#define CSIDL_FLAG_PFTI_TRACKTARGET CSIDL_FLAG_DONT_VERIFY")

// DESCRIPTION: PERSIST_FOLDER_TARGET_INFO
//    This stucture is used for Folder Shortcuts which allow the shell to
// have a file system folder act like another area in the name space.
// One of pidlTargetFolder, szTargetParsingName, or csidl needs to
// specify the destination name space.
//
// pidlTargetFolder: This is a full pidl to the target folder.  Can be NULL in the IPersistFolder3::InitializeEx()
//                   call but not in the GetFolderTargetInfo() return structure.
// szTargetParsingName: Empty string if not specified. Ortherwise, it is the parsible name
//                       to the target.  This name can be parsed by IShellFolder::
//                       ParsedName() from the desktop.
// szNetworkProvider: Can be an empty string.  If not empty, it specifies the type of network
//                    provider that will be used when binding to the target.  This is used
//                    for performance optimizations for the WNet APIs.
// dwAttributes: -1 if not known.  These are the SFGAO_ flags for IShellFolder::GetAttributesOf()
// csidl: This is -1 if it's not used.  This can be used instead of pidlTargetFolder or
//        szTargetParsingName to indicate the TargetFolder.  See the list of CSIDL_ folders
//        below.  CSIDL_FLAG_PFTI_TRACKTARGET means that the IShellFolder's target folder
//        should change if the user changes the target of the underlying CSIDL value.
//        You can also pass CSIDL_FLAG_CREATE to indicate that the target folder
//        should be created if it does not exist.  No other CSIDL_FLAG_* values are supported.

cpp_quote("#include <pshpack8.h>")

#ifndef MAX_PATH
#define MAX_PATH 260
#endif

typedef struct _PERSIST_FOLDER_TARGET_INFO
{
    PIDLIST_ABSOLUTE  pidlTargetFolder;           // pidl for the folder we want to intiailize
    WCHAR         szTargetParsingName[MAX_PATH];  // optional parsing name for the target
    WCHAR         szNetworkProvider[MAX_PATH];    // optional network provider
    DWORD         dwAttributes;                   // optional FILE_ATTRIBUTES_ flags (-1 if not used)
    int           csidl;                          // optional folder index (SHGetFolderPath()) -1 if not used
} PERSIST_FOLDER_TARGET_INFO;

cpp_quote("#include <poppack.h>")


// DESCRIPTION: IPersistFolder3
//    This interface is implemented by an IShellFolder object that wants non-default
// handling of Folder Shortcuts.  In general, shell name space extensions should use
// pidlRoot (the alias pidl) as their location in the name space and pass it to public
// APIs, such as ShellExecute().  The one exception is that pidlTarget should be used
// when sending ChangeNotifies or registering to listen for change notifies
// (see SFVM_GETNOTIFY).
//
// InitializeEx: This method initializes an IShellFolder and specifies where
//               it is rooted in the name space.
//      pbc: May be NULL.
//      pidlRoot: This is the same parameter as IPersistFolder::Initialize(). Caller allocates
//                and frees this parameter.
//      ppfti: May be NULL, in which case this is the same as a call to IPersistFolder::Initialize().
//             Otherwise this is a Folder Shortcut and this structure specifies the target
//             folder and it's attributes.
// GetFolderTargetInfo: This is used by the caller to find information about
//             the folder shortcut.  This structure may not be initialized by the caller,
//             so the callee needs to initialize every member.  The callee allocates
//             pidlTargetFolder and the caller will free it.  Filling in pidlTargetFolder is
//             ALWAYS required.
[
    object,
    uuid(CEF04FDF-FE72-11d2-87A5-00C04F6837CF),  // IID_IPersistFolder3
    pointer_default(unique),
]
interface IPersistFolder3 : IPersistFolder2
{
    HRESULT InitializeEx([in] IBindCtx *pbc, [in] PCIDLIST_ABSOLUTE pidlRoot, [in] const PERSIST_FOLDER_TARGET_INFO *ppfti);
    HRESULT GetFolderTargetInfo([out] PERSIST_FOLDER_TARGET_INFO *ppfti);
};

cpp_quote("#endif")

[
    object,
    uuid(1079acfc-29bd-11d3-8e0d-00c04f6837d5),  // IID_IPersistIDList
    pointer_default(unique),
]
interface IPersistIDList : IPersist
{
    // sets or gets a fully qualifed idlist for an object
    HRESULT SetIDList([in] PCIDLIST_ABSOLUTE pidl);
    HRESULT GetIDList([out] PIDLIST_ABSOLUTE *ppidl);
};

[
    uuid(000214F2-0000-0000-C000-000000000046),
    object,
    pointer_default(unique)
]
interface IEnumIDList : IUnknown
{
    HRESULT Next(
        [in] ULONG celt,
        [out, size_is(celt), length_is(*pceltFetched)] PITEMID_CHILD *rgelt,
        [out] ULONG *pceltFetched);

    HRESULT Skip([in] ULONG celt);
    HRESULT Reset();
    HRESULT Clone([out] IEnumIDList **ppenum);
};

typedef IEnumIDList *LPENUMIDLIST;

[
    uuid(d0191542-7954-4908-bc06-b2360bbe45ba),
    object,
    pointer_default(unique)
]
interface IEnumFullIDList : IUnknown
{
    HRESULT Next(
        [in] ULONG celt,
        [out, size_is(celt), length_is(*pceltFetched)] PIDLIST_ABSOLUTE *rgelt,
        [out] ULONG *pceltFetched);

    HRESULT Skip([in] ULONG celt);
    HRESULT Reset();
    HRESULT Clone([out] IEnumFullIDList **ppenum);
}

// IShellFolder::GetDisplayNameOf/SetNameOf uFlags
typedef enum tagSHGDN
{
    SHGDN_NORMAL             = 0x0000,  // default (display purpose)
    SHGDN_INFOLDER           = 0x0001,  // displayed under a folder (relative)
    SHGDN_FOREDITING         = 0x1000,  // for in-place editing
    SHGDN_FORADDRESSBAR      = 0x4000,  // UI friendly parsing name (remove ugly stuff)
    SHGDN_FORPARSING         = 0x8000,  // parsing name for ParseDisplayName()
} SHGNO;
typedef DWORD SHGDNF;

// IShellFolder::EnumObjects grfFlags bits
typedef enum tagSHCONTF
{
    SHCONTF_FOLDERS             = 0x0020,   // only want folders enumerated (SFGAO_FOLDER)
    SHCONTF_NONFOLDERS          = 0x0040,   // include non folders
    SHCONTF_INCLUDEHIDDEN       = 0x0080,   // show items normally hidden
    SHCONTF_INIT_ON_FIRST_NEXT  = 0x0100,   // allow EnumObject() to return before validating enum
    SHCONTF_NETPRINTERSRCH      = 0x0200,   // hint that client is looking for printers
    SHCONTF_SHAREABLE           = 0x0400,   // hint that client is looking sharable resources (remote shares)
    SHCONTF_STORAGE             = 0x0800,   // include all items with accessible storage and their ancestors
    SHCONTF_WALKTREE            = 0x1000,   // enumerate subfolders recursively (pivoted views)
    SHCONTF_FASTITEMS           = 0x2000,   // hint that client is only interested in items that can be enumerated quickly
    SHCONTF_FLATLIST            = 0x4000,   // enumerate items as flat list even if folder is stacked
} SHCONT;
typedef DWORD SHCONTF;

// IShellFolder::CompareIDs lParam flags
//
//  SHCIDS_ALLFIELDS is a mask for lParam indicating that the shell folder
//  should first compare on the lParam column, and if that proves equal,
//  then perform a full comparison on all fields.  This flag is supported
//  if the IShellFolder supports IShellFolder2.
//
//  SHCIDS_CANONICALONLY is a mask for lParam indicating that the shell folder
//  that the caller doesn't care about proper sort order -- only equality matters.
//  (Most CompareIDs test for equality first, and in the case of inequality do
//  a UI sort.  This bit allows for a more efficient sort in the inequality case.)
//
//

cpp_quote("#define SHCIDS_ALLFIELDS        0x80000000L")
cpp_quote("#define SHCIDS_CANONICALONLY    0x10000000L")
cpp_quote("#define SHCIDS_BITMASK          0xFFFF0000L")
cpp_quote("#define SHCIDS_COLUMNMASK       0x0000FFFFL")

// IShellFolder::GetAttributesOf flags
// SFGAO_CANLINK: If this bit is set on an item in the shell folder, a
//            'Create Shortcut' menu item will be added to the File
//            menu and context menus for the item.  If the user selects
//            that command, your IContextMenu::InvokeCommand() will be called
//            with 'link'.
//                 That flag will also be used to determine if 'Create Shortcut'
//            should be added when the item in your folder is dragged to another
//            folder.
cpp_quote("#define SFGAO_CANCOPY           DROPEFFECT_COPY // Objects can be copied    (0x1)")
cpp_quote("#define SFGAO_CANMOVE           DROPEFFECT_MOVE // Objects can be moved     (0x2)")
cpp_quote("#define SFGAO_CANLINK           DROPEFFECT_LINK // Objects can be linked    (0x4)")
cpp_quote("#define SFGAO_STORAGE           0x00000008L     // supports BindToObject(IID_IStorage)")
cpp_quote("#define SFGAO_CANRENAME         0x00000010L     // Objects can be renamed")
cpp_quote("#define SFGAO_CANDELETE         0x00000020L     // Objects can be deleted")
cpp_quote("#define SFGAO_HASPROPSHEET      0x00000040L     // Objects have property sheets")
//         unused                          0x00000080L
cpp_quote("#define SFGAO_DROPTARGET        0x00000100L     // Objects are drop target")
cpp_quote("#define SFGAO_CAPABILITYMASK    0x00000177L")
//         unused                          0x00000200
//         unused                          0x00000400
//         unused                          0x00000800
//         unused                          0x00001000
cpp_quote("#define SFGAO_ENCRYPTED         0x00002000L     // object is encrypted (use alt color)")
cpp_quote("#define SFGAO_ISSLOW            0x00004000L     // 'slow' object")
cpp_quote("#define SFGAO_GHOSTED           0x00008000L     // ghosted icon")
cpp_quote("#define SFGAO_LINK              0x00010000L     // Shortcut (link)")
cpp_quote("#define SFGAO_SHARE             0x00020000L     // shared")
cpp_quote("#define SFGAO_READONLY          0x00040000L     // read-only")
cpp_quote("#define SFGAO_HIDDEN            0x00080000L     // hidden object")
cpp_quote("#define SFGAO_DISPLAYATTRMASK   0x000FC000L")
cpp_quote("#define SFGAO_FILESYSANCESTOR   0x10000000L     // may contain children with SFGAO_FILESYSTEM")
cpp_quote("#define SFGAO_FOLDER            0x20000000L     // support BindToObject(IID_IShellFolder)")
cpp_quote("#define SFGAO_FILESYSTEM        0x40000000L     // is a win32 file system object (file/folder/root)")
cpp_quote("#define SFGAO_HASSUBFOLDER      0x80000000L     // may contain children with SFGAO_FOLDER")
cpp_quote("#define SFGAO_CONTENTSMASK      0x80000000L")
cpp_quote("#define SFGAO_VALIDATE          0x01000000L     // invalidate cached information")
cpp_quote("#define SFGAO_REMOVABLE         0x02000000L     // is this removeable media?")
cpp_quote("#define SFGAO_COMPRESSED        0x04000000L     // Object is compressed (use alt color)")
cpp_quote("#define SFGAO_BROWSABLE         0x08000000L     // supports IShellFolder, but only implements CreateViewObject() (non-folder view)")
cpp_quote("#define SFGAO_NONENUMERATED     0x00100000L     // is a non-enumerated object")
cpp_quote("#define SFGAO_NEWCONTENT        0x00200000L     // should show bold in explorer tree")
cpp_quote("#define SFGAO_CANMONIKER        0x00400000L     // defunct")
cpp_quote("#define SFGAO_HASSTORAGE        0x00400000L     // defunct")
cpp_quote("#define SFGAO_STREAM            0x00400000L     // supports BindToObject(IID_IStream)")
cpp_quote("#define SFGAO_STORAGEANCESTOR   0x00800000L     // may contain children with SFGAO_STORAGE or SFGAO_STREAM")
cpp_quote("#define SFGAO_STORAGECAPMASK    0x70C50008L     // for determining storage capabilities, ie for open/save semantics")

typedef ULONG SFGAOF;

//      passed to ISF::BindToObject() via IBindCtx::RegisterObjectParam()
// * no interface support required on object param
// If this param is passed to filefldr in a request for IPropertySetStorage or IPropertyStore, the resulting storage
//  will also include properties that the folder knows about, and aren't specified in the file's property handler
//  Pass this if you want innate properties like "size" and "filename" in addition to document properties.
cpp_quote("#define STR_BIND_INCLUDE_ALL_DETAILS   L\"Include All Details\"")

//      passed to ISF::BindToObject() via IBindCtx::RegisterObjectParam()
// * no interface support required on object param
// If this param is passed to filefldr in a request for IPropertySetStorage or IPropertyStore, the resulting storage
//  may be implemented as secondary NTFS streams. This allows file types without property stores to carry arbitrary
//  properties, but is not as robust since secondary NTFS streams will be lost on copy to FAT, etc.
cpp_quote("#define STR_BIND_ALLOW_NTFS_PROPSTORE   L\"Allow NTFS PropertyStore\"")

//      passed to ISF::BindToObject() via IBindCtx::RegisterObjectParam()
// * no interface support required on object param
// Used to bind to a cached read only version of the IPropertyStore if is supported.
// Any write methods of the interface requested will fail.
cpp_quote("#define STR_BIND_CACHED_READ_ONLY      L\"Get Cached ReadOnly Interface\"")

//      passed to ISF::BindToObject() via IBindCtx::RegisterObjectParam()
// * no interface support required on object param
// Used to bind to an IPropertyStore that will delay the creation of the real property store until
// the first read / write. 
cpp_quote("#define STR_BIND_DELAY_PROPSTORE_CREATION L\"Delay property store creation\"")

// passed to ISF::BindToObject() via IBindCtx::RegisterObjectParam()
// * no interface support required on object param
// If this param is passed to filefldr in a request for IPropertySetStorage or IPropertyStore, the resulting storage
//  will also include properties for files that are offline (FILE_ATTRIBUTE_OFFLINE)
cpp_quote("#define STR_BIND_INCLUDE_OFFLINE_DETAILS   L\"Include Offline Details\"")

//      passed to ISF::ParseDisplayName() or ISF::BindToObject() via IBindCtx::RegisterObjectParam()
// * IPersist must be supported by the ObjectParam
// the CLSID returned by IPersist::GetCLSID() should be skipped
// in the binding process. used to avoid loops or to allow delegation to
// base name space functionality. see SHSkipJunction()
cpp_quote("#define STR_SKIP_BINDING_CLSID      L\"Skip Binding CLSID\"")

//      passed to SHGetDesktopFolder()->ParseDisplayName() via IBindCtx::RegisterObjectParam()
// * no interface support required on object param
// instructing to prefer folder support for URLs.  specifically used by the common
// dialog to make it use the DAV NP when parsing http: URLs.
cpp_quote("#define STR_PARSE_PREFER_FOLDER_BROWSING     L\"Parse Prefer Folder Browsing\"")

//      passed to SHGetDesktopFolder()->ParseDisplayName() via IBindCtx::RegisterObjectParam()
// instructing to fail parsing relative paths.  only succeeds for fully qualified paths/urls.
// * no interface support required on object param
//
//      eg. even if "foo.txt" is a child of the desktop, it will still fail
//  but it will succeed for "C:\Documents and Settings\Username\Desktop\foo.txt"
cpp_quote("#define STR_DONT_PARSE_RELATIVE              L\"Don't Parse Relative\"")

//      passed to SHGetDesktopFolder()->ParseDisplayName() via IBindCtx::RegisterObjectParam()
// to try translate from a full file system pidl to a alias to that pidl, if available.
// * no interface support required on object param
//
//      eg.  if you pass the following path "C:\Documents and Settings\Username\Desktop\foo.txt"
// if TRANSLATE is SET result is: [foo.txt] (the alias for the desktop being an empty pidl)
// if TRANSLATE is NOT SET result is: [CLSID_MyComputer][c:\][Documents and Settings][Username][Desktop][foo.txt].
cpp_quote("#define STR_PARSE_TRANSLATE_ALIASES          L\"Parse Translate Aliases\"")

//      passed to SHGetDesktopFolder()->ParseDisplayName() via IBindCtx::RegisterObjectParam()
// to disable the cache of network resources when parsing a name.  The cache is still
// populated with the results of the parse, however we skip the initial query.
cpp_quote("#define STR_PARSE_SKIP_NET_CACHE             L\"Skip Net Resource Cache\"")

//      passed to IPersistFolder3->Initialize() via IBindCtx::RegisterObjectParam()
// Instructs the folder to track the location of the CLSID.  Currently dbfolder uses this to track the pivot of the
// regitem folder that aggregates it.
cpp_quote("#define STR_TRACK_CLSID                      L\"Track the CLSID\"")

//      passed to IShellFolder->ParseDisplayName to enable the SharePoint support
// without this information we will not special case these servers.
cpp_quote("#define STR_SHAREPOINT_SUPPORT               L\"Parse SharePoints in Shell\"")

//      passed to IPersistHistory::LoadHistory() to enable loading the history from a stream
// for an internal navigaton.  An internal navigation is a navigation within the same view.
cpp_quote("#define STR_INTERNAL_NAVIGATE                L\"Internal Navigation\"")

//      passed to IShellFolder3::EnumObjectsEx() to enumerate the sibling of the given IDList.  For example, the siblings
// of a stack item can be enumerated from a non-stacked folder by passing in the stack item.
cpp_quote("#define STR_ENUM_BY_IDLIST                  L\"Enumerate with respect to the IDList\"")

interface IShellFolder;
[
    uuid(000214E6-0000-0000-C000-000000000046),
    object,
    pointer_default(unique)
]

interface IShellFolder : IUnknown
{
    HRESULT ParseDisplayName(
        [in] HWND hwnd,
        [in] LPBC pbc,
        [in, string] LPOLESTR pszDisplayName,
        [out] ULONG *pchEaten,
        [out] PIDLIST_RELATIVE *ppidl,
        [in, out, unique] ULONG *pdwAttributes);

    HRESULT EnumObjects(
        [in] HWND hwnd,
        [in] SHCONTF grfFlags,
        [out] IEnumIDList **ppenumIDList);

    //  returns an instance of a sub-folder which is specified by the IDList (pidl).
    HRESULT BindToObject(
        [in] PCUIDLIST_RELATIVE pidl,
        [in] LPBC pbc,
        [in] REFIID riid,
        [out, iid_is(riid)] void **ppv);

    HRESULT BindToStorage(
        [in] PCUIDLIST_RELATIVE pidl,
        [in] LPBC pbc,
        [in] REFIID riid,
        [out, iid_is(riid)] void **ppv);

    // compares two IDLists and returns the result. The shell
    // explorer always passes 0 as lParam, which indicates 'sort by name'.
    // It should return 0 (as CODE of the scode), if two id indicates the
    // same object; negative value if pidl1 should be placed before pidl2;
    // positive value if pidl2 should be placed before pidl1.
    // use the macro ResultFromShort() to extract the result comparison
    // it deals with the casting and type conversion issues for you
    HRESULT CompareIDs(
        [in] LPARAM lParam,
        [in] PCUIDLIST_RELATIVE pidl1,
        [in] PCUIDLIST_RELATIVE pidl2);

    //  creates a view object of the folder itself. The view
    //  object is a difference instance from the shell folder object.
    //   'hwndOwner' can be used  as the owner window of its dialog box or
    //  menu during the lifetime of the view object.
    //  This member function should always create a new
    //  instance which has only one reference count. The explorer may create
    //  more than one instances of view object from one shell folder object
    //  and treat them as separate instances.
    HRESULT CreateViewObject(
        [in] HWND hwndOwner,
        [in] REFIID riid,
        [out, iid_is(riid)] void **ppv);

    //  returns the attributes of specified objects in that
    //  folder. 'cidl' and 'apidl' specifies objects. 'apidl' contains only
    //  simple IDLists. The explorer initializes *prgfInOut with a set of
    //  flags to be evaluated. The shell folder may optimize the operation
    //  by not returning unspecified flags.
    HRESULT GetAttributesOf(
        [in] UINT cidl,
        [in, size_is(cidl)] PCUITEMID_CHILD_ARRAY apidl,
        [in, out] SFGAOF * rgfInOut);

    //  creates a UI object to be used for specified objects.
    //  The shell explorer passes either IID_IDataObject (for transfer operation)
    //  or IID_IContextMenu (for context menu operation) as riid.
    HRESULT GetUIObjectOf(
        [in] HWND hwndOwner,
        [in] UINT cidl,
        [in, size_is(cidl)] PCUITEMID_CHILD_ARRAY apidl,
        [in] REFIID riid,
        [in, out, unique] UINT * rgfReserved,
        [out, iid_is(riid)] void **ppv);

    //  returns the display name of the specified object.
    //  If the ID contains the display name (in the locale character set),
    //  it returns the offset to the name. Otherwise, it returns a pointer
    //  to the display name string (UNICODE), which is allocated by the
    //  task allocator, or fills in a buffer.
    HRESULT GetDisplayNameOf(
        [in] PCUITEMID_CHILD pidl,
        [in] SHGDNF uFlags,
        [out] STRRET *pName);

    //  sets the display name of the specified object.
    //  If it changes the ID as well, it returns the new ID which is
    //  alocated by the task allocator.
    HRESULT SetNameOf(
        [in] HWND hwnd,
        [in] PCUITEMID_CHILD pidl,
        [in, string] LPCOLESTR pszName,
        [in] SHGDNF uFlags,
        [out] PITEMID_CHILD *ppidlOut);
};

typedef IShellFolder * LPSHELLFOLDER;


cpp_quote("#if (_WIN32_IE >= 0x0500)")

typedef struct tagEXTRASEARCH
{
    GUID    guidSearch;
    WCHAR   wszFriendlyName[80];
    WCHAR   wszUrl[2084];
} EXTRASEARCH, *LPEXTRASEARCH;

typedef struct IEnumExtraSearch *LPENUMEXTRASEARCH;

interface IShellFolder2;    // forward

[
    uuid(0E700BE1-9DB6-11d1-A1CE-00C04FD75D13),
    object,
    pointer_default(unique)
]
interface IEnumExtraSearch : IUnknown
{
    HRESULT Next(
        [in] ULONG celt,
        [out, size_is(celt), length_is(*pceltFetched)] EXTRASEARCH *rgelt,
        [out] ULONG *pceltFetched);

    HRESULT Skip([in] ULONG celt);
    HRESULT Reset();
    HRESULT Clone([out] IEnumExtraSearch **ppenum);
};

// IShellFolder2::GetDefaultColumnState values

typedef [v1_enum] enum tagSHCOLSTATE
{
    SHCOLSTATE_TYPE_STR      = 0x00000001,
    SHCOLSTATE_TYPE_INT      = 0x00000002,
    SHCOLSTATE_TYPE_DATE     = 0x00000003,
    SHCOLSTATE_TYPEMASK      = 0x0000000F,
    SHCOLSTATE_ONBYDEFAULT   = 0x00000010,   // should on by default in details view
    SHCOLSTATE_SLOW          = 0x00000020,   // will be slow to compute, do on a background thread
    SHCOLSTATE_EXTENDED      = 0x00000040,   // provided by a handler, not the folder
    SHCOLSTATE_SECONDARYUI   = 0x00000080,   // not displayed in context menu, but listed in the "More..." dialog
    SHCOLSTATE_HIDDEN        = 0x00000100,   // not displayed in the UI
    SHCOLSTATE_PREFER_VARCMP = 0x00000200,   // VarCmp() (with folderness test) produces same result as CompareIDs()
    SHCOLSTATE_VIEWONLY      = 0x00000800,   // only displayed in the UI
    SHCOLSTATE_FIXED_WIDTH   = 0x00001000,   // Can't resize the column
    SHCOLSTATE_NODPISCALE    = 0x00002000,   // Width is the same in all DPIs
    SHCOLSTATE_FIXED_RATIO   = 0x00004000,   // Fixed width augments with height
    SHCOLSTATE_DISPLAYMASK   = 0x0000F000,   // To filter out new display flags
} SHCOLSTATE;

typedef DWORD SHCOLSTATEF;

typedef PROPERTYKEY SHCOLUMNID;
typedef const SHCOLUMNID* LPCSHCOLUMNID;

[
    uuid(93F2F68C-1D1B-11d3-A30E-00C04F79ABD1),
    object,
    pointer_default(unique)
]
interface IShellFolder2 : IShellFolder
{
    // Returns the guid of the search that is to be invoked when user clicks
    // on the search toolbar button
    HRESULT GetDefaultSearchGUID([out] GUID *pguid);
    // gives an enumerator of the searches to be added to the search menu
    HRESULT EnumSearches([out] IEnumExtraSearch **ppenum);
    HRESULT GetDefaultColumn([in] DWORD dwRes, [out] ULONG *pSort, [out] ULONG *pDisplay);
    // return SHCOLSTATE_ values
    HRESULT GetDefaultColumnState([in] UINT iColumn, [out] SHCOLSTATEF *pcsFlags);
    HRESULT GetDetailsEx([in] PCUITEMID_CHILD pidl, [in] const SHCOLUMNID *pscid, [out] VARIANT *pv);
    HRESULT GetDetailsOf([in] PCUITEMID_CHILD pidl, [in]UINT iColumn, [out] SHELLDETAILS *psd);
    HRESULT MapColumnToSCID([in] UINT iColumn, [in] SHCOLUMNID *pscid);
};

cpp_quote("#endif // _WIN32_IE >= 0x0500)")

//
// FOLDERSETTINGS is a data structure that explorer passes from one folder
// view to another, when the user is browsing. It calls ISV::GetCurrentInfo
// member to get the current settings and pass it to ISV::CreateViewWindow
// to allow the next folder view 'inherit' it. These settings assumes a
// particular UI (which the shell's folder view has), and shell extensions
// may or may not use those settings.

typedef char * LPVIEWSETTINGS;

// NB Bitfields.
// FWF_DESKTOP implies NOCLIENTEDGE/NOSCROLL

typedef [v1_enum] enum tagFOLDERFLAGS
{
    FWF_AUTOARRANGE =       0x00000001,
    FWF_ABBREVIATEDNAMES =  0x00000002,
    FWF_SNAPTOGRID =        0x00000004,
    FWF_MIL              =  0x00000008,     // MIL View
    FWF_BESTFITWINDOW =     0x00000010,
    FWF_DESKTOP =           0x00000020,
    FWF_SINGLESEL =         0x00000040,
    FWF_NOSUBFOLDERS =      0x00000080,
    FWF_TRANSPARENT  =      0x00000100,
    FWF_NOCLIENTEDGE =      0x00000200,
    FWF_NOSCROLL     =      0x00000400,
    FWF_ALIGNLEFT    =      0x00000800,
    FWF_NOICONS      =      0x00001000,
    FWF_SHOWSELALWAYS =     0x00002000,
    FWF_NOVISIBLE    =      0X00004000,
    FWF_SINGLECLICKACTIVATE=0x00008000,     // TEMPORARY -- NO UI FOR THIS
    FWF_NOWEBVIEW =         0x00010000,
    FWF_HIDEFILENAMES =     0x00020000,
    FWF_CHECKSELECT =       0x00040000,
    FWF_NOENUMREFRESH =     0x00080000,
    FWF_NOGROUPING =        0x00100000,
    FWF_FULLROWSELECT =     0x00200000,
    FWF_PREVIEWPANE =       0x00400000,
    FWF_NOFILTERS =         0x00800000,
    FWF_NOPERSISTORDER =    0x01000000,     // Don't persist the order in the view state
    FWF_NOCOLUMNHEADER =    0x02000000,     // don't show column header if not in details mode
    FWF_SHOWNUMORDER =      0x04000000,
    FWF_EXTENDEDTILES =     0x08000000,
    FWF_3D =                0x10000000,
    FWF_PREVIEWMINIMODE =   0x20000000,
    FWF_AUTOCHECKSELECT =   0x40000000,
    FWF_NOAUTOSIZECOLUMNS = 0x80000000,    // Never turn on auto-sizing of columns
} FOLDERFLAGS;


typedef [v1_enum] enum tagFOLDERVIEWMODE
{
    FVM_FIRST =             1,
    FVM_ICON =              1,
    FVM_SMALLICON =         2,
    FVM_LIST =              3,
    FVM_DETAILS =           4,
    FVM_THUMBNAIL =         5,
    FVM_TILE =              6,
    FVM_THUMBSTRIP =        7,
    FVM_CAROUSEL =          8,
    FVM_PANORAMA =          9,
    FVM_LAST =              9,
} FOLDERVIEWMODE;

typedef [v1_enum] enum tagFOLDERLOGICALVIEWMODE
{
    FLVM_FIRST =            1,
    FLVM_DETAILS =          1,
    FLVM_TILES =            2,
    FLVM_ICONS =            3,
    FLVM_LAST =             3,
} FOLDERLOGICALVIEWMODE;

// type that is passed during SFVM_GETSUPPORTEDVIEWFLAGS

typedef [v1_enum] enum tagSUPPORTEDVIEWFLAGS
{
    SVF_CAROUSEL =          0x00000001,
    SVF_PANORAMA =          0x00000002,
    } SUPPORTEDVIEWFLAGS;

typedef struct tagFOLDERSETTINGS
{
    UINT ViewMode;       // View mode (FOLDERVIEWMODE values)
    UINT fFlags;         // View options (FOLDERFLAGS bits)
} FOLDERSETTINGS;

typedef FOLDERSETTINGS *LPFOLDERSETTINGS;
typedef const FOLDERSETTINGS * LPCFOLDERSETTINGS;
typedef FOLDERSETTINGS *PFOLDERSETTINGS;

//
// IShellView::GetWindow(phwnd)
//
//   Inherited from IOleWindow::GetWindow.
//
//
// IShellView::ContextSensitiveHelp(fEnterMode)
//
//   Inherited from IOleWindow::ContextSensitiveHelp.
//
//
// IShellView::TranslateAccelerator(lpmsg)
//
//   Similar to IOleInPlaceActiveObject::TranlateAccelerator. The explorer
//  calls this function BEFORE any other translation. Returning S_OK
//  indicates that the message was translated (eaten) and should not be
//  translated or dispatched by the explorer.
//
//
// IShellView::EnableModeless(fEnable)
//   Similar to IOleInPlaceActiveObject::EnableModeless.
//
//
// IShellView::UIActivate(uState)
//
//   The explorer calls this member function whenever the activation
//  state of the view window is changed by a certain event that is
//  NOT caused by the shell view itself.
//
//   SVUIA_DEACTIVATE will be passed when the explorer is about to
//  destroy the shell view window; the shell view is supposed to remove
//  all the extended UIs (typically merged menu and modeless popup windows).
//
//   SVUIA_ACTIVATE_NOFOCUS will be passsed when the shell view is losing
//  the input focus or the shell view has been just created without the
//  input focus; the shell view is supposed to set menuitems appropriate
//  for non-focused state (no selection specific items should be added).
//
//   SVUIA_ACTIVATE_FOCUS will be passed when the explorer has just
//  created the view window with the input focus; the shell view is
//  supposed to set menuitems appropriate for focused state.
//
//   SVUIA_INPLACEACTIVATE(new) will be passed when the shell view is opened
//  within an ActiveX control, which is not a UI active. In this case,
//  the shell view should not merge menus or put toolbas. To be compatible
//  with Win95 client, we don't pass this value unless the view supports
//  IShellView2.
//
//   The shell view should not change focus within this member function.
//  The shell view should not hook the WM_KILLFOCUS message to remerge
//  menuitems. However, the shell view typically hook the WM_SETFOCUS
//  message, and re-merge the menu after calling IShellBrowser::
//  OnViewWindowActivated.
//
//   One of the ACTIVATE / INPLACEACTIVATE messages will be sent when
//  the view window becomes the currently displayed view.  On Win95 systems,
//  this will happen immediately after the CreateViewWindow call.  On IE4, Win98,
//  and NT5 systems this may happen when the view reports it is ready (if the
//  IShellView supports async creation).  This can be used as a hint as to when
//  to make your view window visible.  Note: the Win95/Win98/NT4 common dialogs
//  do not send either of these on creation.
//
//
// IShellView::Refresh()
//
//   The explorer calls this member when the view needs to refresh its
//  contents (such as when the user hits F5 key).
//
//
// IShellView::CreateViewWindow
//
//   This member creates the view window (right-pane of the explorer or the
//  client window of the folder window).
//
//
// IShellView::DestroyViewWindow
//
//   This member destroys the view window.
//
//
// IShellView::GetCurrentInfo
//
//   This member returns the folder settings.
//
//
// IShellView::AddPropertySHeetPages
//
//   The explorer calls this member when it is opening the option property
//  sheet. This allows the view to add additional pages to it.
//
//
// IShellView::SaveViewState()
//
//   The explorer calls this member when the shell view is supposed to
//  store its view settings. The shell view is supposed to get a view
//  stream by calling IShellBrowser::GetViewStateStream and store the
//  current view state into that stream.
//
//
// IShellView::SelectItem(pidlItem, uFlags)
//
//   The explorer calls this member to change the selection state of
//  item(s) within the shell view window.  If pidlItem is NULL and uFlags
//  is SVSI_DESELECTOTHERS, all items should be deselected.
//

//
// shellview select item flags
//
cpp_quote("#define SVSI_DESELECT       0x00000000")
cpp_quote("#define SVSI_SELECT         0x00000001")
cpp_quote("#define SVSI_EDIT           0x00000003  // includes select")
cpp_quote("#define SVSI_DESELECTOTHERS 0x00000004")
cpp_quote("#define SVSI_ENSUREVISIBLE  0x00000008")
cpp_quote("#define SVSI_FOCUSED        0x00000010")
cpp_quote("#define SVSI_TRANSLATEPT    0x00000020")
cpp_quote("#define SVSI_SELECTIONMARK  0x00000040")
cpp_quote("#define SVSI_POSITIONITEM   0x00000080")
cpp_quote("#define SVSI_CHECK          0x00000100")
cpp_quote("#define SVSI_NOSTATECHANGE  0x80000000")
typedef UINT SVSIF;

//
// shellview get item object flags
//
[v1_enum] enum tagSVGIO
{
    SVGIO_BACKGROUND        = 0x00000000,
    SVGIO_SELECTION         = 0x00000001,
    SVGIO_ALLVIEW           = 0x00000002,
    SVGIO_CHECKED           = 0x00000003,
    SVGIO_TYPE_MASK         = 0x0000000F,
    SVGIO_FLAG_VIEWORDER    = 0x80000000,
};
typedef int SVGIO;

//
// uState values for IShellView::UIActivate
//
typedef [v1_enum] enum tagSVUIA_STATUS
{
    SVUIA_DEACTIVATE       = 0,
    SVUIA_ACTIVATE_NOFOCUS = 1,
    SVUIA_ACTIVATE_FOCUS   = 2,
    SVUIA_INPLACEACTIVATE  = 3          // new flag for IShellView2
} SVUIA_STATUS;

//  this is to handle name collisions
cpp_quote("#ifdef _FIX_ENABLEMODELESS_CONFLICT")
cpp_quote("#define    EnableModeless EnableModelessSV")
cpp_quote("#endif")

//
//  this is so that all the implementations still get the function pointer.
//  and midl wont complain about the data type
//
cpp_quote("#ifdef _NEVER_")
typedef LPARAM LPFNSVADDPROPSHEETPAGE;
cpp_quote("#else //!_NEVER_")
cpp_quote("#include <prsht.h>")
cpp_quote("typedef LPFNADDPROPSHEETPAGE LPFNSVADDPROPSHEETPAGE;")
cpp_quote("#endif //_NEVER_")

interface IShellBrowser;

[
    uuid(000214E3-0000-0000-C000-000000000046),
    object,
    pointer_default(unique)
]
interface IShellView : IOleWindow
{
    HRESULT TranslateAccelerator([in] MSG *pmsg);
    HRESULT EnableModeless([in] BOOL fEnable);
    HRESULT UIActivate([in] UINT uState);
    HRESULT Refresh();
    HRESULT CreateViewWindow(
        [in] IShellView *psvPrevious,
        [in] LPCFOLDERSETTINGS pfs,
        [in] IShellBrowser *psb,
        [in] RECT *prcView,
        [out] HWND *phWnd);

    HRESULT DestroyViewWindow();

    HRESULT GetCurrentInfo([out] LPFOLDERSETTINGS pfs);

    [local] HRESULT AddPropertySheetPages(
        [in] DWORD dwReserved,
        [in] LPFNSVADDPROPSHEETPAGE pfn,
        [in] LPARAM lparam);

    HRESULT SaveViewState();

    HRESULT SelectItem(
        [in] PCUITEMID_CHILD pidlItem,
        [in] SVSIF uFlags);

    HRESULT GetItemObject(
        [in] UINT uItem,
        [in] REFIID riid,
        [out, iid_is(riid)] void **ppv);

typedef IShellView *LPSHELLVIEW;
};

[
    uuid(88E39E80-3578-11CF-AE69-08002B2E1262),
    object,
    pointer_default(unique)
]
interface IShellView2 :  IShellView
{
typedef GUID SHELLVIEWID;

cpp_quote("#define SV2GV_CURRENTVIEW ((UINT)-1)")
cpp_quote("#define SV2GV_DEFAULTVIEW ((UINT)-2)")
//
//  NOTE if the cbSize param is ever updated,")
//  then there will have to be custom [wire_marshal]")
//  implementation to support it")
//
cpp_quote("#include <pshpack8.h>")
typedef struct _SV2CVW2_PARAMS
{
    DWORD cbSize;

    IShellView *psvPrev;
    LPCFOLDERSETTINGS pfs;
    IShellBrowser *psbOwner;
    RECT *prcView;
    SHELLVIEWID const *pvid;
    HWND hwndView;

} SV2CVW2_PARAMS, *LPSV2CVW2_PARAMS;

cpp_quote("#include <poppack.h>")   // Return to byte packing

    HRESULT GetView(
        [in, out] SHELLVIEWID* pvid,
        [in] ULONG uView);

    HRESULT CreateViewWindow2(
        [in] LPSV2CVW2_PARAMS lpParams);

    HRESULT HandleRename(
        [in] PCUITEMID_CHILD pidlNew);

    HRESULT SelectAndPositionItem(
        [in] PCUITEMID_CHILD pidlItem,
        [in] UINT uFlags,
        [in, unique] POINT *ppt);
};

[
    uuid(D926E764-B7F6-4992-BEAE-4B587CF46223),
    object,
    pointer_default(unique)
]
interface IShellView3 :  IShellView2
{

[v1_enum] enum tagSV3CVW3
{
    SV3CVW3_NONINTERACTIVE                 = 0x00000001,    // Instead of bringing up UI, fail silently.
};

typedef DWORD SV3CVW3_FLAGS;

    HRESULT CreateViewWindow3([in] IShellView *psvPrev, [in] LPCFOLDERSETTINGS pfs, [in] IShellBrowser *psbOwner, [in] RECT *prcView, [in] SHELLVIEWID const *pvid,
                              [in] SV3CVW3_FLAGS dwFlags, [out] HWND *phwndView);

};

[
    uuid(7b3a0889-72c2-4b28-a41d-e3c8e1266f84),
    object,
    pointer_default(unique)
]
interface IShellViewWithFrame : IUnknown
{
    HRESULT ShouldUseFrame();
    HRESULT GetModuleCount([out] UINT *pcModules);
    HRESULT GetModuleAt([in] UINT nIndex, [out] BSTR *pbstrAssembly, [out] BSTR *pbstrClass);
};

[
    uuid(cde725b0-ccc9-4519-917e-325d72fab4ce),
    object,
    pointer_default(unique)
]
interface IFolderView : IUnknown
{
    HRESULT GetCurrentViewMode([in, out] UINT *pViewMode);
    HRESULT SetCurrentViewMode([in] UINT ViewMode);

    HRESULT GetFolder([in] REFIID riid, [out, iid_is(riid)] void **ppv);

    HRESULT Item([in] int iItemIndex, [out] PITEMID_CHILD *ppidl);

    HRESULT ItemCount([in] UINT uFlags,[out] int *pcItems);
    HRESULT Items([in] UINT uFlags,[in] REFIID riid, [out, iid_is(riid)] void **ppv);

    HRESULT GetSelectionMarkedItem([out] int *piItem);
    HRESULT GetFocusedItem([out] int *piItem);

    HRESULT GetItemPosition([in] PCUITEMID_CHILD pidl, [out] POINT* ppt);
    HRESULT GetSpacing([in, out, ptr] POINT* ppt);
    HRESULT GetDefaultSpacing([out] POINT* ppt);
    HRESULT GetAutoArrange();

    // like IShellView::SelectItem() by index
    HRESULT SelectItem([in] int iItem, [in] DWORD dwFlags);
    HRESULT SelectAndPositionItems([in] UINT cidl, [in, size_is(cidl)] PCUITEMID_CHILD_ARRAY apidl, [in, ptr, size_is(cidl)] POINT* apt, [in] DWORD dwFlags);
};

cpp_quote("#define SID_SFolderView IID_IFolderView    // folder view, usually IFolderView")


cpp_quote("#if (_WIN32_IE >= 0x0500)")

typedef [v1_enum] enum tagSORTDIRECTION
{
    SORT_DESCENDING = -1,
    SORT_ASCENDING = 1
} SORTDIRECTION;

typedef struct tagSORTCOLUMN
{
    PROPERTYKEY   propkey;
    SORTDIRECTION Direction;
} SORTCOLUMN;

typedef [v1_enum] enum tagFOLDERVIEWWATERMARKFLAGS
{
    FVWF_DEFAULT    = 0x00000000,     // Windows XP behavior
    FVWF_ALPHABLEND = 0x00000001,     // alpha blend the bitmap, assumed 24-bit color + 8-bit alpha
} FOLDERVIEWWATERMARKFLAGS;

cpp_quote("#define FVST_EMPTYTEXT ((UINT)0)")
[
    uuid(9A606F49-DBA2-4989-B6E4-48F36C3E211A),
    object,
    pointer_default(unique)
]
interface IFolderView2 : IFolderView
{
    [helpstring("Synchronously groups the view by propkey")]
    HRESULT SetGroupBy([in] REFPROPERTYKEY propkey);
    HRESULT GetGroupBy([out] PROPERTYKEY* pkey);
    HRESULT GetViewProperty([in] PCUITEMID_CHILD pidl, [in] REFPROPERTYKEY propkey, [out] PROPVARIANT *ppropvar);
    HRESULT SetViewProperty([in] PCUITEMID_CHILD pidl, [in] REFPROPERTYKEY propkey, [in] const PROPVARIANT *ppropvar);
    HRESULT SetTileViewProperties([in] PCUITEMID_CHILD pidl, [in] LPCWSTR pszPropList);
    HRESULT SetExtendedTileViewProperties([in] PCUITEMID_CHILD pidl, [in] LPCWSTR pszPropList);
    HRESULT SetText([in] UINT ifvri, [in] LPCOLESTR pwszText);
    HRESULT GetIconSize([out] int* piImageSize);
    HRESULT SetIconSize([in] int iImageSize);
    HRESULT GetCurrentFolderFlags([out] DWORD *pdwFlags);
    HRESULT SetCurrentFolderFlags([in] DWORD dwMask, [in] DWORD dwFlags);
    HRESULT GetSortColumnCount([out]int *pcColumns);
    HRESULT GetSortColumns([out, size_is(cColumns)] SORTCOLUMN *rgSortColumns, [in] int cColumns);
    [helpstring("Set the columns to be sort by and sorts synchronously")]
    HRESULT SetSortColumns([in, size_is(cColumns)] const SORTCOLUMN *rgSortColumns, [in] int cColumns);
    HRESULT GetVisibleItem([in] int iStart, [out] int *piItem);
    HRESULT GetSelectedItem([in] int iStart, [out] int *piItem);
    HRESULT SetRedraw([in] BOOL bRedrawOn);
    [helpstring("Sets the watermark. fwvf is one of FVWF_*.")]
    HRESULT SetWatermark([in] HBITMAP hbmp, [in] FOLDERVIEWWATERMARKFLAGS fvwf);
    HRESULT SetTextColor([in] COLORREF crBackground, [in] COLORREF crForeground);
    [helpstring("Gets the selection state including check state.  Same as the flags for IFolderView::SelectAndPositionItems")]
    HRESULT GetSelectionState([in] PCUITEMID_CHILD pidl, [out] DWORD *pdwFlags);
};

cpp_quote("#endif // (_WIN32_IE >= 0x0500)")



//-------------------------------------------------------------------------
// ICommDlgBrowser interface
//
//  ICommDlgBrowser interface is the interface that is provided by the new
// common dialog window to hook and modify the behavior of IShellView.  When
// a default view is created, it queries its parent IShellBrowser for the
// ICommDlgBrowser interface.  If supported, it calls out to that interface
// in several cases that need to behave differently in a dialog.
//
// Member functions:
//
//  ICommDlgBrowser::OnDefaultCommand()
//    Called when the user double-clicks in the view or presses Enter.  The
//   browser should return S_OK if it processed the action itself, S_FALSE
//   to let the view perform the default action.
//
//  ICommDlgBrowser::OnStateChange(ULONG uChange)
//    Called when some states in the view change.  'uChange' is one of the
//   CDBOSC_* values.  This call is made after the state (selection, focus,
//   etc) has changed.  There is no return value.
//
//  ICommDlgBrowser::IncludeObject(PCUITEMID_CHILD pidl)
//    Called when the view is enumerating objects.  'pidl' is a relative
//   IDLIST.  The browser should return S_OK to include the object in the
//   view, S_FALSE to hide it
//
//-------------------------------------------------------------------------

cpp_quote("#define CDBOSC_SETFOCUS     0x00000000")
cpp_quote("#define CDBOSC_KILLFOCUS    0x00000001")
cpp_quote("#define CDBOSC_SELCHANGE    0x00000002")
cpp_quote("#define CDBOSC_RENAME       0x00000003")
cpp_quote("#define CDBOSC_STATECHANGE  0x00000004")

[
    uuid(000214F1-0000-0000-C000-000000000046),
    object,
    pointer_default(unique)
]
interface ICommDlgBrowser : IUnknown
{
    HRESULT OnDefaultCommand([in] IShellView *ppshv);
    HRESULT OnStateChange([in] IShellView *ppshv, [in] ULONG uChange);
    HRESULT IncludeObject([in] IShellView *ppshv, [in] PCUITEMID_CHILD pidl);
};

typedef ICommDlgBrowser * LPCOMMDLGBROWSER;

//-------------------------------------------------------------------------
// ICommDlgBrowser2 interface
//
// Member functions:
//
//  ICommDlgBrowser2::Notify(IShellView *pshv, DWORD dwNotfyType)
//   Called when the view is wants to notify common dialog when an event
//  occurrs.
//
//  CDB2N_CONTEXTMENU_START indicates the context menu has started.
//  CDB2N_CONTEXTMENU_DONE  indicates the context menu has completed.
//
//  ICommDlgBrowser2::GetDefaultMenuText(IShellView *pshv,
//                                      WCHAR *pszText, INT cchMax)
//   Called when the view wants to get the default context menu text.
//  pszText points to buffer and cchMax specifies the size of the
//  buffer in characters.  The browser on return has filled the buffer
//  with the default context menu text.  The Shell will call this method
//  with at least a buffer size of MAX_PATH.  The browser should return
//  S_OK if it returned a new default menu text, S_FALSE to let the view
//  to use the normal default menu text.
//
//  ICommDlgBrowser2::GetViewFlags(DWORD *pdwFlags)
//     Called when the view wants to determine  if special customization needs to
//    be done for the common dialog browser. For example View calls this function to
//    determin if all files(hidden and system)needs to be shown. If the GetViewFlags returns a DWORD with
//    CDB2GVF_SHOWALLFILES  flag set then it will show all the files.
//-------------------------------------------------------------------------

cpp_quote("#define CDB2N_CONTEXTMENU_DONE  0x00000001")
cpp_quote("#define CDB2N_CONTEXTMENU_START 0x00000002")

//GetViewFlags
cpp_quote("#define CDB2GVF_SHOWALLFILES        0x00000001")
cpp_quote("#define CDB2GVF_ISFILESAVE          0x00000002 // is file save, else file open")
cpp_quote("#define CDB2GVF_ALLOWPREVIEWPANE    0x00000004")
cpp_quote("#define CDB2GVF_NOSELECTVERB        0x00000008")

[
    uuid(10339516-2894-11d2-9039-00C04F8EEB3E),
    object,
    pointer_default(unique)
]
interface ICommDlgBrowser2 : ICommDlgBrowser
{
    HRESULT Notify([in] IShellView *ppshv, [in] DWORD dwNotifyType);
    HRESULT GetDefaultMenuText([in] IShellView *ppshv, [out, size_is(cchMax)] WCHAR *pszText, [in] int cchMax);
    HRESULT GetViewFlags([out] DWORD *pdwFlags);
};

typedef ICommDlgBrowser2 * LPCOMMDLGBROWSER2;

[
    uuid(1c20815f-dd28-4278-9492-17af47143429),
    object,
    pointer_default(unique)
]
interface ICommDlgBrowser3 : ICommDlgBrowser2
{
    HRESULT OnColumnClicked([in] IShellView *ppshv, [in] int iColumn);
    HRESULT GetCurrentFilter([out, size_is(cchFileSpec)] LPWSTR pszFileSpec, [in] int cchFileSpec);
};



//--------------------------------------------------------------------------
//
// Interface:   IColumnManager
//
// IColumnManager is an interfaced provided by defview to
// allow the manipulation of columns in details view.
//

cpp_quote("#if (_WIN32_IE >= 0x0501)")

typedef [v1_enum] enum tagCM_MASK
{
    CM_MASK_WIDTH           = 0x00000001,
    CM_MASK_DEFAULTWIDTH    = 0x00000002,
    CM_MASK_NAME            = 0x00000004,
    CM_MASK_STATE           = 0x00000008,
} CM_MASK;

typedef [v1_enum] enum tagCM_STATE
{
    CM_STATE_NONE         = 0x00000000,
    CM_STATE_VISIBLE      = 0x00000001,  // The column is visible
    CM_STATE_ISLINK       = 0x00000002,
    CM_STATE_DETAILS      = 0x00000004,
    CM_STATE_FIXEDWIDTH   = 0x00000008,  // Can't resize the column
} CM_STATE;

typedef [v1_enum] enum tagCM_ENUM_FLAGS
{
    CM_ENUM_ALL          = 0x00000001,
    CM_ENUM_VISIBLE      = 0x00000002,
    CM_ENUM_DETAILS      = 0x00000004,
    CM_ENUM_TILE         = 0x00000008,
} CM_ENUM_FLAGS;

typedef [v1_enum] enum tagCM_SET_WIDTH_VALUE
{
    CM_WIDTH_USEDEFAULT  = -1,
    CM_WIDTH_AUTOSIZE    = -2,
} CM_SET_WIDTH_VALUE;

#define MAX_COLUMN_NAME_LEN 80

typedef struct tagCM_COLUMNINFO
{
    DWORD cbSize;  // size in bytes of struct
    DWORD dwMask;  // CM_MASK
    DWORD dwState; // CM_STATE
    UINT uWidth;   // CM_MASK_WIDTH, for SetColumnInfo it can be a CM_SET_WIDTH_VALUE
    UINT uDefaultWidth; // CM_MASK_DEFAULTWIDTH
    WCHAR wszName[MAX_COLUMN_NAME_LEN];
} CM_COLUMNINFO;

[
    uuid(5e275cc5-bd21-45d1-a8a9-fc592444266a),
    object,
    pointer_default(unique)
]
interface IColumnManager : IUnknown
{
    HRESULT SetColumnInfo([in] REFPROPERTYKEY propkey, [in] const CM_COLUMNINFO *pcmci);
    HRESULT GetColumnInfo([in] REFPROPERTYKEY propkey, [out] CM_COLUMNINFO *pcmci);
    HRESULT GetColumnCount([in] CM_ENUM_FLAGS dwFlags, [out] UINT *puCount);
    HRESULT GetColumns([in] CM_ENUM_FLAGS dwFlags, [out, size_is(cColumns)] PROPERTYKEY *rgkeyOrder, [in] UINT cColumns);
    HRESULT SetColumns([in, size_is(cVisible)] const PROPERTYKEY *rgkeyOrder, [in] UINT cVisible);
};

[
    uuid(470BCB4B-6DA7-437A-8846-ED51BA6059FA),
    object,
    pointer_default(unique)
]
interface IOrderView : IUnknown
{
    //  IOrderView
    HRESULT GetInsertMark([out] int *piInsert);
    HRESULT MoveObjects([in, size_is(cidl)] PCUITEMID_CHILD_ARRAY apidl, [in] UINT cidl, [in] int iInsert);
    [helpstring("Moves up or down, in view order, all the items specified in the array of indices. The array must be in ascending order and have no duplicates.")]
    HRESULT MoveObjectsUpDown([in, size_is(ciItem)] UINT *aiItem, [in] UINT ciItem, [in] BOOL fUp);
};

cpp_quote("#endif // (_WIN32_IE >= 0x0501)")

//  this is to handle name collisions
cpp_quote("#ifdef _FIX_ENABLEMODELESS_CONFLICT")
cpp_quote("#undef    EnableModeless ")
cpp_quote("#endif")


[
    uuid(C0A651F5-B48B-11d2-B5ED-006097C686F6), // IID_IFolderFilterSite
    object,
    pointer_default(unique)
]
interface IFolderFilterSite : IUnknown
{
    HRESULT SetFilter([in]IUnknown* punk);
};


[
    uuid(9CC22886-DC8E-11d2-B1D0-00C04F8EEB3E), // IID_IFolderFilter
    object,
    pointer_default(unique)
]
interface IFolderFilter : IUnknown
{
    HRESULT ShouldShow([in] IShellFolder* psf, [in] PCIDLIST_ABSOLUTE pidlFolder, [in] PCUITEMID_CHILD pidlItem);
    HRESULT GetEnumFlags([in] IShellFolder* psf, [in] PCIDLIST_ABSOLUTE pidlFolder, [in] HWND *phwnd, [out] DWORD *pgrfFlags);
};


//==========================================================================
// IInputObjectSite/IInputObject interfaces
//
//  These interfaces allow us (or ISVs) to install/update external Internet
// Toolbar for IE and the shell. The frame will simply get the CLSID from
// registry (to be defined) and CoCreateInstance it.
//
//==========================================================================

//-------------------------------------------------------------------------
//
// IInputObjectSite interface
//
//   A site implements this interface so the object can communicate
// focus change to it.
//
// [Member functions]
//
// IInputObjectSite::OnFocusChangeIS(punkObj, fSetFocus)
//   Object (punkObj) is getting or losing the focus.
//
//-------------------------------------------------------------------------
[
    object,
    uuid(F1DB8392-7331-11D0-8C99-00A0C92DBFE8),
    pointer_default(unique),
    local
]
interface IInputObjectSite: IUnknown
{
    HRESULT OnFocusChangeIS([in] IUnknown* punkObj, [in] BOOL fSetFocus);
};

//-------------------------------------------------------------------------
//
// IInputObject interface
//
//   An object implements this interface so the site can communicate
// activation and accelerator events to it.
//
// [Member functions]
//
// IInputObject::UIActivateIO(fActivate, lpMsg)
//   Activates or deactivates the object.  lpMsg may be NULL.  Returns
//   S_OK if the activation succeeded.
//
// IInputObject::HasFocusIO()
//   Returns S_OK if the object has the focus, S_FALSE if not.
//
// IInputObject::TranslateAcceleratorIO(lpMsg)
//   Allow the object to process the message.  Returns S_OK if the
//   message was processed (eaten).
//
//-------------------------------------------------------------------------
[
    object,
    uuid(68284fAA-6A48-11D0-8c78-00C04fd918b4),
    pointer_default(unique),
    local
]
interface IInputObject: IUnknown
{
    HRESULT UIActivateIO([in] BOOL fActivate, [in] LPMSG lpMsg);
    HRESULT HasFocusIO();
    HRESULT TranslateAcceleratorIO([in] LPMSG lpMsg);
};


//===========================================================================
//
// IShellIcon Interface
//
// used to get a icon index for a IShellFolder object.
//
// this interface can be implemented by a IShellFolder, as a quick way to
// return the icon for a object in the folder.
//
// a instance of this interface is only created once for the folder, unlike
// IExtractIcon witch is created once for each object.
//
// if a ShellFolder does not implement this interface, the standard
// GetUIObject(....IExtractIcon) method will be used to get a icon
// for all objects.
//
// the following standard imagelist indexs can be returned:
//
//      0   document (blank page) (not associated)
//      1   document (with stuff on the page)
//      2   application (exe, com, bat)
//      3   folder (plain)
//      4   folder (open)
//
// IShellIcon:GetIconOf(pidl, flags, lpIconIndex)
//
//      pidl            object to get icon for.
//      flags           GIL_* input flags (GIL_OPEN, ...)
//      lpIconIndex     place to return icon index.
//
//  returns:
//      NOERROR, if lpIconIndex contains the correct system imagelist index.
//      S_FALSE, if unable to get icon for this object, go through
//               GetUIObject, IExtractIcon, methods.
//
//===========================================================================

[
    uuid(000214E5-0000-0000-C000-000000000046), // IID_IShellIcon
    object,
    pointer_default(unique)
]
interface IShellIcon : IUnknown
{
    HRESULT GetIconOf([in] PCUITEMID_CHILD pidl, [in] UINT flags, [out] int *pIconIndex) ;
};

typedef IShellIcon *LPSHELLICON;

//--------------------------------------------------------------------------
//
// Interface:   IShellBrowser
//
//  IShellBrowser interface is the interface that is provided by the shell
// explorer/folder frame window. When it creates the 'contents pane' of
// a shell folder (which provides IShellFolder interface), it calls its
// CreateViewObject member function to create an IShellView object. Then,
// it calls its CreateViewWindow member to create the 'contents pane'
// window. The pointer to the IShellBrowser interface is passed to
// the IShellView object as a parameter to this CreateViewWindow member
// function call.
//
//    +--------------------------+  <-- Explorer window
//    | [] Explorer              |
//    |--------------------------+       IShellBrowser
//    | File Edit View ..        |
//    |--------------------------|
//    |        |                 |
//    |        |              <-------- Content pane
//    |        |                 |
//    |        |                 |       IShellView
//    |        |                 |
//    |        |                 |
//    +--------------------------+
//
//
//
// [Member functions]
//
//
// IShellBrowser::GetWindow(phwnd)
//
//   Inherited from IOleWindow::GetWindow.
//
//
// IShellBrowser::ContextSensitiveHelp(fEnterMode)
//
//   Inherited from IOleWindow::ContextSensitiveHelp.
//
//
// IShellBrowser::InsertMenusSB(hmenuShared, lpMenuWidths)
//
//   Similar to the IOleInPlaceFrame::InsertMenus. The explorer will put
//  'File' and 'Edit' pulldown in the File menu group, 'View' and 'Tools'
//  in the Container menu group and 'Help' in the Window menu group. Each
//  pulldown menu will have a uniqu ID, FCIDM_MENU_FILE/EDIT/VIEW/TOOLS/HELP
//  The view is allowed to insert menuitems into those sub-menus by those
//  IDs must be between FCIDM_SHVIEWFIRST and FCIDM_SHVIEWLAST.
//
//
// IShellBrowser::SetMenuSB(hmenuShared, holemenu, hwndActiveObject)
//
//   Similar to the IOleInPlaceFrame::SetMenu. The explorer ignores the
//  holemenu parameter (reserved for future enhancement)  and performs
//  menu-dispatch based on the menuitem IDs (see the description above).
//  It is important to note that the explorer will add different
//  set of menuitems depending on whether the view has a focus or not.
//  Therefore, it is very important to call ISB::OnViewWindowActivate
//  whenever the view window (or its children) gets the focus.
//
//
// IShellBrowser::RemoveMenusSB(hmenuShared)
//
//   Same as the IOleInPlaceFrame::RemoveMenus.
//
//
// IShellBrowser::SetStatusTextSB(pszStatusText)
//
//   Same as the IOleInPlaceFrame::SetStatusText. It is also possible to
//  send messages directly to the status window via SendControlMsg.
//
//
// IShellBrowser::EnableModelessSB(fEnable)
//
//   Same as the IOleInPlaceFrame::EnableModeless.
//
//
// IShellBrowser::TranslateAcceleratorSB(lpmsg, wID)
//
//   Same as the IOleInPlaceFrame::TranslateAccelerator, but will be
//  never called because we don't support EXEs (i.e., the explorer has
//  the message loop). This member function is defined here for possible
//  future enhancement.
//
//
// IShellBrowser::BrowseObject(pidl, wFlags)")
//
//   The view calls this member to let shell explorer browse to another")
//  folder. The pidl and wFlags specifies the folder to be browsed.")
//
//  Following three flags specifies whether it creates another window or not.
//   SBSP_SAMEBROWSER  -- Browse to another folder with the same window.
//   SBSP_NEWBROWSER   -- Creates another window for the specified folder.
//   SBSP_DEFBROWSER   -- Default behavior (respects the view option).
//
//  Following three flags specifies open, explore, or default mode. These   .
//  are ignored if SBSP_SAMEBROWSER or (SBSP_DEFBROWSER && (single window   .
//  browser || explorer)).                                                  .
//   SBSP_OPENMODE     -- Use a normal folder window
//   SBSP_EXPLOREMODE  -- Use an explorer window
//   SBSP_DEFMODE      -- Use the same as the current window
//
//  Following three flags specifies the pidl.
//   SBSP_ABSOLUTE -- pidl is an absolute pidl (relative from desktop)
//   SBSP_RELATIVE -- pidl is relative from the current folder.
//   SBSP_PARENT   -- Browse the parent folder (ignores the pidl)
//   SBSP_NAVIGATEBACK    -- Navigate back (ignores the pidl)
//   SBSP_NAVIGATEFORWARD -- Navigate forward (ignores the pidl)
//
//  Following two flags control history manipulation as result of navigate
//   SBSP_WRITENOHISTORY -- write no history (shell folder) entry
//   SBSP_NOAUTOSELECT -- suppress selection in history pane
//
// IShellBrowser::GetViewStateStream(grfMode, ppstm)
//
//   The browser returns an IStream interface as the storage for view
//  specific state information.
//
//   grfMode -- Specifies the read/write access (STGM_READ/WRITE/READWRITE)
//   ppstm   -- Specifies the IStream *variable to be filled.
//
//
// IShellBrowser::GetControlWindow(id, phwnd)
//
//   The shell view may call this member function to get the window handle
//  of Explorer controls (toolbar or status winodw -- FCW_TOOLBAR or
//  FCW_STATUS).
//
//
// IShellBrowser::SendControlMsg(id, uMsg, wParam, lParam, pret)
//
//   The shell view calls this member function to send control messages to
//  one of Explorer controls (toolbar or status window -- FCW_TOOLBAR or
//  FCW_STATUS).
//
//
// IShellBrowser::QueryActiveShellView(IShellView * ppshv)
//
//   This member returns currently activated (displayed) shellview object.
//  A shellview never need to call this member function.
//
//
// IShellBrowser::OnViewWindowActive(pshv)
//
//   The shell view window calls this member function when the view window
//  (or one of its children) got the focus. It MUST call this member before
//  calling IShellBrowser::InsertMenus, because it will insert different
//  set of menu items depending on whether the view has the focus or not.
//
//
// IShellBrowser::SetToolbarItems(lpButtons, nButtons, uFlags)
//
//   The view calls this function to add toolbar items to the exporer's
//  toolbar. 'lpButtons' and 'nButtons' specifies the array of toolbar
//  items. 'uFlags' must be one of FCT_MERGE, FCT_CONFIGABLE, FCT_ADDTOEND.
//
//-------------------------------------------------------------------------

//
// Values for wFlags parameter of ISB::BrowseObject() member.
//
cpp_quote("#define SBSP_DEFBROWSER         0x0000")
cpp_quote("#define SBSP_SAMEBROWSER        0x0001")
cpp_quote("#define SBSP_NEWBROWSER         0x0002")

cpp_quote("#define SBSP_DEFMODE            0x0000")
cpp_quote("#define SBSP_OPENMODE           0x0010")
cpp_quote("#define SBSP_EXPLOREMODE        0x0020")
cpp_quote("#define SBSP_HELPMODE           0x0040 // IEUNIX : Help window uses this.")
cpp_quote("#define SBSP_NOTRANSFERHIST     0x0080")

cpp_quote("#define SBSP_ABSOLUTE           0x0000")
cpp_quote("#define SBSP_RELATIVE           0x1000")
cpp_quote("#define SBSP_PARENT             0x2000")
cpp_quote("#define SBSP_NAVIGATEBACK       0x4000")
cpp_quote("#define SBSP_NAVIGATEFORWARD    0x8000")

cpp_quote("#define SBSP_ALLOW_AUTONAVIGATE 0x10000")

cpp_quote("#define SBSP_NOAUTOSELECT       0x04000000")
cpp_quote("#define SBSP_WRITENOHISTORY     0x08000000")

cpp_quote("#define SBSP_REDIRECT                     0x40000000")
cpp_quote("#define SBSP_INITIATEDBYHLINKFRAME        0x80000000")
//
// Values for id parameter of ISB::GetWindow/SendControlMsg members.
//
// WARNING:
//  Any shell extensions which sends messages to those control windows
// might not work in the future version of windows. If you really need
// to send messages to them, (1) don't assume that those control window
// always exist (i.e. GetControlWindow may fail) and (2) verify the window
// class of the window before sending any messages.
//
cpp_quote("#define FCW_STATUS      0x0001")
cpp_quote("#define FCW_TOOLBAR     0x0002")
cpp_quote("#define FCW_TREE        0x0003")
cpp_quote("#define FCW_INTERNETBAR 0x0006")
cpp_quote("#define FCW_PROGRESS    0x0008")


//
// Values for uFlags paremeter of ISB::SetToolbarItems member.
//
cpp_quote("#define FCT_MERGE       0x0001")
cpp_quote("#define FCT_CONFIGABLE  0x0002")
cpp_quote("#define FCT_ADDTOEND    0x0004")

cpp_quote("#ifdef _NEVER_")
typedef LPARAM LPTBBUTTONSB;
cpp_quote("#else //!_NEVER_")
cpp_quote("#include <commctrl.h>")
cpp_quote("typedef LPTBBUTTON LPTBBUTTONSB;")
cpp_quote("#endif //_NEVER_")

[
    uuid(000214E2-0000-0000-C000-000000000046),
    object,
    pointer_default(unique)
]
interface IShellBrowser : IOleWindow
{
    // same as IOleInPlaceFrame
    HRESULT InsertMenusSB(
        [in] HMENU hmenuShared,
        [in, out] LPOLEMENUGROUPWIDTHS lpMenuWidths);

    HRESULT SetMenuSB(
        [in] HMENU hmenuShared,
        [in] HOLEMENU holemenuRes,
        [in] HWND hwndActiveObject);

    HRESULT RemoveMenusSB([in] HMENU hmenuShared);
    HRESULT SetStatusTextSB([in, unique] LPCOLESTR pszStatusText);
    HRESULT EnableModelessSB([in] BOOL fEnable);
    HRESULT TranslateAcceleratorSB([in] MSG *pmsg, [in] WORD wID);

    // IShellBrowser
    HRESULT BrowseObject(
        [in] PCUIDLIST_RELATIVE pidl,
        [in] UINT wFlags);

    HRESULT GetViewStateStream(
        [in] DWORD grfMode,
        [out] IStream **ppStrm);

    HRESULT GetControlWindow(
        [in] UINT id,
        [out] HWND * phwnd);

    [local] HRESULT SendControlMsg(
        [in] UINT id,
        [in] UINT uMsg,
        [in] WPARAM wParam,
        [in] LPARAM lParam,
        [in] LRESULT *pret);

    HRESULT QueryActiveShellView([out] IShellView **ppshv);
    HRESULT OnViewWindowActive([in] IShellView *pshv);
    [local] HRESULT SetToolbarItems(
        [in] LPTBBUTTONSB lpButtons,
        [in] UINT nButtons,
        [in] UINT uFlags);
};

typedef IShellBrowser * LPSHELLBROWSER;


[
    uuid(cb728b20-f786-11ce-92ad-00aa00a74cd0), // IID_IProfferService
    object,
    pointer_default(unique)
]
interface IProfferService : IUnknown
{
    HRESULT ProfferService([in]REFGUID rguidService, [in] IServiceProvider *psp, [out] DWORD *pdwCookie);
    HRESULT RevokeService([in]DWORD dwCookie);
}

cpp_quote("#define SID_SProfferService IID_IProfferService    // nearest service that you can proffer to")

// Tells an IShellItem not to resolve the link target obtained
// when using the BHID_LinkTargetItem GUID in BindToHandler.
cpp_quote("#define STR_DONT_RESOLVE_LINK      L\"Don't Resolve Link\"")

// Tells a static list folder to not persist on every change
cpp_quote("#define STR_PLAYLIST_EDITOR_UI  L\"Static List In Dialog\"")

//  BindHandler GUIDs for IShellItem::BindToHandler (defined in shlguid.h)")
//  BHID_SFObject            restricts usage to IShellFolder::BindToObject()")
//  BHID_SFUIObject          restricts usage to IShellFolder::GetUIObjectOf()")
//  BHID_SFViewObject        restricts usage to IShellFolder::CreateViewObject()")
//  BHID_LocalCopyHelper     creates and initializes CLSID_LocalCopyHelper")
//  BHID_LinkTargetItem      CLSID_ShellItem initialized with the target this item (SFGAO_LINK only)")
//  BHID_Storage             attempts to get the stg/stm riid from BTO, but defaults to shell implementations on failure")

[
    helpstring("Shell Namespace helper"),
    uuid(43826d1e-e718-42ee-bc55-a1e261c37bfe),
    object,
    pointer_default(unique)
]
interface IShellItem : IUnknown
{
    HRESULT BindToHandler(
        [in] IBindCtx *pbc,
        [in] REFGUID rbhid,
        [in] REFIID riid,
        [out, iid_is(riid)] void **ppvOut);

    HRESULT GetParent([out] IShellItem **ppsi);

    typedef [v1_enum] enum tagSIGDN
    {                                                   // lower word (& with 0xFFFF)
        SIGDN_NORMALDISPLAY               = 0x00000000, // SHGDN_NORMAL
        SIGDN_PARENTRELATIVEPARSING       = 0x80018001, // SHGDN_INFOLDER | SHGDN_FORPARSING
        SIGDN_DESKTOPABSOLUTEPARSING      = 0x80028000, // SHGDN_FORPARSING
        SIGDN_PARENTRELATIVEEDITING       = 0x80031001, // SHGDN_INFOLDER | SHGDN_FOREDITING
        SIGDN_DESKTOPABSOLUTEEDITING      = 0x8004c000, // SHGDN_FORPARSING | SHGDN_FORADDRESSBAR
        SIGDN_FILESYSPATH                 = 0x80058000, // SHGDN_FORPARSING
        SIGDN_URL                         = 0x80068000, // SHGDN_FORPARSING
        SIGDN_PARENTRELATIVEFORADDRESSBAR = 0x8007c001, // SHGDN_INFOLDER | SHGDN_FORPARSING | SHGDN_FORADDRESSBAR
        SIGDN_PARENTRELATIVE              = 0x80080001, // SHGDN_INFOLDER
    } SIGDN;

    HRESULT GetDisplayName(
        [in] SIGDN sigdnName,
        [out, string] LPOLESTR *ppszName);

    HRESULT GetAttributes(
        [in] SFGAOF sfgaoMask,
        [out] SFGAOF *psfgaoAttribs);

    //  SICHINT_DISPLAY         iOrder based on display in a folder view
    //  SICHINT_ALLFIELDS       exact instance compare
    //  SICHINT_CANONICAL       iOrder based on canonical name (better performance)
    [v1_enum] enum tagSHELLITEMCOMPAREHINTF
    {
        SICHINT_DISPLAY         = 0x00000000,
        SICHINT_ALLFIELDS       = 0x80000000,
        SICHINT_CANONICAL       = 0x10000000,
    };
    typedef DWORD SICHINTF;

    HRESULT Compare(
        [in] IShellItem *psi,
        [in] SICHINTF hint,
        [out] int *piOrder);
};

cpp_quote("SHSTDAPI SHCreateItemFromFolderID(int csidl, HANDLE hToken, REFIID riid, void **ppv);")
cpp_quote("SHSTDAPI SHCreateItemFromIDList(PCIDLIST_ABSOLUTE pidl, REFIID riid, void **ppv);")
cpp_quote("SHSTDAPI SHCreateItemFromParsingName(PCWSTR pszPath, IBindCtx *pbc, REFIID riid, void **ppv);")
cpp_quote("SHSTDAPI SHCreateItemWithParent(PCIDLIST_ABSOLUTE pidlParent, IShellFolder *psfParent, PCUITEMID_CHILD pidl, REFIID riid, void **ppvItem);")
cpp_quote("SHSTDAPI SHCreateItemFromRelativeName(IShellItem *psiParent, PCWSTR pszName, IBindCtx* pbc, REFIID riid, void **ppv);")


// GETPROPERTYSTOREFLAGS
[v1_enum] enum tagGETPROPERTYSTOREFLAGS
{
    GPS_DEFAULT                = 0x00000000,
    GPS_READWRITE              = 0x00000001,
    GPS_INMEMORY               = (GPS_READWRITE | 0x00000002),  // A read/write store that only holds properties for the lifetime of the shell item
    GPS_NOINCLUDEALLDETAILS    = 0x00000004,   // default is to include all details
    GPS_NONTFSPROPSTORE        = 0x00000008,   // default is to allow NTFS propertystore
    GPS_CACHEDREADONLY         = 0x00000010,   // only include cached properties (don't hit the disk / slow properties)
    GPS_INCLUDEOFFLINEDETAILS  = 0x00000020,   
    GPS_DELAYCREATION          = 0x00000040,   // delay the creation of the real property store until the first read / write
};
typedef DWORD GETPROPERTYSTOREFLAGS;

// bootstrapping for cross-depot checkin
cpp_quote("#define GPS_TEMPORARY GPS_INMEMORY")

[
    helpstring("Shell Namespace helper 2"),
    uuid(58bbfe39-c0ad-4f95-9e55-e4c2a1ba1cf8),
    object,
    pointer_default(unique)
]
interface IShellItem2 : IShellItem
{
    HRESULT GetPropertyStore([in] GETPROPERTYSTOREFLAGS flags, [in] REFIID riid, [out, iid_is(riid)] void **ppv);
    HRESULT GetPropertyDescriptionList([in] REFPROPERTYKEY keyType, [in] REFIID riid, [out, iid_is(riid)] void **ppv);
};

[
    helpstring("Shell Namespace enumerator"),
    uuid(70629033-e363-4a28-a567-0db78006e6d7),
    object,
    pointer_default(unique)
]
interface IEnumShellItems : IUnknown
{
    HRESULT Next(
        [in] ULONG celt,
        [out, size_is(celt), length_is(*pceltFetched)] IShellItem **rgelt,
        [out] ULONG *pceltFetched);

    HRESULT Skip([in] ULONG celt);
    HRESULT Reset();
    HRESULT Clone([out] IEnumShellItems **ppenum);
};

//-------------------------------------------------------------------------
//
// ITransferAdviseSink interface
//
//-------------------------------------------------------------------------

// ITransferAdviseSink response codes

cpp_quote("#define STRESPONSE_CONTINUE               S_OK")
cpp_quote("#define STRESPONSE_RENAME                 MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 20)")
cpp_quote("#define STRESPONSE_SKIP                   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 21)")
cpp_quote("#define STRESPONSE_CANCEL                 MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 22)")
cpp_quote("#define STRESPONSE_RETRY                  __HRESULT_FROM_WIN32(ERROR_RETRY)")

typedef GUID STGTRANSCONFIRMATION, *LPSTGTRANSCONFIRMATION;

// Storage operation tags.

typedef [v1_enum] enum tagSTGOP
{
    STGOP_MOVE               = 1,
    STGOP_COPY               = 2,
    STGOP_SYNC               = 3,
    STGOP_DIFF               = 4,
    STGOP_REMOVE             = 5,
    STGOP_RENAME             = 6,
    STGOP_STATS              = 7,
    STGOP_APPLYPROPERTIES    = 8,   // _WIN32_WINNT >= 0x0600
    STGOP_LINK               = 9,   // _WIN32_WINNT >= 0x0600
} STGOP, *LPSTGOP;

[
    uuid(9e53e36c-b6b6-4a9b-a6a2-1666e42587bc), object,
    pointer_default(unique)
]
interface ITransferAdviseSink : IQueryContinue
{
    // Before an operation such as a copy, move, or delete is about
    // to be performed the storage will advise the sink via this method.

    HRESULT PreOperation (     [in] const STGOP          op,
                               [in] IShellItem           *psiItem,
                               [in] IShellItem           *psiDest);

    // When the storage believes that user confirmation or acknowledgement
    // is required, it asks the advise to seek it via this method.
    // pwszItem is [in,out] non-const because rename can massage the name.

    HRESULT ConfirmOperation(  [in] IShellItem               *psiItem,
                               [in] IShellItem               *psiDest,
                               [in] STGTRANSCONFIRMATION     stc);

    // As the operation (copy, move, etc) proceeds the storage calls
    // this method on the sink.  There is no guarantee of service but
    // intervals of one second between updates are ideal.

    HRESULT OperationProgress( [in]  const STGOP            op,
                               [in]  IShellItem             *psiItem,
                               [in]  IShellItem             *psiDest,
                               [in]  ULONGLONG              ulTotal,
                               [in]  ULONGLONG              ulComplete);

    // When an operation is complete or if it is aborted the storage advises
    // the sink via this method and provides the final status (S_OK, failure,
    // etc) of the task.  Certain operations can provide extra information
    // describing the results, such as when a file is renamed on a copy collision.

    HRESULT PostOperation(     [in]  const STGOP            op,
                               [in]  IShellItem             *psiItem,
                               [in]  IShellItem             *psiDest,
                               [in]  HRESULT                hrResult);
}

typedef [v1_enum] enum tagPKA_FLAGS
{
    PKA_SET                = 0x00000000,   // replace current value
    PKA_APPEND             = 0x00000001,   // append to current value - multi-value properties only
    PKA_DELETE             = 0x00000002,   // delete from current value - multi-value properties only
} PKA_FLAGS;

[
   uuid(800c31bd-c671-4604-9eb9-e44245ced2b9),
   object,
   pointer_default(unique)
]
interface IPropertyArray : IUnknown
{
    HRESULT GetCount([out] int *pcItems);
    HRESULT GetAt([in] int iIndex, [out] PROPERTYKEY *pkey, [out] PKA_FLAGS *pflags, [out] PROPVARIANT *ppropvar);
    HRESULT IsKeyInArray([in] REFPROPERTYKEY key);
    HRESULT GetValues([in] REFPROPERTYKEY key, [out] UINT *pcValues, [out, size_is(,*pcValues)] PROPVARIANT **prgpropvar);
    HRESULT InsertAt([in] int iIndex, [in] REFPROPERTYKEY key, [in] PKA_FLAGS flags, [in] const PROPVARIANT *ppropvar);
    HRESULT GetArrays([out] UINT *pcItems, [out, size_is(,*pcItems)] PROPVARIANT **prgpropvar, [out, size_is(,*pcItems)] PROPERTYKEY **prgkeys, [out, size_is(,*pcItems)] PKA_FLAGS **prgFlags);
}

// Extended FOF_ flags. These features work with IFileOperation and SHFileOperationEx, but not SHFileOperation.
cpp_quote("#define FOFX_NOSKIPJUNCTIONS         0x00010000  // Don't avoid binding to junctions (like Task folder, Recycle-Bin)")
cpp_quote("#define FOFX_PREFERHARDLINK          0x00020000  // Create hard link if possible")
cpp_quote("#define FOFX_COLLECTION              0x00040000  // Operate on items inside collections (playlists)")
cpp_quote("#define FOFX_MODALPROGRESSUI         0x00100000  // Display modal (rather than modeless) progress UI")
cpp_quote("#define FOFX_PRESERVEFILEEXTENSIONS  0x00200000  // Rename collisions preserve file extns (use with FOF_RENAMEONCOLLISION)")

[
    object,
    uuid(5e09c7bf-4498-43c2-babc-f2f448264c1e),
    pointer_default(unique),
    local
]
interface IFileOperationProgressSink : IUnknown
{
    HRESULT StartOperations(void);
    HRESULT FinishOperations([in] HRESULT hrResult);
    HRESULT PreRenameItem([in] DWORD dwFlags, [in] IShellItem *psiItem,
        [in] LPCWSTR pszNewName);
    HRESULT PostRenameItem([in] DWORD dwFlags, [in] IShellItem *psiItem,
        [in] LPCWSTR pszNewName, [in] HRESULT hrRename, [in] IShellItem *psiNewlyCreated);
    HRESULT PreMoveItem([in] DWORD dwFlags, [in] IShellItem *psiItem,
        [in] IShellItem *psiDestinationFolder, [in] LPCWSTR pszNewName);
    HRESULT PostMoveItem([in] DWORD dwFlags, [in] IShellItem *psiItem,
        [in] IShellItem *psiDestinationFolder, [in] LPCWSTR pszNewName, [in] HRESULT hrMove,
        [in] IShellItem *psiNewlyCreated);
    HRESULT PreCopyItem([in] DWORD dwFlags, [in] IShellItem *psiItem,
        [in] IShellItem *psiDestinationFolder, [in] LPCWSTR pszNewName);
    HRESULT PostCopyItem(DWORD dwFlags, IShellItem *psiItem,
        [in] IShellItem *psiDestinationFolder, [in] LPCWSTR pszNewName, [in] HRESULT hrCopy,
        [in] IShellItem *psiNewlyCreated);
    HRESULT PreLinkItem([in] DWORD dwFlags, [in] IShellItem *psiItem,
        [in] IShellItem *psiDestinationFolder, [in] LPCWSTR pszNewName);
    HRESULT PostLinkItem(DWORD dwFlags, IShellItem *psiItem,
        [in] IShellItem *psiDestinationFolder, [in] LPCWSTR pszNewName, [in] HRESULT hrLink,
        [in] IShellItem *psiNewlyCreated);
    HRESULT PreDeleteItem([in] DWORD dwFlags, [in] IShellItem *psiItem);
    HRESULT PostDeleteItem([in] DWORD dwFlags, [in] IShellItem *psiItem,
        [in] HRESULT hrDelete, [in] IShellItem *psiNewlyCreated);
    HRESULT UpdateProgress(
        [in] UINT iWorkTotal, [in] UINT iWorkSoFar);
    HRESULT ResetTimer(void);
    HRESULT PauseTimer(void);
    HRESULT ResumeTimer(void);
};    

[
    helpstring("Shell Copy/Move/Rename/Delete/Link/ApplyProperties Operation Handler"),
    uuid(b94ed75e-7628-403f-acdb-0d1ae521b1c7),
    object,
    pointer_default(unique)
]
interface IFileOperation : IUnknown
{
    // 1) (Optional) Set up your event sink.
    HRESULT Advise([in] IFileOperationProgressSink *pfops, [out] DWORD *pdwCookie);
    HRESULT Unadvise([in] DWORD dwCookie);

    // 2) Set operation state.
    // FOF_ flags (defined in shellapi.h) and FOFX_ flags are passed here.
    HRESULT SetOperationFlags([in] DWORD dwOperationFlags);
    HRESULT SetProgressMessage([in] LPCWSTR pszMessage);
    HRESULT SetProperties([in] IPropertyArray *pproparray);
    HRESULT SetParentWindow([in] HWND hwndParent);

    // 3) Specify operations to take on given items.
    // FooItem takes an IShellItem*.
    // FooItems takes an IShellItem*, an IEnumShellItems* or an IDataObject*.
    HRESULT ApplyPropertiesToItem([in] IShellItem *psiItem);
    HRESULT ApplyPropertiesToItems([in] IUnknown *punkItems);
    HRESULT RenameItem ([in] IShellItem *psiItem, [in] LPCWSTR pszNewName, 
        [in] IFileOperationProgressSink *pfopsItem);
    HRESULT RenameItems([in] IUnknown *pUnkItems, [in] LPCWSTR pszNewName);
    HRESULT MoveItem   ([in] IShellItem *psiItem, [in] IShellItem *psiDestinationFolder, [in] LPCWSTR pszNewName, 
        [in] IFileOperationProgressSink *pfopsItem);
    HRESULT MoveItems  ([in] IUnknown *punkItems, [in] IShellItem *psiDestinationFolder);
    HRESULT CopyItem   ([in] IShellItem *psiItem, [in] IShellItem *psiDestinationFolder, [in] LPCWSTR pszCopyName,
        [in] IFileOperationProgressSink *pfopsItem);
    HRESULT CopyItems  ([in] IUnknown *punkItems, [in] IShellItem *psiDestinationFolder);
    HRESULT LinkItem   ([in] IShellItem *psiItem, [in] IShellItem *psiDestinationFolder, [in] LPCWSTR pszNewName,
        [in] IFileOperationProgressSink *pfopsItem);
    HRESULT LinkItems  ([in] IUnknown *punkItems, [in] IShellItem *psiDestinationFolder);
    HRESULT DeleteItem ([in] IShellItem *psiItem, [in] IFileOperationProgressSink *pfopsItem);
    HRESULT DeleteItems([in] IUnknown *punkItems);

    // 4) Perform operations.
    HRESULT PerformOperations(void);
};

//  BindHandler GUIDs for IShellItemArray::BindToHandler (defined in shlguid.h)")
//  BHID_DataObject           Ask shellItemArray for its Dataobject")

[
    helpstring("Shell Item Container"),
    uuid(12d3ef71-3051-4cc8-a446-9807d6d14433),
    object,
    pointer_default(unique)
]
interface IShellItemArray : IUnknown
{
    typedef [v1_enum] enum tagSIATTRIBFLAGS
    {
        SIATTRIBFLAGS_AND               = 0x00000001, // if multiple items and the attirbutes together.
        SIATTRIBFLAGS_OR                = 0x00000002, // if multiple items or the attributes together.
        SIATTRIBFLAGS_APPCOMPAT         = 0x00000003, // Call GetAttributes directly on the ShellFolder for multiple attributes

        SIATTRIBFLAGS_MASK              = 0x00000003,
    } SIATTRIBFLAGS;

    HRESULT BindToHandler(
        [in] IBindCtx *pbc,
        [in] REFGUID rbhid,
        [in] REFIID riid,
        [out, iid_is(riid)] void **ppvOut);

    HRESULT GetPropertyStore([in] GETPROPERTYSTOREFLAGS flags, [in] REFIID riid, [out, iid_is(riid)] void **ppv);
    HRESULT GetPropertyDescriptionList([in] REFPROPERTYKEY keyType, [in] REFIID riid, [out, iid_is(riid)] void **ppv);

    HRESULT GetAttributes(
        [in] SIATTRIBFLAGS dwAttribFlags,
        [in] SFGAOF sfgaoMask,
        [out] SFGAOF *psfgaoAttribs);

    HRESULT GetCount(
        [out] DWORD *pdwNumItems);

    HRESULT GetItemAt(
        [in] DWORD dwIndex,
        [out] IShellItem **ppsi);

    HRESULT EnumItems(
        [out] IEnumShellItems **ppenumShellItems);
};

cpp_quote("SHSTDAPI SHCreateShellItemArray(PCIDLIST_ABSOLUTE pidlParent, IShellFolder *psfParent, UINT cidl, PCUITEMID_CHILD_ARRAY ppidl, IShellItemArray **ppsiItemArray);")
cpp_quote("SHSTDAPI SHCreateShellItemArrayFromIDLists(UINT cidl, PCIDLIST_ABSOLUTE_ARRAY rgpidl, IShellItemArray **ppsiItemArray);")

[v1_enum] enum tagPROPERTYUI_NAME_FLAGS
{
    PUIFNF_DEFAULT          = 0x00000000,
    PUIFNF_MNEMONIC         = 0x00000001,   // include mnemonic in display name
};
typedef DWORD PROPERTYUI_NAME_FLAGS;

[v1_enum] enum tagPROPERTYUI_FLAGS
{
    PUIF_DEFAULT                 = 0x00000000,
    PUIF_RIGHTALIGN              = 0x00000001,   // this property should be right alligned
    PUIF_NOLABELININFOTIP        = 0x00000002,   // this property should not display a label in the infotip
    PUIF_READONLY                = 0x00000004,   // this property cannot be written to
    PUIF_ISGROUP                 = 0x00000008,   // property metadata is really just a group heading
    PUIF_REVERSESORT             = 0x00000010,   // applies to a property in a list of sort properties, specifies "reverse sort" on that property
    PUIF_CANSTACKBY              = 0x00000020,   // this column can be used to stack by
    PUIF_SHOW_BY_DEFAULT         = 0x00000040,   // the property should be shown by default in a view (where applicable)
    PUIF_SHOW_IN_PRIMARY_LIST    = 0x00000080,   // the property should be shown by default in primary column selection UI
    PUIF_SHOW_IN_SECONDARY_LIST  = 0x00000100,   // the property should be shown by default in secondary column selection UI
    PUIF_HIDEIFNOTPRESENT        = 0x00000200,   // only show this property if it is present
    PUIF_MULTIPLEVALUES          = 0x00000400,   // the shell items have 2 or more different values for this property
    // Unused                    = 0x00000800,
    PUIF_BEGINCOLUMN             = 0x00001000,   // this property is the start of a new column, for extended tiles mode
    PUIF_ENDCOLUMN               = 0x00002000,   // this is the last property in the current column, for ext. tiles mode. If a column only has one property, this flag can appear with PUIF_BEGINCOLUMN
    PUIF_HASACTIONHANDLER        = 0x00004000,   // this property has a registered action handler (you can expect IPropertyDescription::GetActionHandler to succeed)
    PUIF_SLOW                    = 0x00008000,   // this property is slow to get
    // TODO: Replicate any LVCFMT flags we car about other that RightAlign, which is handled above. This is necessary for prop metadata to replace colhndlrs.
};
typedef DWORD PROPERTYUI_FLAGS;

[v1_enum] enum tagPROPERTYUI_FORMAT_FLAGS
{
    PUIFFDF_DEFAULT         = 0x00000000,
    PUIFFDF_RIGHTTOLEFT     = 0x00000001,   // BIDI support, right to left caller
    PUIFFDF_SHORTFORMAT     = 0x00000002,   // short format version of string
    PUIFFDF_NOTIME          = 0x00000004,   // truncate time to days, not hours/mins/sec
    PUIFFDF_FRIENDLYDATE    = 0x00000008,   // "Today", "Yesterday", etc
    PUIFFDF_NOUNITS         = 0x00000010,   // don't do "KB", "MB", "KHz"
    PUIFFDF_PREFIXNAME      = 0x00000020,   // Prefix the value with the property name.
    PUIFFDF_ALWAYSKB        = 0x00000040,   // Always format byte sizes as KB, so multi-item display is uniform (used in shell folders)
    PUIFFDF_FAILIFEMPTYPROP = 0x00000080,   // For IPropertyDescription::FormatForDisplay only - if the property value is VT_EMPTY, fail the call
};
typedef DWORD PROPERTYUI_FORMAT_FLAGS;

[v1_enum] enum tagPROPERTY_COMPARE_VALUES_FLAGS
{
    PCVF_DEFAULT             = 0x00000000,
};
typedef DWORD PROPERTY_COMPARE_VALUES_FLAGS;

[v1_enum] enum tagPROPERTY_SORT_DESCRIPTION
{
    PSD_GENERIC              = 0x00000000,
    PSD_A_Z                  = 0x00000001,
    PSD_LOWEST_HIGHEST       = 0x00000002,
    PSD_SMALLEST_BIGGEST     = 0x00000003,
    PSD_OLDEST_NEWEST        = 0x00000004,
    PSD_CUSTOM               = 0xFFFFFFFF,
};
typedef DWORD PROPERTY_SORT_DESCRIPTION;

//
//  PROPERTYUI_DEFVAL - Tuple that defines an opaque identifier for a default property value (ulVal),
//                      and a friendly name for the value that can be displayed to the user
//
typedef struct tagPROPERTYUI_DEFVAL
{
    ULONG   ulVal;
    LPWSTR  pszName;
    // icon/image?
    // tooltip?
    // other text?
    // help links?
    // prompt question?
} PROPERTYUI_DEFVAL;

[
    uuid(4f9a8df8-fca5-4e56-9dcb-c6d1b4bdc81f),
    object,
    pointer_default(unique)
]
interface IEditVariantInPlace : IUnknown
{
    HRESULT Initialize([in] HWND hwndParent, [in] UINT uCodePage, [in] LPRECT prect, [in] PROPVARIANT *pv, [in] PROPERTYUI_DEFVAL *pDefVals);
    HRESULT Persist([out] PROPVARIANT *pv);
};

[v1_enum] enum tagDPV_FLAGS
{
    DPV_DEFAULT    = 0x00000000,
    DPV_SELECTED   = 0x00000001, // in selected state
    DPV_FOCUSED    = 0x00000002, // in focused state
};
typedef DWORD DPV_FLAGS;

[
    uuid(9c054922-416f-4053-8f9b-f991dc3d108c),
    object,
    local,
    pointer_default(unique)
]
interface IDrawPropVariant : IUnknown
{
    HRESULT Draw([in] const PROPVARIANT *ppv, [in] HDC hdc, [in] RECT *prc, [in] DPV_FLAGS dwState);
    HRESULT GetWidth([out] UINT* puWidth, [out] DWORD* pdwFlags);
};

cpp_quote("#if (_WIN32_IE >= 0x0501)")
cpp_quote("SHSTDAPI SHFormatForDisplay(REFFMTID fmtid, PROPID pid, const PROPVARIANT *pPropVar, PROPERTYUI_FORMAT_FLAGS flags, LPWSTR pwszText, DWORD cchText);")
cpp_quote("#endif // (_WIN32_IE >= 0x0501)")

[
    helpstring("helper service for dealing with properties ala IPropertySetStorage"),
    uuid(757a7d9f-919a-4118-99d7-dbb208c8cc66),
    object,
    pointer_default(unique)
]
interface IPropertyUI : IUnknown
{
    HRESULT ParsePropertyName([in] LPCWSTR pszName, [out] FMTID *pfmtid, [out] PROPID *ppid, [in, out] ULONG *pchEaten);
    HRESULT GetCannonicalName([in] REFFMTID fmtid, [in] PROPID pid, [out, size_is(cchText)] LPWSTR pwszText, [in] DWORD cchText);
    HRESULT GetDisplayName([in] REFFMTID fmtid, [in] PROPID pid, [in] PROPERTYUI_NAME_FLAGS flags, [out, size_is(cchText)] LPWSTR pwszText, [in] DWORD cchText);
    HRESULT GetPropertyDescription([in] REFFMTID fmtid, [in] PROPID pid, [out, size_is(cchText)] LPWSTR pwszText, [in] DWORD cchText);
    HRESULT GetDefaultWidth([in] REFFMTID fmtid, [in] PROPID pid, [out] ULONG *pcxChars);
    HRESULT GetFlags([in] REFFMTID fmtid, [in] PROPID pid, [out] PROPERTYUI_FLAGS *pflags);
    HRESULT FormatForDisplay([in] REFFMTID fmtid, [in] PROPID pid, [in] const PROPVARIANT *pvar, [in] PROPERTYUI_FORMAT_FLAGS flags, [out, size_is(cchText)] LPWSTR pwszText, [in] DWORD cchText);
    HRESULT GetHelpInfo([in] REFFMTID fmtid, [in] PROPID pid, [out, size_is(cch)] LPWSTR pwszHelpFile, [in] DWORD cch, [out] UINT *puHelpID);
};

typedef [v1_enum] enum tagPROPERTY_GROUPING_TYPE
{
    PGT_DISCRETE         = 0x00000000,   // display individual values
    PGT_STATICRANGE      = 0x00000001,   // display static ranges for values
    PGT_DYNAMICRANGE     = 0x00000002,   // display dynamic created ranges for the values
    PGT_DATERANGE        = 0x00000003,   // display month/year groups
} PROPERTY_GROUPING_TYPE;

typedef [v1_enum] enum tagPROPERTY_SUGGESTED_VALUES_TYPE
{
    PSV_DEFAULT        = 0x00000000,   // return list of all suggested values
    PSV_MOSTCOMMON     = 0x00000001,   // limit list to most common values, in priority order
} PROPERTY_SUGGESTED_VALUES_TYPE;

cpp_quote("#if (_WIN32_IE >= 0x0501)")

[
    uuid(b19eda26-0eba-4654-a3a3-779793fcb1f5), object,
    pointer_default(unique)
]
interface IPropVariantArray : IUnknown
{
    HRESULT GetCount([out] int *pcItems);
    HRESULT GetAt([in] int iIndex, [out] PROPVARIANT *ppvar);
};

[v1_enum] enum tagPROPERTY_DISPLAY_NAME_TYPE
{
    PDNT_DEFAULT        = 0x00000000,   // singular display name
    PDNT_PLURAL         = 0x00000001,   // plural display name
};
typedef DWORD PROPERTY_DISPLAY_NAME_TYPE;


[
    uuid(126ab71f-33fa-4e74-b1e9-5c2ef0bfcfe0),
    object,
    pointer_default(unique)
]
interface IPropertyDescription : IUnknown
{
    HRESULT GetPropertyKey([out] PROPERTYKEY *pkey);
    HRESULT GetCanonicalName([out] BSTR *pbstrName);
    HRESULT GetDisplayName([in] PROPERTY_DISPLAY_NAME_TYPE type, [out] BSTR *pbstrName);
    HRESULT GetEditInvitation([out] BSTR *pbstrInvite);
    HRESULT SetFlags([in] PROPERTYUI_FLAGS mask, [in] PROPERTYUI_FLAGS flags);
    HRESULT GetFlags([out] PROPERTYUI_FLAGS *pflags);
    HRESULT GetStackClassType([out] BSTR *pbstrClassType);
    HRESULT GetStackViewStatePropertyBag([in] DWORD grfMode, [out] IPropertyBag **pppb);
    HRESULT GetHelpUrl([out] BSTR *pbstrUrl);
    HRESULT GetEditingControlCLSID([out] CLSID *pclsidControl);
    HRESULT GetEditingControlElementName([out] BSTR *pbstrAvalonAssembly, [out] BSTR *pbstrAvalonModule);
    HRESULT GetDrawingControlCLSID([out] CLSID *pclsidControl);
    HRESULT GetDrawingControlElementName([out] BSTR *pbstrAvalonAssembly, [out] BSTR *pbstrAvalonModule);
    HRESULT GetActionHandler([in] IDataObject *pdo, [in] REFIID riid, [out, iid_is(riid)] void **ppv);
    HRESULT GetSuggestedValues([in] PROPERTY_SUGGESTED_VALUES_TYPE suggval, [in] REFIID riid, [out, iid_is(riid)] void **ppv);  // IPropVariantArray
    HRESULT GetDefaultCharWidth([out] DWORD *pcxChars);
    HRESULT GetDisplayType([out] DWORD *pshcolstatetype);  // Needs to correspond to SHCOLSTATE_TYPE for now
    HRESULT GetGroupingType([out] PROPERTY_GROUPING_TYPE *pgroupingtype);
    HRESULT GetPropVariantType([out] VARTYPE *pvt);
    HRESULT GetValue([in] IPropertyStore *pstore, [out] PROPVARIANT *pv);
    HRESULT SetValue([in] IPropertyStore *pstore, [in] const PROPVARIANT *pv);
    HRESULT FormatForDisplay([in] IPropertyStore *pstore, [in] PROPERTYUI_FORMAT_FLAGS flags, [out] BSTR *pbstrDisplay);
    HRESULT GetRelativeDescription([in] IPropertyStore *pstore1, [in] IPropertyStore *pstore2, [in] PROPERTY_COMPARE_VALUES_FLAGS flags, [out] BSTR *pbstrDesc1, [out] BSTR *pbstrDesc2);
    HRESULT GetSortDescription([in] BOOL fDescending, [out] BSTR *pbstrDescription);
};

[
    uuid(e9c40a8f-f83d-47a0-b718-37ed62fcb26b),
    object,
    pointer_default(unique)
]
interface IAggregatePropertyStore : IPropertyStore
{
    HRESULT GetAggregateValue([in] REFPROPERTYKEY key, [out] PROPVARIANT *pv, [out] BOOL *pfMultipleValues);
    HRESULT GetShellItems([out] IShellItemArray **ppsia);
    HRESULT GetStoreCount([out] DWORD *pcStores);
    HRESULT GetStoreAt([in] DWORD i, [in] REFIID riid, [out, iid_is(riid)] void **ppv);
};

[
    uuid(2c2aecc9-c0ab-497f-a92c-56f2968810a1),
    object,
    pointer_default(unique)
]
interface IPropertyDescriptionList : IUnknown
{
    HRESULT GetCount([out] DWORD *pcmd);
    HRESULT GetAt([in] DWORD nmd, [in] REFIID riid, [out, iid_is(riid)] void **ppv);
};

cpp_quote("SHSTDAPI SHGetPropertyDescription(REFPROPERTYKEY key, REFIID riid, void **ppv);")
cpp_quote("SHSTDAPI SHGetPropertyDescriptionByName(LPCWSTR pszCanonicalName, REFIID riid, void **ppv);")
cpp_quote("SHSTDAPI SHGetPropertyDescriptionListFromString(LPCWSTR pszPropList, REFIID riid, void **ppv);")

cpp_quote("#endif // (_WIN32_IE >= 0x0501)")


//-------------------------------------------------------------
// Folder Category Support
//-------------------------------------------------------------
cpp_quote("#if (_WIN32_IE >= 0x0500)")

[
    helpstring("Provides a list of catagorizers registered on an IShellFolder"),
    uuid(9af64809-5864-4c26-a720-c1f78c086ee3),
    object,
    pointer_default(unique)
]
interface ICategoryProvider : IUnknown
{
    [helpstring("Returns S_OK if the view should display this column in category selection UI, or S_FALSE to remove it.")]
    HRESULT CanCategorizeOnSCID(SHCOLUMNID* pscid);
    [helpstring("Returns either a GUID to create in CreateCategory, or a SHCOLUNNID that is used by the default categorizer. Return S_FALSE if you do not support a default group. "
                "GUID_NULL returned in pguid indicates to the client to use pscid as the default category.")]
    HRESULT GetDefaultCategory(GUID* pguid, SHCOLUMNID* pscid);
    [helpstring("Returns either a GUID that represents the categoizer to use for the specified SHCOLUMNID.")]
    HRESULT GetCategoryForSCID(SHCOLUMNID* pscid, GUID* pguid);
    [helpstring("Returns an IEnumGUID that has a list of GUIDs that represent categories.")]
    HRESULT EnumCategories(IEnumGUID** penum);
    [helpstring("Returns the name of the given category.")]
    HRESULT GetCategoryName(GUID* pguid, LPWSTR pszName, UINT cch);
    [helpstring("Creates the category.")]
    HRESULT CreateCategory(GUID* pguid, REFIID riid, [iid_is(riid)]void** ppv);
}

typedef [v1_enum] enum tagCATEGORYINFO_FLAGS
{
    CATINFO_NORMAL            = 0x00000000,   // Apply default properties to this category
    CATINFO_COLLAPSED         = 0x00000001,   // This category should appear collapsed. useful for the "None" category.
    CATINFO_HIDDEN            = 0x00000002,   // This category should follow the "Hidden" files setting for being displayed
    CATINFO_EXPANDED          = 0x00000003,   // This category should appear expanded.
    CATINFO_NOHEADER          = 0x00000004,   // This category has no header.
} CATEGORYINFO_FLAGS;

typedef [v1_enum] enum tagCATSORT_FLAGS
{
    CATSORT_DEFAULT     = 0x00000000,   // Default Sort order
    CATSORT_NAME        = 0x00000001,   // Sort by name
} CATSORT_FLAGS;

typedef struct tagCATEGORY_INFO
{
    CATEGORYINFO_FLAGS cif;
    WCHAR wszName[260];
} CATEGORY_INFO;


///////////////////////////////////////////////////////
//
// Drag and Drop helper
//
// Purpose: To expose the Shell drag images
//
// This interface is implemented in the shell by CLSID_DragDropHelper.
//
// To use:
//   If you are the source of a drag (i.e. in response to LV_DRAGBEGIN or
//    equivelent begin drag message) call
//    IDragSourceHelper::InitializeFromWindow
//              (<hwnd of window supporting DI_GETDRAGIMAGE>,
//               <pointer to POINT indicating offset to the mouse from
//                  the upper left corner of the image>,
//               <pointer to data object>)
//
//      NOTE: The Data object must support IDataObject::SetData with multiple
//            data types and GetData must implement data type cloning
//            (Including HGLOBAL), not just aliasing.
//
//   If you wish to have an image while over your application add the
//    IDragImages::Dr* calls to your IDropTarget implementation. For Example:
//
//    STDMETHODIMP CUserDropTarget::DragEnter(IDataObject* pDataObject,
//                                            DWORD grfKeyState,
//                                            POINTL pt, DWORD* pdwEffect)
//    {
//          // Process your DragEnter
//          // Call IDragImages::DragEnter last.
//          _pDropTargetHelper->DragEnter(_hwndDragOver, pDataObject,
//                                        (POINT*)&pt, *pdwEffect);
//          return hres;
//    }
//
//
//   If you wish to be able to source a drag image from a custom control,
//     implement a handler for the RegisterWindowMessage(DI_GETDRAGIMAGE).
//     The LPARAM is a pointer to an SHDRAGIMAGE structure.
//
//      sizeDragImage  -   Calculate the length and width required to render
//                          the images.
//      ptOffset       -   Calculate the offset from the upper left corner to
//                          the mouse cursor within the image
//      hbmpDragImage  -   CreateBitmap( sizeDragImage.cx, sizeDragImage.cy,
//                           GetDeviceCaps(hdcScreen, PLANES),
//                           GetDeviceCaps(hdcScreen, BITSPIXEL),
//                           NULL);
//
//   Drag Images will only be displayed on Windows NT 5.0 or later.
//
//
//   Note about IDropTargetHelper::Show - This method is provided for
//     showing/hiding the Drag image in low color depth video modes. When
//     painting to a window that is currently being dragged over (i.e. For
//     indicating a selection) you need to hide the drag image by calling this
//     method passing FALSE. After the window is done painting, Show the image
//     again by passing TRUE.

cpp_quote("#include <pshpack8.h>")
typedef struct tagSHDRAGIMAGE
{
    SIZE        sizeDragImage;      // OUT - The length and Width of the
                                    //        rendered image
    POINT       ptOffset;           // OUT - The Offset from the mouse cursor to
                                    //        the upper left corner of the image
    HBITMAP     hbmpDragImage;      // OUT - The Bitmap containing the rendered
                                    //        drag images
    COLORREF    crColorKey;         // OUT - The COLORREF that has been blitted
                                    //        to the background of the images
} SHDRAGIMAGE, *LPSHDRAGIMAGE;
cpp_quote("#include <poppack.h> // Return to byte packing")

// This is sent to a window to get the rendered images to a bitmap
// Call RegisterWindowMessage to get the ID
cpp_quote("#define DI_GETDRAGIMAGE     TEXT(\"ShellGetDragImage\")")

[
    uuid(4657278B-411B-11D2-839A-00C04FD918D0),
    local,
    pointer_default(unique)
]
interface IDropTargetHelper : IUnknown
{
    HRESULT DragEnter([in] HWND hwndTarget, [in] IDataObject* pDataObject, [in] POINT* ppt, [in] DWORD dwEffect);
    HRESULT DragLeave();
    HRESULT DragOver([in] POINT* ppt, [in] DWORD dwEffect);
    HRESULT Drop([in] IDataObject* pDataObject, [in] POINT* ppt, DWORD dwEffect);
    HRESULT Show([in] BOOL fShow);
};

[
    uuid(DE5BF786-477A-11D2-839D-00C04FD918D0),
    local,
    pointer_default(unique)
]
interface IDragSourceHelper: IUnknown
{
    // IDragSourceHelper
    HRESULT InitializeFromBitmap([in] LPSHDRAGIMAGE pshdi, [in] IDataObject* pDataObject);
    HRESULT InitializeFromWindow([in] HWND hwnd, [in] POINT* ppt, [in] IDataObject* pDataObject);
};


//-------------------------------------------------------------
// ICategorizer
//-------------------------------------------------------------

[
    helpstring("Categorizes items"),
    uuid(a3b14589-9174-49a8-89a3-06a1ae2b9ba7),
    object,
    pointer_default(unique)
]
interface ICategorizer : IUnknown
{
    [helpstring("Returns the description of this category that will be displayed in the UI")]
    HRESULT GetDescription(LPWSTR pszDesc, UINT cch);
    [helpstring("Returns a list of categories associated with a list of ID Lists. NOTE: -1 is an invalid Category ID, and they cannot be persisted")]
    HRESULT GetCategory([in] UINT cidl,
                        [in, size_is(cidl)] PCUITEMID_CHILD_ARRAY apidl,
                        [in, out, size_is(cidl)] DWORD* rgCategoryIds);

    [helpstring("Returns information about the category, such as default display and the text to display in the UI")]
    HRESULT GetCategoryInfo(DWORD dwCategoryId, CATEGORY_INFO* pci);
    [helpstring("Returns HRESULTFromShort. -1, 0, 1 indicate the comparison of the IDs. Used for sorting categories in the UI")]
    HRESULT CompareCategory(CATSORT_FLAGS csfFlags, DWORD dwCategoryId1, DWORD dwCategoryId2);
};

[
    helpstring("Provides for creation of category based drop targets"),
    uuid(504C9F82-0F68-47f4-8F63-083E58C88412),
    object,
    pointer_default(unique)
]
interface IDropTargetFactory : IUnknown
{
    [helpstring("Creates the DropTarget")]
    HRESULT CreateDropTarget([in] DWORD dwCategoryID, [in] REFIID riid, [out, iid_is(riid)] void **ppv);
};

cpp_quote("#endif // (_WIN32_IE >= 0x0500)")


cpp_quote("#ifdef UNICODE")
cpp_quote("#define IShellLink      IShellLinkW")
cpp_quote("#else")
cpp_quote("#define IShellLink      IShellLinkA")
cpp_quote("#endif")

// IShellLink::Resolve fFlags
typedef enum tagSLR_FLAGS
{
    SLR_NO_UI               = 0x0001,   // don't post any UI durring the resolve operation, not msgs are pumped
    SLR_ANY_MATCH           = 0x0002,   // no longer used
    SLR_UPDATE              = 0x0004,   // save the link back to it's file if the track made it dirty
    SLR_NOUPDATE            = 0x0008,
    SLR_NOSEARCH            = 0x0010,   // don't execute the search heuristics
    SLR_NOTRACK             = 0x0020,   // don't use NT5 object ID to track the link
    SLR_NOLINKINFO          = 0x0040,   // don't use the net and volume relative info
    SLR_INVOKE_MSI          = 0x0080,   // if we have a darwin link, then call msi to fault in the applicaion
    SLR_NO_UI_WITH_MSG_PUMP = 0x0101,   // SLR_NO_UI + requires an enable modeless site or HWND
} SLR_FLAGS;

// IShellLink::GetPath fFlags
typedef enum tagSLGP_FLAGS
{
    SLGP_SHORTPATH          = 0x0001,
    SLGP_UNCPRIORITY        = 0x0002,
    SLGP_RAWPATH            = 0x0004,
    SLGP_RELATIVEPRIORITY   = 0x0008,
} SLGP_FLAGS;

[
    uuid(000214EE-0000-0000-C000-000000000046),
    object,
    pointer_default(unique)
]
interface IShellLinkA : IUnknown
{
    HRESULT GetPath([out, size_is(cch)] LPSTR pszFile, [in] int cch, [in, out, ptr] WIN32_FIND_DATAA *pfd, [in] DWORD fFlags);
    HRESULT GetIDList([out] PIDLIST_ABSOLUTE * ppidl);
    HRESULT SetIDList([in] PCIDLIST_ABSOLUTE pidl);
    HRESULT GetDescription([out, size_is(cch)] LPSTR pszName, [in] int cch);
    HRESULT SetDescription([in] LPCSTR pszName);
    HRESULT GetWorkingDirectory([out, size_is(cch)] LPSTR pszDir, [in] int cch);
    HRESULT SetWorkingDirectory([in] LPCSTR pszDir);
    HRESULT GetArguments([out, size_is(cch)] LPSTR pszArgs, [in] int cch);
    HRESULT SetArguments([in] LPCSTR pszArgs);
    HRESULT GetHotkey([out] WORD *pwHotkey);
    HRESULT SetHotkey([in] WORD wHotkey);
    HRESULT GetShowCmd([out] int *piShowCmd);
    HRESULT SetShowCmd([in] int iShowCmd);
    HRESULT GetIconLocation([out, size_is(cch)] LPSTR pszIconPath, [in] int cch, [out] int *piIcon);
    HRESULT SetIconLocation([in] LPCSTR pszIconPath, [in] int iIcon);
    HRESULT SetRelativePath([in] LPCSTR pszPathRel, [in] DWORD dwReserved);
    HRESULT Resolve([in] HWND hwnd, [in] DWORD fFlags);
    HRESULT SetPath([in] LPCSTR pszFile);
};

[
    uuid(000214F9-0000-0000-C000-000000000046),
    object,
    pointer_default(unique)
]
interface IShellLinkW : IUnknown
{
    HRESULT GetPath([out, size_is(cch)] LPWSTR pszFile, [in] int cch, [in, out, ptr] WIN32_FIND_DATAW *pfd, [in] DWORD fFlags);
    HRESULT GetIDList([out] PIDLIST_ABSOLUTE * ppidl);
    HRESULT SetIDList([in] PCIDLIST_ABSOLUTE pidl);
    HRESULT GetDescription([out, size_is(cch)] LPWSTR pszName, int cch);
    HRESULT SetDescription([in] LPCWSTR pszName);
    HRESULT GetWorkingDirectory([out, size_is(cch)] LPWSTR pszDir, int cch);
    HRESULT SetWorkingDirectory([in] LPCWSTR pszDir);
    HRESULT GetArguments([out, size_is(cch)] LPWSTR pszArgs, int cch);
    HRESULT SetArguments([in] LPCWSTR pszArgs);
    HRESULT GetHotkey([out] WORD *pwHotkey);
    HRESULT SetHotkey([in] WORD wHotkey);
    HRESULT GetShowCmd([out] int *piShowCmd);
    HRESULT SetShowCmd([in] int iShowCmd);
    HRESULT GetIconLocation([out, size_is(cch)] LPWSTR pszIconPath, [in] int cch, [out] int *piIcon);
    HRESULT SetIconLocation([in] LPCWSTR pszIconPath, [in] int iIcon);
    HRESULT SetRelativePath([in] LPCWSTR pszPathRel, [in] DWORD dwReserved);
    HRESULT Resolve([in] HWND hwnd, [in] DWORD fFlags);
    HRESULT SetPath([in] LPCWSTR pszFile);
};


// Link resolution helpers - called when a link is created or needs to be resolved.

[
    object,
    uuid(5cd52983-9449-11d2-963a-00c04f79adf0),
    pointer_default(unique)
]
interface IResolveShellLink : IUnknown
{
    HRESULT ResolveShellLink([in] IUnknown *punkLink, [in] HWND hwnd, [in] DWORD fFlags);
}

[
    object,
    uuid(ed266937-99a3-42b7-b7a9-760ad135e537),
    pointer_default(unique)
]
interface IResolveShellLink2 : IResolveShellLink
{
    HRESULT CreateShellLink([in] IUnknown *punkLink);
}


[
    object,
    uuid(49ff1172-eadc-446d-9285-156453a6431c),
    pointer_default(unique)
]
interface IActionProgressDialog : IUnknown
{
    [v1_enum] enum tagSPINITF {
        SPINITF_NORMAL         = 0x00000000,      // default normal progress behavior
        SPINITF_MODAL          = 0x00000001,      // call punkSite->EnableModeless() or EnableWindow()
        SPINITF_NOMINIMIZE     = 0x00000008,      // Do not have a minimize button in the caption bar.
    };
    typedef DWORD SPINITF;

    HRESULT Initialize(
        [in] SPINITF flags,
        [in, string] LPCWSTR pszTitle,
        [in, string] LPCWSTR pszCancel);

    HRESULT Stop();
};

[
    object,
    uuid(f34bf05d-bda6-479e-b8b2-c07a8770c676),
    pointer_default(unique)
]
interface IProgressImage : IUnknown
{
    HRESULT SetTitleImage([in] IShellItem *psi);
};

[
    object,
    uuid(FFF994E6-E785-11D6-8F9F-00065BBD32BD),
    helpstring("HW Notification Handler Interface"),
    pointer_default(unique)
]
interface IHWNotificationHandler : IUnknown
{
    HRESULT Initialize([in, string] LPCWSTR pszParams);
    HRESULT HandleNotification([in, string] LPCWSTR pszPath);
};

cpp_quote("#define PREFERENCEOPTIONS_NEVER              0x00000001")
cpp_quote("#define PREFERENCEOPTIONS_PERMEDIAONLY       0x00000002")
cpp_quote("#define PREFERENCEOPTIONS_PERMEDIABYDEFAULT  0x00000004")

[
    object,
    uuid(C1FB73D0-EC3A-4ba2-B512-8CDB9187B6D1),
    helpstring("HW Event Handler Interface"),
    pointer_default(unique)
]
interface IHWEventHandler : IUnknown
{
    HRESULT Initialize([in, string] LPCWSTR pszParams);
    HRESULT HandleEvent([in, string] LPCWSTR pszDeviceID,
        [in, string] LPCWSTR pszAltDeviceID,
        [in, string] LPCWSTR pszEventType);
    HRESULT HandleEventWithContent([in, string] LPCWSTR pszDeviceID,
        [in, string] LPCWSTR pszAltDeviceID,
        [in, string] LPCWSTR pszEventType,
        [in, string] LPCWSTR pszContentTypeHandler,
        [in] IDataObject* pdataobject);
};

cpp_quote("#define ARCONTENT_AUTORUNINF             0x00000002") // That's the one we have today, and always had
cpp_quote("#define ARCONTENT_AUDIOCD                0x00000004") // Audio CD (not MP3 and the like, the stuff you buy at the store)
cpp_quote("#define ARCONTENT_DVDMOVIE               0x00000008") // DVD Movie (not MPEGs, the stuff you buy at the store)
cpp_quote("#define ARCONTENT_BLANKCD                0x00000010") // Blank CD-R/CD-RW
cpp_quote("#define ARCONTENT_BLANKDVD               0x00000020") // Blank DVD-R/DVD-RW
cpp_quote("#define ARCONTENT_UNKNOWNCONTENT         0x00000040") // Whatever files.  Mean that it's formatted.
cpp_quote("#define ARCONTENT_AUTOPLAYPIX            0x00000080") //
cpp_quote("#define ARCONTENT_AUTOPLAYMUSIC          0x00000100") //
cpp_quote("#define ARCONTENT_AUTOPLAYVIDEO          0x00000200") //
cpp_quote("#define ARCONTENT_VIDEOCDMOVIE           0x00000400") //
cpp_quote("#define ARCONTENT_SUPERVIDEOCDMOVIE      0x00000800") //
cpp_quote("#define ARCONTENT_PORTABLEUSERPROFILE    0x00001000") //
cpp_quote("#define ARCONTENT_DVDAUDIO               0x00002000") //

[
    object,
    uuid(DDEFE873-6997-4e68-BE26-39B633ADBE12),
    helpstring("HW Event Handler Interface"),
    pointer_default(unique)
]
interface IQueryCancelAutoPlay : IUnknown
{
    HRESULT AllowAutoPlay([in, string]LPCWSTR pszPath, [in]DWORD dwContentType,
      [in, string]LPCWSTR pszLabel, [in] DWORD dwSerialNumber);
};

cpp_quote("#define DYNHWHANDLER_SHOW                0x00000001")
cpp_quote("#define DYNHWHANDLER_DYNAMICACTIONSTRING 0x00000002")

[
    object,
    uuid(FFF994DA-E785-11D6-8F9F-00065BBD32BD),
    helpstring("Dynamic HW Handler Interface"),
    pointer_default(unique)
]
interface IDynamicHWHandler : IUnknown
{
    HRESULT GetDynamicInfo([in, string]LPCWSTR pszDeviceID, [out] DWORD* pdwFlags);
    HRESULT GetActionString([out, string] LPWSTR* ppszAction);
};

[
    object,
    uuid(49ff1173-eadc-446d-9285-156453a6431c),
    pointer_default(unique)
]
interface IActionProgress : IUnknown
{
    [v1_enum] enum tagSPBEGINF {
        SPBEGINF_NORMAL             = 0x00000000,      // default normal progress behavior
        SPBEGINF_AUTOTIME           = 0x00000002,      // automatically updates the "time remaining" text
        SPBEGINF_NOPROGRESSBAR      = 0x00000010,      // Don't display the progress bar (SetProgress() wont be called)
        SPBEGINF_MARQUEEPROGRESS    = 0x00000020,      // use marquee progress (comctl32 v6 required)
        SPBEGINF_NOCANCELBUTTON     = 0x00000040,      // no cancel button
    };
    typedef DWORD SPBEGINF;

    typedef [v1_enum] enum _SPACTION {
        SPACTION_NONE            = 0,
        SPACTION_MOVING,
        SPACTION_COPYING,
        SPACTION_RECYCLING,
        SPACTION_APPLYINGATTRIBS,
        SPACTION_DOWNLOADING,
        SPACTION_SEARCHING_INTERNET,
        SPACTION_CALCULATING,
        SPACTION_UPLOADING,
        SPACTION_SEARCHING_FILES,
        SPACTION_DELETING,
    } SPACTION;

    HRESULT Begin(
        [in] SPACTION action,
        [in] SPBEGINF flags);

    HRESULT UpdateProgress(
        [in] ULONGLONG ulCompleted,
        [in] ULONGLONG ulTotal);

    typedef [v1_enum] enum _SPTEXT
    {
        SPTEXT_ACTIONDESCRIPTION        = 1,
        SPTEXT_ACTIONDETAIL,
    } SPTEXT;

    HRESULT UpdateText(
        [in] SPTEXT sptext,
        [in, string] LPCWSTR pszText,
        [in] BOOL fMayCompact);

    HRESULT QueryCancel([out] BOOL * pfCancelled);
    HRESULT ResetCancel();

    HRESULT End();

};

//  The IShellExtInit interface is used by the explorer to initialize shell
// extension objects. The explorer (1) calls CoCreateInstance (or equivalent)
// with the registered CLSID and IID_IShellExtInit, (2) calls its Initialize
// member, then (3) calls its QueryInterface to a particular interface (such
// as IContextMenu or IPropSheetExt and (4) performs the rest of operation.
//
// IShellExtInit::Initialize
//
//  This member function is called when the explorer is initializing either
// context menu extension, property sheet extension or non-default drag-drop
// extension.
//
//  Parameters: (context menu or property sheet extension)
//   pidlFolder -- Specifies the parent folder
//   lpdobj -- Spefifies the set of items selected in that folder.
//   hkeyProgID -- Specifies the type of the focused item in the selection.
//
//  Parameters: (non-default drag-and-drop extension)
//   pidlFolder -- Specifies the target (destination) folder
//   lpdobj -- Specifies the items that are dropped (see the description
//    about shell's clipboard below for clipboard formats).
//   hkeyProgID -- Specifies the folder type.

[
    uuid(000214E8-0000-0000-C000-000000000046),
    object,
    local,
    pointer_default(unique)
]
interface IShellExtInit : IUnknown
{
    HRESULT Initialize([in] PCIDLIST_ABSOLUTE pidlFolder, [in] IDataObject *pdtobj, [in] HKEY hkeyProgID);
}
typedef IShellExtInit * LPSHELLEXTINIT;


//  The explorer uses the IShellPropSheetExt to allow property sheet
// extensions or control panel extensions to add additional property
// sheet pages.
//
// IShellPropSheetExt::AddPages
//
//  The explorer calls this member function when it finds a registered
// property sheet extension for a particular type of object. For each
// additional page, the extension creates a page object by calling
// CreatePropertySheetPage API and calls lpfnAddPage.
//
//  Parameters:
//   lpfnAddPage -- Specifies the callback function.
//   lParam -- Specifies the opaque handle to be passed to the callback function.
//
//
// IShellPropSheetExt::ReplacePage
//
//  The explorer never calls this member of property sheet extensions. The
// explorer calls this member of control panel extensions, so that they
// can replace some of default control panel pages (such as a page of
// mouse control panel).
//
//  Parameters:
//   uPageID -- Specifies the page to be replaced.
//   lpfnReplace Specifies the callback function.
//   lParam -- Specifies the opaque handle to be passed to the callback function.
//
[
    uuid(000214E9-0000-0000-C000-000000000046),
    object,
    local,
    pointer_default(unique)
]
interface IShellPropSheetExt : IUnknown
{
    HRESULT AddPages([in] LPFNSVADDPROPSHEETPAGE pfnAddPage, [in] LPARAM lParam);
    enum tagSHELLPROPSHEETEXTPAGEID
    {
        EXPPS_FILETYPES     = 0x00000001,
    };
    typedef UINT EXPPS;
    HRESULT ReplacePage([in] EXPPS uPageID, [in] LPFNSVADDPROPSHEETPAGE pfnReplaceWith, [in] LPARAM lParam);
}
typedef IShellPropSheetExt * LPSHELLPROPSHEETEXT;

// used by a property sheet extension to indicate that it has a managed avalon details page equivalent,
// thus the property sheet shouldnt be added to the win32 dialog.
typedef
[
    helpstring("Constants for IShellPropSheetExt2::AddPages2")
]
enum tagPropPageSettings
{
    PS_DEFAULT                             = 0x0,
    PS_DONT_ADD_IF_MANAGED_PROPPAGE_EXISTS = 0x1,
} PAGESETTINGS;

[
    uuid(137a39c6-34bf-4f52-a18d-39e951714c37),
    object,
    local,
    pointer_default(unique)
]
interface IShellPropSheetExt2 : IShellPropSheetExt
{
    HRESULT AddPages2([in] LPFNSVADDPROPSHEETPAGE pfnAddPage, [in] LPARAM lParam, [in] PAGESETTINGS pagesettings, [out] BOOL *pfHasManagedPropPage);
}

[
    helpstring("used to initialize an object on a remote computer (server)"),
    uuid(000214FE-0000-0000-C000-000000000046),
    object,
    pointer_default(unique)
]
interface IRemoteComputer : IUnknown
{
    // function is called when the explorer is initializing or
    // enumerating the name space extension. If failure is returned during
    // enumeration, the extension won't appear for this computer. Otherwise,
    // the extension will appear, and should target the given machine.
    //
    // pszMachine       Specifies the name of the machine to target. (\\server)
    // bEnumerationg    test to see if this object should be enumerated
    //                  on this server
    HRESULT Initialize([in] LPCWSTR pszMachine, [in] BOOL bEnumerating);
};

[
    uuid(7307055c-b24a-486b-9f25-163e597a28a9), object, pointer_default(unique)
]
interface IQueryContinue : IUnknown
{
    HRESULT QueryContinue();    // S_OK -> Continue, other
};

[
    uuid(ba9711ba-5893-4787-a7e1-41277151550b), object, pointer_default(unique)
]
interface IUserNotification : IUnknown
{
    HRESULT SetBalloonInfo([in, string] LPCWSTR pszTitle, [in, string] LPCWSTR pszText, [in] DWORD dwInfoFlags);
    // times in msec
    HRESULT SetBalloonRetry([in] DWORD dwShowTime, [in] DWORD dwInterval, [in] UINT cRetryCount);
    HRESULT SetIconInfo([in] HICON hIcon, [in, string] LPCWSTR pszToolTip);
    HRESULT Show([in] IQueryContinue *pqc, [in] DWORD dwContinuePollInterval);
    HRESULT PlaySound([in, string] LPCWSTR pszSoundName);
};


// interface for describing the limits placed on a name, used for validation
// parsing and translation.

[
    uuid(1df0d7f1-b267-4d28-8b10-12e23202a5c4)
]
interface IItemNameLimits : IUnknown
{
    HRESULT GetValidCharacters([out] LPWSTR *ppwszValidChars, [out] LPWSTR *ppwszInvalidChars);
    HRESULT GetMaxLength([in] LPCWSTR pszName, [out] int *piMaxNameLen);
};



cpp_quote("#if (_WIN32_IE >= 0x0400)")

// --- IExtractImage
// this interface is provided for objects to provide a thumbnail image.
// IExtractImage::GetLocation()
//      Gets a path description of the image that is to be extracted. This is used to
//      identify the image in the view so that multiple instances of the same image can reuse the
//      original image. If *pdwFlags == IEIFLAG_ASYNC and the result is E_PENDING, then *pdwPriority
//      is used to return the priority of the item, this is usually a measure of how long it will take
//      to perform the extraction. *pdwFlags can return IEIFLAG_CACHE if the view should cache a copy
//      of the image for future reference and faster access. This flag is used to tell the difference
//      between file formats that cache a thumbnail image such as Flashpix or Office documents, and those
//      that don't cache one.
// IExtractImage::Extract()
//      Extract the thumbnail of the specified size. If GetLocation() returned the values indicating
//      it is free-threaded and can be placed on a background thread. If the object
//      supports IRunnableTask as well, then long extractions can be started and paused as appropriate.
//      At this point it is asssumed the object is free-threaded.
//      If dwRecClrDepth contains a recommended Colour depth
//      If *phBmpthumbnail is non NULL, then it contains the destination bitmap that should be used.

cpp_quote("#define IEI_PRIORITY_MAX        ITSAT_MAX_PRIORITY")
cpp_quote("#define IEI_PRIORITY_MIN        ITSAT_MIN_PRIORITY")
cpp_quote("#define IEIT_PRIORITY_NORMAL     ITSAT_DEFAULT_PRIORITY")

cpp_quote("#define IEIFLAG_ASYNC       0x0001      // ask the extractor if it supports ASYNC extract (free threaded)")
cpp_quote("#define IEIFLAG_CACHE       0x0002      // returned from the extractor if it does NOT cache the thumbnail")
cpp_quote("#define IEIFLAG_ASPECT      0x0004      // passed to the extractor to beg it to render to the aspect ratio of the supplied rect")
cpp_quote("#define IEIFLAG_OFFLINE     0x0008      // if the extractor shouldn't hit the net to get any content neede for the rendering")
cpp_quote("#define IEIFLAG_GLEAM       0x0010      // does the image have a gleam ? this will be returned if it does")
cpp_quote("#define IEIFLAG_SCREEN      0x0020      // render as if for the screen  (this is exlusive with IEIFLAG_ASPECT )")
cpp_quote("#define IEIFLAG_ORIGSIZE    0x0040      // render to the approx size passed, but crop if neccessary")
cpp_quote("#define IEIFLAG_NOSTAMP     0x0080      // returned from the extractor if it does NOT want an icon stamp on the thumbnail")
cpp_quote("#define IEIFLAG_NOBORDER    0x0100      // returned from the extractor if it does NOT want an a border around the thumbnail")
cpp_quote("#define IEIFLAG_QUALITY     0x0200      // passed to the Extract method to indicate that a slower, higher quality image is desired, re-compute the thumbnail")
cpp_quote("#define IEIFLAG_REFRESH     0x0400      // returned from the extractor if it would like to have Refresh Thumbnail available")
cpp_quote("#define IEIFLAG_INFOTIP     0x0800      // render the thumbnail for the infotip of the item")

[
    uuid(BB2E617C-0920-11d1-9A0B-00C04FC2D6C1),
    object,
    pointer_default(unique)
]
interface IExtractImage : IUnknown
{
    HRESULT GetLocation([out, size_is(cch)] LPWSTR pszPathBuffer,
                        [in] DWORD cch,
                        [in, out, unique] DWORD *pdwPriority,
                        [in] const SIZE * prgSize,
                        [in] DWORD dwRecClrDepth,
                        [in, out] DWORD *pdwFlags);

   HRESULT Extract([out] HBITMAP *phBmpThumbnail);
}
typedef IExtractImage * LPEXTRACTIMAGE;

cpp_quote("#endif")

cpp_quote("#if (_WIN32_IE >= 0x0500)")

// GetDateStamp : returns the date stamp associated with the image. If this image is already cached,
//                then it is easy to find out if the image is out of date.

[
    uuid(953BB1EE-93B4-11d1-98A3-00C04FB687DA),
    object,
    pointer_default(unique)
]
interface IExtractImage2 : IExtractImage
{
    HRESULT GetDateStamp([out] FILETIME *pDateStamp);
}
typedef IExtractImage2 * LPEXTRACTIMAGE2;

cpp_quote("#endif")



//-------------------------------------------------------------------------
//
// IDockingWindow interface
//
//   An object (docking window) implements this interface so the site can
// communicate with it.  An example of a docking window is a toolbar.
//
// [Member functions]
//
// IDockingWindow::ShowDW(fShow)
//   Shows or hides the docking window.
//
// IDockingWindow::CloseDW(dwReserved)
//   Closes the docking window.  dwReserved must be 0.
//
// IDockingWindow::ResizeBorderDW(prcBorder, punkToolbarSite, fReserved)
//   Resizes the docking window's border to *prcBorder.  fReserved must
//   be 0.
//
// IObjectWithSite::SetSite(punkSite)
//   IDockingWindow usually paired with IObjectWithSite.
//   Provides the IUnknown pointer of the site to the docking window.
//
//-------------------------------------------------------------------------

[
    uuid(012dd920-7b26-11d0-8ca9-00a0c92dbfe8),
    object
]
interface IDockingWindow : IOleWindow
{
    HRESULT ShowDW([in] BOOL fShow);
    HRESULT CloseDW([in] DWORD dwReserved);
    HRESULT ResizeBorderDW([in] LPCRECT prcBorder, [in] IUnknown* punkToolbarSite, [in] BOOL fReserved);
};

//-------------------------------------------------------------------------
//
// IDeskBand interface
//
//
// [Member functions]
//
// IDeskBand::GetBandInfo(dwBandID, dwViewMode, pdbi)
//   Returns info on the given band in *pdbi, according to the mask
//   field in the DESKBANDINFO structure and the given viewmode.
//
//-------------------------------------------------------------------------


// Mask values for DESKBANDINFO
cpp_quote("#define DBIM_MINSIZE    0x0001")
cpp_quote("#define DBIM_MAXSIZE    0x0002")
cpp_quote("#define DBIM_INTEGRAL   0x0004")
cpp_quote("#define DBIM_ACTUAL     0x0008")
cpp_quote("#define DBIM_TITLE      0x0010")
cpp_quote("#define DBIM_MODEFLAGS  0x0020")
cpp_quote("#define DBIM_BKCOLOR    0x0040")

cpp_quote("#include <pshpack8.h>")

typedef struct tagDESKBANDINFO
{
    DWORD       dwMask;
    POINTL      ptMinSize;
    POINTL      ptMaxSize;
    POINTL      ptIntegral;
    POINTL      ptActual;
    WCHAR       wszTitle[256];
    DWORD       dwModeFlags;
    COLORREF    crBkgnd;
} DESKBANDINFO;

cpp_quote("#include <poppack.h>")   // Return to byte packing

// DESKBANDINFO dwModeFlags values
cpp_quote("#define DBIMF_NORMAL            0x0000")
cpp_quote("#define DBIMF_FIXED             0x0001")
cpp_quote("#define DBIMF_FIXEDBMP          0x0004   // a fixed background bitmap (if supported)")
cpp_quote("#define DBIMF_VARIABLEHEIGHT    0x0008")
cpp_quote("#define DBIMF_UNDELETEABLE      0x0010")
cpp_quote("#define DBIMF_DEBOSSED          0x0020")
cpp_quote("#define DBIMF_BKCOLOR           0x0040")
cpp_quote("#define DBIMF_USECHEVRON        0x0080")
cpp_quote("#define DBIMF_BREAK             0x0100")
cpp_quote("#define DBIMF_ADDTOFRONT        0x0200")
cpp_quote("#define DBIMF_TOPALIGN          0x0400")
cpp_quote("#define DBIMF_NOGRIPPER         0x0800")
cpp_quote("#define DBIMF_ALWAYSGRIPPER     0x1000")

// GetBandInfo view mode values
cpp_quote("#define DBIF_VIEWMODE_NORMAL         0x0000")
cpp_quote("#define DBIF_VIEWMODE_VERTICAL       0x0001")
cpp_quote("#define DBIF_VIEWMODE_FLOATING       0x0002")
cpp_quote("#define DBIF_VIEWMODE_TRANSPARENT    0x0004")

// Command Target IDs
enum tagDESKBANDCID {
    DBID_BANDINFOCHANGED    = 0,
    DBID_SHOWONLY           = 1,
    DBID_MAXIMIZEBAND       = 2,      // Maximize the specified band (VT_UI4 == dwID)
    DBID_PUSHCHEVRON        = 3,
    DBID_DELAYINIT          = 4,      // Note: _bandsite_ calls _band_ with this code
    DBID_FINISHINIT         = 5,      // Note: _bandsite_ calls _band_ with this code
    DBID_SETWINDOWTHEME     = 6,      // Note: _bandsite_ calls _band_ with this code
    DBID_PERMITAUTOHIDE     = 7,
};

cpp_quote("#define DBPC_SELECTFIRST    (DWORD)-1")
cpp_quote("#define DBPC_SELECTLAST     (DWORD)-2")

cpp_quote("#define CGID_DeskBand IID_IDeskBand")

[
    uuid(EB0FE172-1A3A-11D0-89B3-00A0C90A90AC),
    object,
]
interface IDeskBand : IDockingWindow
{
    HRESULT GetBandInfo([in] DWORD dwBandID, [in] DWORD dwViewMode, [in, out] DESKBANDINFO* pdbi);
};


//-------------------------------------------------------------------------
//
// ITaskbarList interface
//
//
// [Member functions]
//
// ITaskbarList::HrInit()
//   This function must be called first to validate use of other members.
//
// ITaskbarList::AddTab(hwnd)
//   This function adds a tab for hwnd to the taskbar.
//
// ITaskbarList::DeleteTab(hwnd)
//   This function deletes a tab for hwnd from the taskbar.
//
// ITaskbarList::ActivateTab(hwnd)
//   This function activates the tab associated with hwnd on the taskbar.
//
// ITaskbarList::SetActivateAlt(hwnd)
//   This function marks hwnd in the taskbar as the active tab
//
//-------------------------------------------------------------------------
[
    uuid(56FDF342-FD6D-11d0-958A-006097C9A090),
    object,
]
interface ITaskbarList : IUnknown
{
    HRESULT HrInit();
    HRESULT AddTab([in] HWND hwnd);
    HRESULT DeleteTab([in] HWND hwnd);
    HRESULT ActivateTab([in] HWND hwnd);
    HRESULT SetActiveAlt([in] HWND hwnd);
};

[
    uuid(602D4995-B13A-429b-A66E-1935E44F4317),
    object,
]
interface ITaskbarList2 : ITaskbarList
{
    HRESULT MarkFullscreenWindow([in] HWND hwnd, [in] BOOL fFullscreen);
};


[
    object,
    uuid(3d73a659-e5d0-4d42-afc0-5121ba425c8d),     // IID_ICDBurn
    pointer_default(unique)
]
interface ICDBurn : IUnknown
{
    HRESULT GetRecorderDriveLetter([out, size_is(cch)] LPWSTR pszDrive, [in] UINT cch);
    HRESULT Burn([in] HWND hwnd);
    HRESULT HasRecordableDrive([out] BOOL *pfHasRecorder);
};

// Wizard Extension objects.  These interfaces defined methods for extending
// Win32 wizard in a progromatic way.

// Range of ID's that extensions can used, these mustn't clash with
// the existing wizards dialog IDS.  (That enables them to still
// do PropSheet_SetCurSelByID).

cpp_quote("#define IDD_WIZEXTN_FIRST    0x5000")
cpp_quote("#define IDD_WIZEXTN_LAST     0x5100")


// This site object is requested via a QueryService of the objects site,
// it allows the extension to navigate in/out out itself, eg. when the
// extension has shown all of its pages and wants to navigate to the
// next page it would call GetNextPage and select the specified HPAGE.

[
    uuid(88960f5b-422f-4e7b-8013-73415381c3c3),
    helpstring("Wizard Extension Site"),
    local
]
interface IWizardSite : IUnknown
{
    HRESULT GetPreviousPage([out] HPROPSHEETPAGE *phpage);
    HRESULT GetNextPage([out] HPROPSHEETPAGE *phpage);
    HRESULT GetCancelledPage([out] HPROPSHEETPAGE *phpage);
};

cpp_quote("#define SID_WizardSite IID_IWizardSite")


// A wizard extension is implemented using this object, the extension will declare the
// pages that it supports using the AddPages method, and then when its host needs to navigate
// into the extenion it will do so via GetFirstPage and selecting that.

[
    uuid(c02ea696-86cc-491e-9b23-74394a0444a8),
    helpstring("Wizard Extension"),
    local
]
interface IWizardExtension : IUnknown
{
    HRESULT AddPages([in, out] HPROPSHEETPAGE* aPages, [in] UINT cPages, [out] UINT *pnPagesAdded);
    HRESULT GetFirstPage([out] HPROPSHEETPAGE *phpage);
    HRESULT GetLastPage([out] HPROPSHEETPAGE *phpage);
};


// The Web Wizard is a HTML host for wizard pages, it allows you
// create a HTML wizard starting at the URL defined via SetInitialURL.

[
    helpstring("Web Wizard Page Extension"),
    uuid(0e6b3f66-98d1-48c0-a222-fbde74e2fbc5),
    object,
    pointer_default(unique)
]
interface IWebWizardExtension : IWizardExtension
{
    HRESULT SetInitialURL([in, string] LPCWSTR pszURL);
    HRESULT SetErrorURL([in, string] LPCWSTR pszErrorURL);
};

cpp_quote("#define SID_WebWizardHost IID_IWebWizardExtension")


// flags for the host to control the publishing wizard

cpp_quote ("#define SHPWHF_NORECOMPRESS             0x00000001  // don't allow/prompt for recompress of streams")
cpp_quote ("#define SHPWHF_NONETPLACECREATE         0x00000002  // don't create a network place when transfer is complete")
cpp_quote ("#define SHPWHF_NOFILESELECTOR           0x00000004  // don't show the file selector")
cpp_quote ("#define SHPWHF_ANYLOCATION              0x00000100  // allow publishing to any location")
cpp_quote ("#define SHPWHF_VALIDATEVIAWEBFOLDERS    0x00010000  // enable web folders to validate network places (ANP support)")

[
    helpstring("Web Publishing Wizard"),
    uuid(aa9198bb-ccec-472d-beed-19a4f6733f7a),
    object,
    pointer_default(unique)
]
interface IPublishingWizard : IWizardExtension
{
    HRESULT Initialize([in] IDataObject *pdo, [in] DWORD dwOptions, [in, string] LPCWSTR pszServiceScope);
    HRESULT GetTransferManifest([out] HRESULT *phrFromTransfer, [out] IXMLDOMDocument **pdocManifest);
}

[
    uuid(6d1b6ff1-badd-440f-b85d-c6a491fb405c),
    object,
    pointer_default(unique)
]
interface IPublishingWizard2 : IPublishingWizard
{
    HRESULT GetIDArrayToPublish([out] UINT *pcItems, [out, size_is(,*pcItems,)] PIDLIST_ABSOLUTE **pppidl);
    HRESULT GetServiceScope([out, size_is(cchServiceScope)] LPWSTR pszServiceScope, [in]UINT cchServiceScope);
}


// Object to host an IFolderView in a window.  This is used to build check mark selection
// UI for files.
[
    uuid(1ea58f02-d55a-411d-b09e-9e65ac21605b),
    helpstring("Shell Folder Host"),
    local,
]
interface IFolderViewHost : IUnknown
{
    HRESULT Initialize([in] HWND hwndParent, [in] IDataObject *pdo, [in] RECT *prc);
};

[
    uuid(efe62d8a-c624-49ab-bf35-046be19966de),
    helpstring("Device Picker Shell Folder Host"),
    local,
]
interface IDevicePickerFolderViewHost : IFolderFilterSite
{
    HRESULT Initialize([in] HWND hwnd, [in] RECT *prc);
    HRESULT GetView([in] REFIID riid, [out, iid_is(riid)] void **ppv);
};

[
    helpstring("Unknown Object Enumerator"),
    uuid(2c1c7e2e-2d0e-4059-831e-1e6f82335c2e),
    object,
    pointer_default(unique)
]
interface IEnumObjects : IUnknown
{
    HRESULT Next(
        [in] ULONG celt,
        [in] REFIID riid,
        [out, size_is(celt), length_is(*pceltFetched), iid_is(riid)] void **rgelt,
        [out] ULONG *pceltFetched);

    HRESULT Skip([in] ULONG celt);
    HRESULT Reset();
    HRESULT Clone([out] IEnumObjects **ppenum);
};

[
    uuid(a6087428-3be3-4d73-b308-7c04a540bf1a),
    object,
    pointer_default(unique)
]
interface IObjectProvider : IUnknown
{
    //  IObjectProvider is similar to IServiceProvider
    //  except that it does not imply that unhandled/unknown
    //  requests should be forwarded, as IServiceProvider does.
    HRESULT QueryObject(
        [in] REFGUID guidObject,
        [in] REFIID riid,
        [out, iid_is(riid)] void **ppvOut);
};

[
    uuid(d92995f8-cf5e-4a76-bf59-ead39ea2b97e),
    helpstring("shell name space walking callback interface"),
]
interface INamespaceWalkCB : IUnknown
{
    HRESULT FoundItem([in] IShellFolder *psf, [in] PCUITEMID_CHILD pidl);
    HRESULT EnterFolder([in] IShellFolder *psf, [in] PCUITEMID_CHILD pidl);
    HRESULT LeaveFolder([in] IShellFolder *psf, [in] PCUITEMID_CHILD pidl);
    HRESULT InitializeProgressDialog([out, string] LPWSTR *ppszTitle, [out, string] LPWSTR *ppszCancel);
};

[
    uuid(7ac7492b-c38e-438a-87db-68737844ff70),
]
interface INamespaceWalkCB2 : INamespaceWalkCB
{
    HRESULT WalkComplete(HRESULT hr);
};

[
    uuid(57ced8a7-3f4a-432c-9350-30f24483f74f),
    helpstring("shell name space walk, used to expand data objects, views or recurse folders"),
]
interface INamespaceWalk : IUnknown
{
    enum tagNAMESPACEWALKFLAG
    {
        NSWF_NONE_IMPLIES_ALL          = 0x00000001,
        NSWF_ONE_IMPLIES_ALL           = 0x00000002,
        NSWF_DONT_TRAVERSE_LINKS       = 0x00000004,
        NSWF_DONT_ACCUMULATE_RESULT    = 0x00000008,
        NSWF_TRAVERSE_STREAM_JUNCTIONS = 0x00000010,
        NSWF_FILESYSTEM_ONLY           = 0x00000020,
        NSWF_SHOW_PROGRESS             = 0x00000040,
        NSWF_FLAG_VIEWORDER            = 0x00000080,
        NSWF_IGNORE_AUTOPLAY_HIDA      = 0x00000100,
        NSWF_ASYNC                     = 0x00000200,
        NSWF_DONT_RESOLVE_LINKS        = 0x00000400,
        NSWF_ACCUMULATE_FOLDERS        = 0x00000800,
        NSWF_DONT_SORT                 = 0x00001000,    // Don't maintain sort order of items
        NSWF_USE_STORAGE_ENUM          = 0x00002000,    // Use SHCONTF_STORAGE in enumerations
        NSWF_USE_WALKTREE_ENUM         = 0x00004000,    // Use SHCONTF_WALKTREE in enumerations
    };

    // punkToWalk can be an IShellView site, IShellFolder or IDataObject
    HRESULT Walk([in] IUnknown *punkToWalk, [in] DWORD dwFlags, [in] int cDepth, [in] INamespaceWalkCB *pnswcb);
    HRESULT GetIDArrayResult([out] UINT *pcItems, [out, size_is(,*pcItems,)] PIDLIST_ABSOLUTE **prgpidl);
};

cpp_quote("_inline void FreeIDListArray(PIDLIST_RELATIVE *ppidls, UINT cItems)")
cpp_quote("{                                        ")
cpp_quote("     UINT i;                             ")
cpp_quote("     for (i = 0; i < cItems; i++)        ")
cpp_quote("     {                                   ")
cpp_quote("         CoTaskMemFree(ppidls[i]);       ")
cpp_quote("     }                                   ")
cpp_quote("     CoTaskMemFree(ppidls);              ")
cpp_quote("}                                        ")
cpp_quote("#if defined(STRICT_TYPED_ITEMIDS) && defined(__cplusplus)")
cpp_quote("_inline void FreeIDListArrayFull(PIDLIST_ABSOLUTE *ppidls, UINT cItems)")
cpp_quote("{                                        ")
cpp_quote("     for (UINT i = 0; i < cItems; i++)   ")
cpp_quote("     {                                   ")
cpp_quote("         CoTaskMemFree(ppidls[i]);       ")
cpp_quote("     }                                   ")
cpp_quote("     CoTaskMemFree(ppidls);              ")
cpp_quote("}                                        ")
cpp_quote("_inline void FreeIDListArrayChild(PITEMID_CHILD *ppidls, UINT cItems)")
cpp_quote("{                                        ")
cpp_quote("     for (UINT i = 0; i < cItems; i++)   ")
cpp_quote("     {                                   ")
cpp_quote("         CoTaskMemFree(ppidls[i]);       ")
cpp_quote("     }                                   ")
cpp_quote("     CoTaskMemFree(ppidls);              ")
cpp_quote("}                                        ")
cpp_quote("#else //  defined(STRICT_TYPED_ITEMIDS) && defined(__cplusplus)")
cpp_quote("#define FreeIDListArrayFull FreeIDListArray")
cpp_quote("#define FreeIDListArrayChild FreeIDListArray")
cpp_quote("#endif //  defined(STRICT_TYPED_ITEMIDS) && defined(__cplusplus)")


//
//  Flags for IAutoCompleteDropDown::GetDropDownStatus
//
cpp_quote("#define ACDD_VISIBLE        0x0001")

[
    uuid(3CD141F4-3C6A-11d2-BCAA-00C04FD929DB),
    object,
    pointer_default(unique)
]
interface IAutoCompleteDropDown : IUnknown
{
    HRESULT GetDropDownStatus([out] DWORD *pdwFlags, [out, string] LPWSTR *ppwszString);
    HRESULT ResetEnumerator();
};

cpp_quote("#define PPW_LAUNCHEDBYUSER       0x00000001      // The wizard was launch explicitly by the user, not on demand by the key manager")

[
    helpstring("Passport Wizard"),
    uuid(a09db586-9180-41ac-9114-460a7f362b76),
    object,
    pointer_default(unique)
]
interface IPassportWizard : IModalWindow
{
    HRESULT SetOptions([in] DWORD dwOptions);
};


// the cd burning wizard extension sets return codes through a property bag
// to tell the main wizard whether it should stop or keep going
cpp_quote("#define PROPSTR_EXTENSIONCOMPLETIONSTATE L\"ExtensionCompletionState\"")
enum tagCDBURNINGEXTENSIONRET
{
    CDBE_RET_DEFAULT          = 0x00000000,
    CDBE_RET_DONTRUNOTHEREXTS = 0x00000001,
    CDBE_RET_STOPWIZARD       = 0x00000002,
};
cpp_quote("#define SID_CDWizardHost IID_ICDBurnExt")

enum tagCDBURNINGEXTENSIONACTION
{
    CDBE_TYPE_MUSIC = 0x00000001,
    CDBE_TYPE_DATA  = 0x00000002,
    CDBE_TYPE_ALL   = 0xFFFFFFFF
};
typedef int CDBE_ACTIONS;

[
    uuid(2271dcca-74fc-4414-8fb7-c56b05ace2d7),
    helpstring("add-ons for cd burning"),
]
interface ICDBurnExt : IUnknown
{
    HRESULT GetSupportedActionTypes([out] CDBE_ACTIONS *pdwActions);
}

typedef void (*PFDVENUMREADYBALLBACK)(LPVOID pvData);

[
    helpstring("simple interface for showing a window"),
    uuid(b4db1657-70d7-485e-8e3e-6fcb5a5c1802),
    object,
    pointer_default(unique)
]
interface IModalWindow : IUnknown
{
    [local]HRESULT Show([in] HWND hwndParent);
    [call_as(Show)] HRESULT RemoteShow([in] HWND hwndParent);
};

//-----------------------------------------
// Keywords
//-----------------------------------------

//
// interface for communication between the view and the Explorer band treeview control
//
[
    uuid(70F55181-5FEA-4900-B6B8-7343CB0A348C),
    helpstring("Private interface between CDefView and Explorer band"),
    local
]
interface IDVGetEnum : IUnknown
{
    HRESULT SetEnumReadyCallback([in] PFDVENUMREADYBALLBACK pfn, [in] LPVOID pvData);
    HRESULT CreateEnumIDListFromContents([in] PCIDLIST_ABSOLUTE pidlFolder, [in] DWORD dwEnumFlags, [out] IEnumIDList **ppEnumIDList);
};

[
    helpstring("supports inserting an item into a folder"),
    uuid(D2B57227-3D23-4b95-93C0-492BD454C356),
    object,
    local
]
interface IInsertItem : IUnknown
{
    HRESULT InsertItem([in] PCUIDLIST_RELATIVE pidl);
}

///// IDeskBar
[
    uuid(EB0FE173-1A3A-11D0-89B3-00A0C90A90AC),
    object,
    pointer_default(unique),
    local
]
interface IDeskBar : IOleWindow
{
    HRESULT SetClient([in] IUnknown* punkClient);
    HRESULT GetClient([out] IUnknown** ppunkClient);
    HRESULT OnPosRectChangeDB([in] LPRECT prc);
};

//-------------------------------------------------------------------------
//
// IMenuBand interface
//
//   This interface provides methods the menuband (CLSID_MenuBand)
//  to receive pertinent messages.
//
// [Member functions]
//
// IMenuBand::IsMenuMessage(pmsg)
//   A message pump calls this function to see if any messages need
//   to be redirected to this object.  If this returns S_OK, the
//   message loop should not call TranslateMessage or DispatchMessage.
//   If this returns E_FAIL, the menu has exited menu mode and is ready
//   to be destroyed.
//
// IMenuBand::TranslateMenuMessage(pmsg, plRet)
//   Offers the object an opportunity to translate messages.  The
//   parent window proc must call this method for every message (not
//   the message pump).  The message, wParam, and lParam should be
//   delivered to this method in *pmsg.  This method may change the
//   values of pmsg->wParam or pmsg->lParam, in which case these changes
//   should be forwarded on.
//
//   This method is required because some modal message pumps (like the one
//   in TrackPopupMenu) do not give an opportunity to call a custom
//   TranslateAccelerator method like IInputObject::TranslateAcceleratorIO.
//
//   TranslateMenuMessage returns S_OK if the message was handled and
//   should be eaten.  *plRet is not touched if this returns S_FALSE.
//
//
//-------------------------------------------------------------------------

[
    uuid(568804CD-CBD7-11d0-9816-00C04FD91972),
    object,
    pointer_default(unique),
    local
]
interface IMenuBand : IUnknown
{
    // CmdIDs for the IOleCommandTarget Group: CGID_MenuBandHandler (defined in shguidp.h)
    enum tagMENUBANDHANDLERCID {
        MBHANDCID_PIDLSELECT    = 0,         // A PIDL from a menuband was selected
    };

    HRESULT IsMenuMessage([in] MSG * pmsg);
    HRESULT TranslateMenuMessage([in,out] MSG * pmsg, [out] LRESULT * plRet);
};

[
    object,
    uuid(47c01f95-e185-412c-b5c5-4f27df965aea),     // IID_IFolderBandPriv
    pointer_default(unique)
]
interface IFolderBandPriv : IUnknown
{
    HRESULT SetCascade([in] BOOL f);
    HRESULT SetAccelerators([in] BOOL f);
    HRESULT SetNoIcons([in] BOOL f);
    HRESULT SetNoText([in] BOOL f);
};

cpp_quote("#if _WIN32_IE >= 0x0400")

//-------------------------------------------------------------------------
//
// IBandSite interface
//
//   This interface provides methods to get or set bandsite information.
//
// [Member functions]
//
// IBandSite::AddBand(punk)
//   Add a band to the bandsite.  Returns the band ID in ShortFromResult(hres).
//
// IBandSite::EnumBands(uBand, *pdwBandID)
//   Enumerate the bands. If uBand is -1, pdwBandID is ignored and this
//   method returns the count of bands in the bandsite.  Call this method
//   with uBand starting at 0 to begin enumerating.  Returns S_OK and the
//   band ID in *pdwBandID of the next band.
//
// IBandSite::QueryBand(dwBandID, ppstb, pdwState, pszName, cchName)
//   Get info about a band.
//
// IBandSite::SetBandState(dwBandID, dwState)
//   Set the band's state.
//
// IBandSite::RemoveBand(dwBandID)
//   Remove the band.
//
// IBandSite::GetBandObject(dwBandID, riid, ppv)
//   Get an object that support riid for the band.
//
// IBandSite::GetBandSiteInfo(pbsinfo)
//   Get info about the bandsite.
//
// IBandSite::SetBandSiteInfo(pbsinfo)
//   Set info about the bandsite.
//
//-------------------------------------------------------------------------

cpp_quote("#include <pshpack8.h>")

typedef struct tagBANDSITEINFO
{
    DWORD       dwMask;         // BSIM_* flags
    DWORD       dwState;        // BSSF_* flags
    DWORD       dwStyle;        // BSIS_* flags
} BANDSITEINFO;

cpp_quote("#include <poppack.h>")   // Return to byte packing


enum tagBANDSITECID {
    BSID_BANDADDED,
    BSID_BANDREMOVED,
};

// Field mask
cpp_quote("#define BSIM_STATE          0x00000001")
cpp_quote("#define BSIM_STYLE          0x00000002")

// State flags
cpp_quote("#define BSSF_VISIBLE        0x00000001")
cpp_quote("#define BSSF_NOTITLE        0x00000002")
cpp_quote("#define BSSF_UNDELETEABLE   0x00001000")

// Style flags
cpp_quote("#define BSIS_AUTOGRIPPER               0x00000000")
cpp_quote("#define BSIS_NOGRIPPER                 0x00000001")
cpp_quote("#define BSIS_ALWAYSGRIPPER             0x00000002")
cpp_quote("#define BSIS_LEFTALIGN                 0x00000004")
cpp_quote("#define BSIS_SINGLECLICK               0x00000008")
cpp_quote("#define BSIS_NOCONTEXTMENU             0x00000010")
cpp_quote("#define BSIS_NODROPTARGET              0x00000020")
cpp_quote("#define BSIS_NOCAPTION                 0x00000040")
cpp_quote("#define BSIS_PREFERNOLINEBREAK         0x00000080")
cpp_quote("#define BSIS_LOCKED                    0x00000100")
cpp_quote("#define BSIS_MIL                       0x00000200")
cpp_quote("#define BSIS_PRESERVEORDERDURINGLAYOUT 0x00000400")

cpp_quote("#define SID_SBandSite IID_IBandSite")
cpp_quote("#define CGID_BandSite IID_IBandSite")

[
    object,
    uuid(4CF504B0-DE96-11D0-8B3F-00A0C911E8E5)
]
interface IBandSite : IUnknown
{
    HRESULT AddBand([in] IUnknown* punk);
    HRESULT EnumBands([in] UINT uBand, [out] DWORD* pdwBandID);
    HRESULT QueryBand([in] DWORD dwBandID, [out] IDeskBand** ppstb, [out] DWORD* pdwState, [out, size_is(cchName)] LPWSTR pszName, [in] int cchName);
    HRESULT SetBandState([in] DWORD dwBandID, [in] DWORD dwMask, [in] DWORD dwState);
    HRESULT RemoveBand([in] DWORD dwBandID);
    HRESULT GetBandObject([in] DWORD dwBandID, [in] REFIID riid, [out, iid_is(riid)] void **ppv);
    HRESULT SetBandSiteInfo([in] const BANDSITEINFO *pbsinfo);
    HRESULT GetBandSiteInfo([in, out] BANDSITEINFO *pbsinfo);
};

cpp_quote("#endif // _WIN32_IE >= 0x0400")

[
    uuid(A9521922-0812-4d44-9EC3-7FD38C726F3D),
    helpstring("callback objects for CRegTreeOptions items"),
    local
]
interface IRegTreeItem : IUnknown
{
    HRESULT GetCheckState([out] BOOL *pbCheck);
    HRESULT SetCheckState([in] BOOL bCheck);
};



//-------------------------------------------------------------------------
//
// IMenuPopup interface
//
//   This interface provides methods to navigate thru a menu.
//
// [Member functions]
//
// IMenuPopup::Popup(ppt, prcExclude, dwFlags)
//   Invoke the menu, located at the point *ppt (in screen coordinates).
//   The optional prcExclude points to the rectangle to exclude when
//   positioning the menu, otherwise it should be NULL.  dwFlags may be:
//
//      MDBPU_SETFOCUS: the menu can take the focus.
//
//   Returns S_OK if the object implements the popup menu as a modeless
//   menu.  Otherwise it returns S_FALSE, and the menu is finished.
//
// IMenuPopup::OnSelect(dwSelectType)
//   This method handles selection notifications.
//
// IMenuPopup::SetSubMenu(pmp, fSet)
//   Sets the given menu bar interface to be the submenu of this
//   object's interface.  Set fSet == FALSE to remove the submenu.
//
//-------------------------------------------------------------------------

// Type values for IMenuPopup::OnSelect
enum tagMENUPOPUPSELECT
{
    MPOS_EXECUTE = 0,           // Execute the selected menu item
    MPOS_FULLCANCEL,            // Cancel the entire menu
    MPOS_CANCELLEVEL,           // Cancel the current cascaded menu
    MPOS_SELECTLEFT,            // select one to the left of the cur selection
    MPOS_SELECTRIGHT,           // select one to the right of the cur selection
    MPOS_CHILDTRACKING          // the child got a tracking select (mouse moved over)
};

// Flags for IMenuPopup::Popup
enum tagMENUPOPUPPOPUPFLAGS
{
    MPPF_SETFOCUS        = 0x00000001,    // Menu can take the focus
    MPPF_INITIALSELECT   = 0x00000002,    // Select the first item
    MPPF_NOANIMATE       = 0x00000004,    // Do not animate this show
    MPPF_KEYBOARD        = 0x00000010,    // The menu is activated by keyboard
    MPPF_REPOSITION      = 0x00000020,    // Resposition the displayed bar.
    MPPF_FORCEZORDER     = 0x00000040,    // internal: Tells menubar to ignore Submenu positions
    MPPF_FINALSELECT     = 0x00000080,    // Select the last item
    MPPF_TOP             = 0x20000000,    // Popup menu up from point
    MPPF_LEFT            = 0x40000000,    // Popup menu left from point
    MPPF_RIGHT           = 0x60000000,    // Popup menu right from point
    MPPF_BOTTOM          = 0x80000000,    // Popup menu below point
    MPPF_POS_MASK        = 0xE0000000,    // Menu Position Mask
    MPPF_ALIGN_LEFT      = 0x02000000,    // Default alignment
    MPPF_ALIGN_RIGHT     = 0x04000000     // Popup menu aligned to right of exclude rect
};
typedef int MP_POPUPFLAGS;


[
    uuid(D1E7AFEB-6A2E-11d0-8C78-00C04FD918B4),
    object,
    pointer_default(unique),
    local
]
interface IMenuPopup : IDeskBar
{
    HRESULT Popup([in] POINTL *ppt, [in] RECTL *prcExclude, MP_POPUPFLAGS dwFlags);
    HRESULT OnSelect(DWORD dwSelectType);
    HRESULT SetSubMenu([in] IMenuPopup* pmp, BOOL fSet);
};

// image recompression object, given the cx, cy and a quality that we need go through the steps
// of creating a stream that we can give to somebody containing an image that size.  if the
// image is < that size then return S_FALSE.

[
    uuid(505f1513-6b3e-4892-a272-59f8889a4d3e),
    helpstring("Image Recompression Object"),
    pointer_default(unique),
    object
]
interface IImageRecompress : IUnknown
{
    HRESULT RecompressImage(IShellItem *psi, int cx, int cy, int iQuality, IStorage *pstg, IStream **ppstrmOut);
}


[
    uuid(9A93B3FB-4E75-4c74-871A-2CDA667F39A5),
    object,
    pointer_default(unique)
]
interface IDefViewSafety : IUnknown
{
    HRESULT IsSafePage();
};


[
    uuid(0811AEBE-0B87-4C54-9E72-548CF649016B),
    object,
    pointer_default(unique)
]
interface IContextMenuSite : IUnknown
{
    HRESULT DoContextMenuPopup([in] IUnknown* punkContextMenu, [in] UINT fFlags, [in] POINT pt);
};

//
// Selection state
//
typedef [v1_enum] enum tagKEYWORD_SELSTATE
{
    KEYWORD_SELSTATE_UNSELECTED    = 0x00000000,
    KEYWORD_SELSTATE_SELECTED      = 0x00000001,
    KEYWORD_SELSTATE_INDETERMINATE = 0x00000002
} KEYWORD_SELSTATE;

//
// Enumerator results
//
typedef struct tagKEYWORD
{
    BSTR             bstrKeyword;
    KEYWORD_SELSTATE nSelectionState;
} KEYWORD;

[
    helpstring("Keyword enumerator"),
    uuid(847B7DC1-E7EB-44d4-A830-30D933ED6312),
    object,
    pointer_default(unique)
]
interface IEnumKeywords : IUnknown
{
    HRESULT Next([in] ULONG celt, [out, size_is(celt)] KEYWORD *pKeywords, [out] ULONG *pcFetched);
    HRESULT Reset(void);
    HRESULT Skip ([in] ULONG celt);
    HRESULT Clone ([out, retval] IEnumKeywords **ppEnumKeywords);
};

// The main Keywords interface, which stores the Keywords,
// and knows how to parse them from strings, merge sets of Keywords
// from different sources, and create canonical Keyword strings.
// It can also return an enumerator and delimiter, so you can create
// the string yourself, or store them in a different way.
[
    uuid(2619DF03-B566-44b2-B005-72240980902B),
    object,
    pointer_default(unique)
]
interface IKeywordList : IUnknown
{
    // If bCanonical is true, returns the string that will separate Keywords
    // on output (e.g., comma+space).  If it is false, it returns the
    // characters that would be acceptable as delimiters for input strings
    // (e.g. comma, semicolon)
    HRESULT GetDelimiter([in] BOOL  bCanonical, [in,out] BSTR *pbstrDelimiter);

    // Prepend a Keyword onto the list of Keywords
    HRESULT Prepend([in] LPCWSTR pwszKeyword);

    // Append a Keyword onto the list of Keywords
    HRESULT Append([in] LPCWSTR pwszKeyword);

    // Remove the given Keyword from the list
    HRESULT Remove([in] LPCWSTR pwszKeyword);

    // Pass NULL for the keyword to set the selection state
    // for all keywords.
    HRESULT SetSelectionState([in] LPCWSTR pwszKeyword, [in] KEYWORD_SELSTATE nSelectionState);

    // Get the selection state for this keyword.  Returns E_FAIL
    // if the keyword isn't in this list
    HRESULT GetSelectionState([in] LPCWSTR pwszKeyword, [in,out] KEYWORD_SELSTATE *pnSelectionState);

    // Remove all Keywords from the list
    HRESULT RemoveAll();

    // Initialize the list of Keywords with the default set of Keywords
    // for the given media type.  Pass NULL for the default set.
    HRESULT InitFromDefaultKeywords([in] GUID *pKeywordSet);

    // Initialize the list of Keywords from the given string where the strings
    // are separated by the appropriate delimeter.
    HRESULT InitFromString([in] LPCWSTR pwszKeywords);

    // Merge this list of Keywords with another
    HRESULT Merge([in] IKeywordList *pKeywordList);

    // Apply the selection state of this list of keywords to the
    // supplied list of keywords.
    HRESULT Apply([in] IKeywordList *pKeywordList);

    // Convert the Keywords to a string
    HRESULT ToString([in,out] BSTR *pbstrKeywords);

    HRESULT EnumerateKeywords([in,out] IEnumKeywords **ppEnumKeywords);
};

[
    helpstring("A modal keyword dialog would be created using this interface"),
    uuid(8B670AD2-7C3C-4FE8-A0BC-6B2985191C98),
    object,
    pointer_default(unique)
]
interface IModalKeywordEditor : IModalWindow
{
    // Set the initial list of Keywords
    HRESULT Initialize([in] IKeywordList *pKeywordList);

    // Get the list of Keywords
    HRESULT GetKeywords([in,out] IKeywordList **ppKeywordList);
};

/////////////////////////////////////////
// Side bar native data sources interfaces
//-----------------------------------------
//-----------------------------------------
// Data Consumer Notify interface
//-----------------------------------------
[
    local,
    uuid(98206e73-f2e6-455a-9332-17b41988a355),
    pointer_default(unique)
]
interface IDataConsumerNotify : IUnknown
{
    HRESULT UpdateViewStrings([in] DWORD dwFlags, [in, size_is(cBSTR)] BSTR* rgBSTR, [in] DWORD cBSTR);
    HRESULT UpdateViewByteArrays([in] DWORD dwFlags, [in] BYTE** rgpData, [in] DWORD *rgcbLen, [in] DWORD dwCount);
    HRESULT UpdateViewVariants([in] DWORD dwFlags, [in, size_is(dwCount)] VARIANT *pvData, [in] DWORD dwCount);
}

//-----------------------------------------
//  Data Source Manager, module scheduling interface
//-----------------------------------------
[
    local,
    uuid(2B9ED45E-6D3F-475b-B18E-CD32D5D8BEEF),
    pointer_default(unique)
]
interface IDataSourceScheduler : IUnknown
{
    HRESULT SetTimer([in] DWORD dwDataTimeoutSecs);
    HRESULT KillTimer();
    HRESULT AddEventHandle([in] HANDLE hEvent);
    HRESULT RemoveEventHandle([in] HANDLE hEvent);
    HRESULT CreateMessageWindow([in] LPCWSTR pstrWindowClass, [out] HWND *phwnd);
    HRESULT RemoveMessageWindow([in] HWND hwnd);
}

//-----------------------------------------
// Module Data Source object
//-----------------------------------------
typedef [
helpstring("Constants that define the type of event received by an IModuleDataSource's OnEvent")
] enum tagModuleDataSourceEventType
{
    MDS_TIMER_TICK,
    MDS_HANDLE_SIGNALED,
    MDS_MESSAGE,
    MDS_STATE_CHANGE
} ModuleDataSourceEventType;

[
    uuid(898046a4-ce79-4c73-a650-ac266fe55ac4),
    pointer_default(unique)
]
interface IModuleDataSource : IUnknown
{
    HRESULT Initialize([in, unique] LPCWSTR strInitString);
    HRESULT Shutdown();
    HRESULT GetFlags([out] DWORD *pdwFlags);
    HRESULT OnEvent([in] ModuleDataSourceEventType evt, [in] UINT uMsg, [in] WPARAM wParam, [in] LPARAM lParam);
    HRESULT NotifyFromModuleView([in, size_is(dwCount)] LPCWSTR* rgStrings, [in] DWORD dwCount, [out] DWORD *pdwStatus);
};
// End Start Bar interfaces
/////////////////////////////////////////

typedef
[
    helpstring("Constants for the type of usage of an open file")
]
enum tagFILE_USAGE_TYPE
{
    FUT_PLAYING,
    FUT_EDITING,
    FUT_GENERIC
} FILE_USAGE_TYPE;

cpp_quote("#define OF_CAP_CANSWITCHTO     0x0001")
cpp_quote("#define OF_CAP_CANCLOSE        0x0002")

[
    uuid(64a1cbf0-3a1a-4461-9158-376969693950),
    pointer_default(unique)
]
interface IOpenFile : IUnknown
{
    HRESULT GetAppName([out, string] LPWSTR *ppszName);
    HRESULT GetUsage([out] FILE_USAGE_TYPE *pfut);
    HRESULT GetCapabilities([out] DWORD *pdwCapFlags);
    HRESULT GetSwitchToHWND([out] HWND *phwnd);
    HRESULT CloseFile();
};

interface IFileDialog;

//
// Implemented by a client of the common file dialog browser,
//  for notification of events within the dialog.
//
[
    uuid(721ed8c3-8c44-42a5-ba6b-c111351a9d06),
    object,
    pointer_default(unique)
]
interface IFileDialogEvents : IUnknown
{
    HRESULT OnFileOk([in] IFileDialog *pfd);
    HRESULT OnFolderChange([in] IFileDialog *pfd);
    HRESULT OnHelp([in] IFileDialog *pfd);
    HRESULT OnSelectionChange([in] IFileDialog *pfd);
    HRESULT OnShareViolation([in] IFileDialog *pfd);
    HRESULT OnTypeChange([in] IFileDialog *pfd);
}

//
// Implemented by the common file dialog browser, used by clients to
//  initialize, show, and get results from the dialog.
//
[
    uuid(61483B79-DE34-48b3-85C2-554DEC52290A),
    object,
    pointer_default(unique)
]
interface IFileDialog : IModalWindow
{
    enum tagFILEOPENDIALOGOPTIONS
    {
        FOS_OVERWRITEPROMPT          = 0x00000002,
        FOS_NOCHANGEDIR              = 0x00000008,
        FOS_SHOWHELP                 = 0x00000010,
        FOS_FORCEFILESYSTEM          = 0x00000040,
        FOS_NOVALIDATE               = 0x00000100,
        FOS_ALLOWMULTISELECT         = 0x00000200,
        FOS_PATHMUSTEXIST            = 0x00000800,
        FOS_FILEMUSTEXIST            = 0x00001000,
        FOS_CREATEPROMPT             = 0x00002000,
        FOS_SHAREAWARE               = 0x00004000,
        FOS_NOREADONLYRETURN         = 0x00008000,
        FOS_NOTESTFILECREATE         = 0x00010000,
        FOS_HIDEMRUPLACES            = 0x00020000,
        FOS_HIDEPINNEDPLACES         = 0x00040000,
        FOS_NODEREFERENCELINKS       = 0x00100000,
        FOS_DONTADDTORECENT          = 0x02000000,
        FOS_FORCESHOWHIDDEN          = 0x10000000
    };

    HRESULT SetFileTypes([in] UINT cFileTypes, [in, size_is(cFileTypes)] const COMDLG_FILTERSPEC *rgFilterSpec);
    HRESULT SetFileTypeIndex([in] UINT iFileType);
    HRESULT GetFileTypeIndex([out] UINT *piFileType);
    HRESULT Advise([in] IFileDialogEvents *pfde, [out] DWORD *pdwCookie);
    HRESULT Unadvise([in] DWORD dwCookie);
    HRESULT SetOptions([in] DWORD fos);
    HRESULT GetOptions([out] DWORD *pfos);
    HRESULT SetDefaultFolder([in] IShellItem *psi);
    HRESULT SetFolder([in] IShellItem *psi);
    HRESULT GetFolder([out] IShellItem **ppsi);
    HRESULT GetCurrentSelection([out] IShellItem **ppsi);
    HRESULT GetFileName([out, string] WCHAR **pszName);
    HRESULT SetTitle([in, string] LPCWSTR pszTitle);
    HRESULT SetOkButtonLabel([in, string] LPCWSTR pszText);
    HRESULT SetFileNameLabel([in, string] LPCWSTR pszLabel);
    HRESULT GetResult([out] IShellItem **ppsi);
    HRESULT AddPlace([in] IShellItem *psi); // May become AddPlaces(IShellItemArray)
    HRESULT SetDefaultExtension([in] LPCWSTR pszDefaultExtension);
}

//
// Additional methods specific to the file save dialog
//
[
    uuid(B7E4FD53-13C3-4015-923F-2EE66752E918),
    object,
    pointer_default(unique)
]
interface IFileSaveDialog : IFileDialog
{
    HRESULT SetSaveName([in, string] LPCWSTR pszName);
    HRESULT SetSaveAsItem([in] IShellItem *psi);
}

//
// Additional methods specific to the file open dialog
// (adding multiselect capability)
//
[
    uuid(BA68A421-6683-4e35-B343-2994FECB5634),
    object,
    pointer_default(unique)
]
interface IFileOpenDialog : IFileDialog
{
    HRESULT GetResults([out] IShellItemArray **ppenum);
    HRESULT GetSelectedItems([out] IShellItemArray **ppsai);
}

// Describes the inking mode for the file dialog
typedef [v1_enum] enum tagFILESAVEDIALOGINKMODE
{
    FSDIM_DISABLED      = 0,        // No Ink filename controls
    FSDIM_ENABLED          = 1,        // Ink filename controls on Tablets
    FSDIM_FORCE_VISIBLE    = 2         // Ink filename controls on all platforms
} FILESAVEDIALOGINKMODE;

//
// Additional method for the inking area of the file dialog
//
[
    uuid(ca70d954-900f-49d0-ba31-6215f7686596),
    object,
    pointer_default(unique)
]
interface IFileDialogInk : IUnknown
{
    HRESULT SetInkFilenameMode([in] FILESAVEDIALOGINKMODE dwMode);
}

typedef [v1_enum] enum tagCDCONTROLSTATE
{
    CDCS_ENABLED        = 0x00000001,
    CDCS_VISIBLE        = 0x00000002,
} CDCONTROLSTATE;
typedef DWORD CDCONTROLSTATEF;

// Used to specify whether a control is placed
// above or below the set of standard controls
typedef [v1_enum] enum tagCDCONTROLLAYOUT
{
    CDCL_ABOVE        = 0x00000000,
    CDCL_BELOW        = 0x00000001,
} CDCONTROLLAYOUT;

// Some facts:
// - Controls are added before the dialog is shown.  Their relative layout is implied by the order in which
//    they are added. Controls may be added below or above the standard set of controls.
//    Controls can not be removed or added afterwards, but they may be hidden or disabled at any time.
//    Their labels may be changed at any time.
// - Some controls are container controls: combobox, toolsmenu, opendropdown, radiogroup.  These may have
//   items added to them.
// - Items with a container control are "immutable", except for their enabled/visible state.  They can be
//    added and removed at will.  There is no ability to position items within a container - they appear in the
//    order they were added.  IDs for items are scoped to their parent control.
// - Container controls have the notion of a "selected item", with the exception of the toolsmenu.
// - radiobuttongroups behave exactly like comboboxes.  The radio buttons within the group are treated exactly
//    like items in a combobox, one of which can be the "selected item".
[
    uuid(6857070D-3A83-435f-8767-83182569C051),
    object,
    pointer_default(unique)
]
interface IFileDialogCustomize : IUnknown
{
    // Methods for adding or enabling controls. All of these can have their
    // enabled/visible state set, however the default is for them to be enabled and visible,
    // so this parameter has been left off these methods.
    HRESULT EnableToolbarMenu([in] DWORD dwIDCtl, [in, string] LPCWSTR pszLabel);
    HRESULT EnableOpenDropDown([in] DWORD dwIDCtl);
    HRESULT AddPushButton([in] DWORD dwIDCtl, [in, string] LPCWSTR pszLabel, [in] CDCONTROLLAYOUT dwLayout);
    HRESULT AddComboBox([in] DWORD dwIDCtl, [in, string] LPCWSTR pszLabel, [in] CDCONTROLLAYOUT dwLayout);
    HRESULT AddRadioButtonGroup([in] DWORD dwIDCtl, [in, string] LPCWSTR pszLabel, [in] CDCONTROLLAYOUT dwLayout);
    HRESULT AddCheckButton([in] DWORD dwIDCtl, [in, string] LPCWSTR pszLabel, [in] CDCONTROLLAYOUT dwLayout, [in] BOOL bChecked);
    HRESULT AddEditBox([in] DWORD dwIDCtl, [in, string] LPCWSTR pszLabel, [in] CDCONTROLLAYOUT dwLayout, [in, string] LPCWSTR pszText);

    // Getting/setting attributes on controls on the fly
    HRESULT SetControlLabel([in] DWORD dwIDCtl, [in, string] LPCWSTR pszLabel);
    HRESULT GetControlState([in] DWORD dwIDCtl, [out] CDCONTROLSTATEF *pdwState);
    HRESULT SetControlState([in] DWORD dwIDCtl, [in] CDCONTROLSTATEF dwState);
    HRESULT GetEditBoxText([in] DWORD dwIDCtl, [out, string] WCHAR **ppszText);
    HRESULT SetEditBoxText([in] DWORD dwIDCtl, [in, string] LPCWSTR pszText);
    HRESULT GetCheckButtonState([in] DWORD dwIDCtl, [out] BOOL *pbChecked);
    HRESULT SetCheckButtonState([in] DWORD dwIDCtl, [in] BOOL bChecked);

    // Method for adding items to "container controls" (radiogroup, combobox, opendropdown, toolsmenu)
    HRESULT AddControlItem([in] DWORD dwIDCtl, [in] DWORD dwIDItem, [in] LPCWSTR pszLabel);

    // Methods for removing items in the "container controls"
    HRESULT RemoveControlItem([in] DWORD dwIDCtl, [in] DWORD dwIDItem);
    HRESULT RemoveAllControlItems([in] DWORD dwIDCtl);

    // Getting/setting attributes on control items on the fly
    // Items are considered immutable once created, except for their state:
    HRESULT GetControlItemState([in] DWORD dwIDCtl, [in] DWORD dwIDItem, [out] CDCONTROLSTATEF *pdwState);
    HRESULT SetControlItemState([in] DWORD dwIDCtl, [in] DWORD dwIDItem, [in] CDCONTROLSTATEF dwState);

    // Methods for some "container controls": OpenDropDown, combobox, radiobuttongroup.
    // These methods don't apply to the tools menu.
    // These methods can be called after the dialog has closed, to determine the users final choice.
    // For comboboxes and radiobuttongroups, these methods may also be called while the
    // dialog is showing (which makes no sense for the OpenDropDown).
    HRESULT GetSelectedControlItem([in] DWORD dwIDCtl, [out] DWORD *pdwIDItem);
    HRESULT SetSelectedControlItem([in] DWORD dwIDCtl, [in] DWORD dwIDItem); // Not valid for OpenDropDown
}


// Event notifications from the controls, handled by an interface
// optionally implemented by the same IFileDialogEvents object supplied by the app.
[
    uuid(36116642-D713-4b97-9B83-7484A9D00433),
    object,
    pointer_default(unique)
]
interface IFileDialogControlEvents : IUnknown
{
    // An item in a combobox, toolsmenu, or radiobutton group was selected.
    // (this notification is *not* sent when an item is chosen from the open dropdown,
    //  as the action here is always the same: close the dialog as if the user clicked open.
    //  At that point, the app will then be able to call GetSelectedItem() for the open dropdown, to
    //  obtain the item that was chosen).
    HRESULT OnItemSelected([in] IFileDialogCustomize *pfdc, [in] DWORD dwIDCtl, [in] DWORD dwIDItem);

    // A pushbutton was clicked.
    HRESULT OnButtonClicked([in] IFileDialogCustomize *pfdc, [in] DWORD dwIDCtl);

    // A checkbutton was toggled.
    HRESULT OnCheckButtonToggled([in] IFileDialogCustomize *pfdc, [in] DWORD dwIDCtl, [in] BOOL bChecked);

    // A combobox, toolsmenu or open dropdown is about to be "dropped down".  At this point,
    // the application may want to update the contents based on the current state of the dialog.
    HRESULT OnControlActivating([in] IFileDialogCustomize *pfdc, [in] DWORD dwIDCtl);
}



//
// Delegate Item IDs are in a partially known format so the delegate (inner) and
// delgating (outer) folders share the pidl contents. the inner folder allocates
// its pidls using the IMalloc provided by the outer folder via SetItemAlloc()
// that pidl must conform to the delegate item format.
//
cpp_quote("#include <pshpack1.h>")

typedef struct tagDELEGATEITEMID
{
    WORD cbSize;                // size of entire item ID (points to the NULL or next item)
    WORD wOuter;                // Private data owned by the outer folder
    WORD cbInner;               // Size of delegate's data
    BYTE rgb[1];                // Inner folder's data (opaque to outer folder)
                                //   followed by outer folder's data.
} DELEGATEITEMID;

cpp_quote("#include <poppack.h>")

cpp_quote("typedef const UNALIGNED DELEGATEITEMID *PCDELEGATEITEMID;")
cpp_quote("typedef UNALIGNED DELEGATEITEMID *PDELEGATEITEMID;")

[
    helpstring("shell name space delegate folder interface"),
    uuid(ADD8BA80-002B-11D0-8F0F-00C04FD7D062),
    object,
    pointer_default(unique)
]
interface IDelegateFolder : IUnknown
{
    // use to give the delegate folder the IMalloc interface that it
    // needs to use to alloc and free item IDs.
    // These IDs are in the form of DELEGATEITEMIDs
    // and it is the delegates job to pack its data into the pidl
    // in the delegate format
    HRESULT SetItemAlloc([in] IMalloc *pmalloc);
};

cpp_quote("// INTERFACE: IBrowserFrameOptions")
cpp_quote("//")
cpp_quote("// This interface was implemented so a browser or host can ask a ShellView/ShelNameSpace what")
cpp_quote("// kind of 'Behavior' is appropriate for that view.")
cpp_quote("//")
cpp_quote("//    IBrowserFrameOptions::GetBrowserOptions()")
cpp_quote("//       dwMask is the logical OR of bits to look for.  pdwOptions is not optional and")
cpp_quote("//       it's return value will always equal or will be a subset of dwMask.")
cpp_quote("//       If the function succeeds, the return value must be S_OK and pdwOptions needs to be filled in.")
cpp_quote("//       If the function fails, pdwOptions needs to be filled in with BFO_NONE.")
cpp_quote("//")


[
    uuid(10DF43C8-1DBE-11d3-8B34-006097DF5BD4),
    object,
    local
]
interface IBrowserFrameOptions : IUnknown
{
    typedef [unique] IBrowserFrameOptions * LPBROWSERFRAMEOPTIONS;

    enum tagBROWSERFRAMEOPTIONS
    {
        BFO_NONE                            = 0x00000000,      // Do nothing.
        BFO_BROWSER_PERSIST_SETTINGS        = 0x00000001,      // Does this item want the browser stream? (Same window position as IE browser windows?)
        BFO_RENAME_FOLDER_OPTIONS_TOINTERNET = 0x00000002,     // Rename "Folder Options" to "Internet Options" in the Tools or View menu?
        BFO_BOTH_OPTIONS                    = 0x00000004,      // Keep both "Folder Options" and "Internet Options" in the Tools or View menu?
        BIF_PREFER_INTERNET_SHORTCUT        = 0x00000008,      // NSE would prefer a .url shortcut over a .lnk shortcut
        BFO_BROWSE_NO_IN_NEW_PROCESS        = 0x00000010,      // Specify this flag if you don't want the "Browse in New Process" via invoking a shortcut.
        BFO_ENABLE_HYPERLINK_TRACKING       = 0x00000020,      // Does this NSE want it's display name tracked to determine when hyperlinks should be tagged as previously used?
        BFO_USE_IE_OFFLINE_SUPPORT          = 0x00000040,      // Use "Internet Explorer"'s offline support?
        BFO_SUBSTITUE_INTERNET_START_PAGE   = 0x00000080,      // Does this NSE want to use the Start Page support?
        BFO_USE_IE_LOGOBANDING              = 0x00000100,      // Use the Brand block in the Toolbar.  (Spinning globe or whatever it is this year)
        BFO_ADD_IE_TOCAPTIONBAR             = 0x00000200,      // Should " - Internet Explorer" be appended to display name in the Captionbar
        BFO_USE_DIALUP_REF                  = 0x00000400,      // Should the DialUp ref count get a ref while the browse is navigated to this location?  This will also enable the ICW and Software update.
        BFO_USE_IE_TOOLBAR                  = 0x00000800,      // Should the IE toolbar be used?
        BFO_NO_PARENT_FOLDER_SUPPORT        = 0x00001000,      // Can you NOT navigate to a parent folder?  Used for Backspace button to parent folder or the View.GoTo.ParentFolder feature.
        BFO_NO_REOPEN_NEXT_RESTART          = 0x00002000,      // Browser windows are NOT reopened the next time the shell boots if the windows were left open on the previous logoff.  Does this NSE want the same feature?
        BFO_GO_HOME_PAGE                    = 0x00004000,      // Add "Home Page" to menu (Go).
        BFO_PREFER_IEPROCESS                = 0x00008000,      // prefers to use IEXPLORE.EXE over EXPLORER.EXE
        BFO_SHOW_NAVIGATION_CANCELLED       = 0x00010000,      // If navigation is aborted, show the "Action Cancelled" HTML page.

        BFO_QUERY_ALL                       = 0xFFFFFFFF,      // Return all values set.
    };
    typedef DWORD BROWSERFRAMEOPTIONS;

    HRESULT GetFrameOptions([in] BROWSERFRAMEOPTIONS dwMask, [out] BROWSERFRAMEOPTIONS * pdwOptions);
}

cpp_quote("#include <pshpack8.h>")

typedef struct tagSMDATA
{
    DWORD   dwMask;             // SMDM_* values
    DWORD   dwFlags;            // Not used
    HMENU   hmenu;              // Static HMENU portion.
    HWND    hwnd;               // HWND owning the HMENU
    UINT    uId;                // Id of the item in the menu (-1 for menu itself)
    UINT    uIdParent;          // Id of the item spawning this menu
    UINT    uIdAncestor;        // Id of the very top item in the chain of ShellFolders
    IUnknown*    punk;          // IUnkown of the menuband
    PIDLIST_ABSOLUTE pidlFolder;// pidl of the ShellFolder portion
    PUITEMID_CHILD   pidlItem;  // pidl of the item in the ShellFolder portion
    IShellFolder*   psf;        // IShellFolder for the shell folder portion
    void*   pvUserData;         // User defined Data associated with a pane.
} SMDATA, *LPSMDATA;

cpp_quote("// Mask")
cpp_quote("#define SMDM_SHELLFOLDER               0x00000001  // This is for an item in the band")
cpp_quote("#define SMDM_HMENU                     0x00000002  // This is for the Band itself")
cpp_quote("#define SMDM_TOOLBAR                   0x00000004  // Plain toolbar, not associated with a shell folder or hmenu")

cpp_quote("// Flags (bitmask)")
typedef struct tagSMINFO
{
    DWORD   dwMask;     // SMIM_*
    DWORD   dwType;     // SMIT_*
    DWORD   dwFlags;    // SMIF_*
    int     iIcon;
} SMINFO, * PSMINFO;

typedef struct tagSHCSCHANGENOTIFYSTRUCT
{
    LONG            lEvent;     // Change notify Event
    PCIDLIST_ABSOLUTE   pidl1;  // Pidl 1 Passed in from the Change notify
    PCIDLIST_ABSOLUTE   pidl2;  // Pidl 2 Passed in from the Change notify
} SMCSHCHANGENOTIFYSTRUCT, *PSMCSHCHANGENOTIFYSTRUCT;

cpp_quote("#include <poppack.h>") /* Return to byte packing */

// Mask flags
enum tagSMINFOMASK
{
    SMIM_TYPE           = 0x00000001,
    SMIM_FLAGS          = 0x00000002,
    SMIM_ICON           = 0x00000004
};

// Types for mbiinfo.dwType
enum tagSMINFOTYPE
{
    SMIT_SEPARATOR      = 0x00000001,
    SMIT_STRING         = 0x00000002
};

// Flags for mbiinfo.dwFlags
enum tagSMINFOFLAGS
{
    SMIF_ICON           = 0x00000001,       // Show an icon
    SMIF_ACCELERATOR    = 0x00000002,       // Underline the character marked w/ '&'
    SMIF_DROPTARGET     = 0x00000004,       // Item is a drop target
    SMIF_SUBMENU        = 0x00000008,       // Item has a submenu
    SMIF_CHECKED        = 0x00000020,       // Item has a Checkmark
    SMIF_DROPCASCADE    = 0x00000040,       // Item can cascade out during drag/drop
    SMIF_HIDDEN         = 0x00000080,       // Don't display item
    SMIF_DISABLED       = 0x00000100,       // Should be unselectable. Gray.
    SMIF_TRACKPOPUP     = 0x00000200,       // Should be unselectable. Gray.
    SMIF_DEMOTED        = 0x00000400,       // Display item in "Demoted" state.
    SMIF_ALTSTATE       = 0x00000800,       // Displayed in "Altered State"
    SMIF_DRAGNDROP      = 0x00001000,       // If item that is being dragged hovers over an item for long enough then it SMC_EXECs that item
    SMIF_NEW            = 0x00002000,       // Item is newly-installed or otherwise attractive (XP)
};

cpp_quote("#define SMC_INITMENU            0x00000001  // The callback is called to init a menuband")
cpp_quote("#define SMC_CREATE              0x00000002")
cpp_quote("#define SMC_EXITMENU            0x00000003  // The callback is called when menu is collapsing")
cpp_quote("#define SMC_GETINFO             0x00000005  // The callback is called to return DWORD values")
cpp_quote("#define SMC_GETSFINFO           0x00000006  // The callback is called to return DWORD values")
cpp_quote("#define SMC_GETOBJECT           0x00000007  // The callback is called to get some object")
cpp_quote("#define SMC_GETSFOBJECT         0x00000008  // The callback is called to get some object")
cpp_quote("#define SMC_SFEXEC              0x00000009  // The callback is called to execute an shell folder item")
cpp_quote("#define SMC_SFSELECTITEM        0x0000000A  // The callback is called when an item is selected")
cpp_quote("#define SMC_REFRESH             0x00000010  // Menus have completely refreshed. Reset your state.")
cpp_quote("#define SMC_DEMOTE              0x00000011  // Demote an item")
cpp_quote("#define SMC_PROMOTE             0x00000012  // Promote an item, wParam = SMINV_* flag")
cpp_quote("#define SMC_DEFAULTICON         0x00000016  // Returns Default icon location in wParam, index in lParam")
cpp_quote("#define SMC_NEWITEM             0x00000017  // Notifies item is not in the order stream.")
cpp_quote("#define SMC_CHEVRONEXPAND       0x00000019  // Notifies of a expansion via the chevron")
cpp_quote("#define SMC_DISPLAYCHEVRONTIP   0x0000002A  // S_OK display, S_FALSE not.")
cpp_quote("#define SMC_SETSFOBJECT         0x0000002D  // Called to save the passed object")
cpp_quote("#define SMC_SHCHANGENOTIFY      0x0000002E  // Called when a Change notify is received. lParam points to SMCSHCHANGENOTIFYSTRUCT")
cpp_quote("#define SMC_CHEVRONGETTIP       0x0000002F  // Called to get the chevron tip text. wParam = Tip title, Lparam = TipText Both MAX_PATH")
cpp_quote("#define SMC_SFDDRESTRICTED      0x00000030  // Called requesting if it's ok to drop. wParam = IDropTarget.")
cpp_quote("#define SMC_GETAUTOEXPANDSTATE  0x00000041  // callback returns the default autoexpand state lParam = LPDWORD to recieve flags")
cpp_quote("#define SMC_AUTOEXPANDCHANGE    0x00000042  // Notify that the menu is expanding/contracting")
cpp_quote("#define SMC_GETCONTEXTMENUMODIFIER 0x00000043  // Used to add items to a context menu")
cpp_quote("                                            // wParam = state flags")

cpp_quote("// Flags for return value from SMC_GETAUTOEXPANDSTATE and SMC_AUTOEXPANDCHANGE:")
cpp_quote("#define SMAE_EXPANDED           0x00000001  // The menu is or should start expanded")
cpp_quote("#define SMAE_CONTRACTED         0x00000002  // The menu is or should start contracted")
cpp_quote("                                            // SMAE_EXPANDED and SMAE_CONTRACTED are mutually exclusive")
cpp_quote("#define SMAE_USER               0x00000004  // Indicates that the menu expansion/contraction is a reflection")
cpp_quote("                                            // of user choice")
cpp_quote("#define SMAE_VALID              0x00000007")

[
    uuid(4CA300A1-9B8D-11d1-8B22-00C04FD918D0),
    object,
    pointer_default(unique),
    local // cannot marshal because method has polymorphic parameters
]

interface IShellMenuCallback : IUnknown
{
    // psmd is [in,out] because SMC_MAPACCELERATOR returns a value in uId
    HRESULT CallbackSM([in,out] LPSMDATA psmd, UINT uMsg, WPARAM wParam, LPARAM lParam);
};

//-------------------------------------------------------------------------
//
// IShellMenu interface
//
//-------------------------------------------------------------------------

cpp_quote("#define SMINIT_DEFAULT              0x00000000  // No Options")
cpp_quote("#define SMINIT_RESTRICT_DRAGDROP    0x00000002  // Don't allow Drag and Drop")
cpp_quote("#define SMINIT_TOPLEVEL             0x00000004  // This is the top band.")
cpp_quote("#define SMINIT_CACHED               0x00000010")
cpp_quote("#define SMINIT_AUTOEXPAND           0x00000100  // automatically expand/contract menu band")

// These are mutually Exclusive
cpp_quote("#define SMINIT_VERTICAL             0x10000000  // This is a vertical menu")
cpp_quote("#define SMINIT_HORIZONTAL           0x20000000  // This is a horizontal menu    (does not inherit)")

cpp_quote("#define ANCESTORDEFAULT      (UINT)-1")

cpp_quote("#define SMSET_TOP                   0x10000000    // Bias this namespace to the top of the menu")
cpp_quote("#define SMSET_BOTTOM                0x20000000    // Bias this namespace to the bottom of the menu")
cpp_quote("#define SMSET_DONTOWN               0x00000001    // The Menuband doesn't own the non-ref counted object")
                                                  // and should not destroy it.

cpp_quote("#define SMINV_REFRESH        0x00000001")
cpp_quote("#define SMINV_ID             0x00000008")

[
    uuid(EE1F7637-E138-11d1-8379-00C04FD918D0),
    object,
    pointer_default(unique), /* some of our pointers can be NULL (as noted) */
    local
]
interface IShellMenu : IUnknown
{
    HRESULT Initialize([in] IShellMenuCallback* psmc, UINT uId, UINT uIdAncestor, DWORD dwFlags);
    HRESULT GetMenuInfo([out] IShellMenuCallback** ppsmc, [out] UINT* puId, [out] UINT* puIdAncestor, [out] DWORD* pdwFlags);
    HRESULT SetShellFolder(IShellFolder* psf, [in] PCIDLIST_ABSOLUTE pidlFolder, HKEY hKey, DWORD dwFlags);
    HRESULT GetShellFolder([out] DWORD* pdwFlags, [out] PIDLIST_ABSOLUTE* ppidl, [in] REFIID riid, [out, iid_is(riid)] void** ppv);
    HRESULT SetMenu([in] HMENU hmenu, [in] HWND hwnd, DWORD dwFlags);
    HRESULT GetMenu([out /* can be null */] HMENU* phmenu, [out /* can be null */] HWND* phwnd, [out /* can be null */] DWORD* pdwFlags);
    HRESULT InvalidateItem([in /* can be null */] LPSMDATA psmd, DWORD dwFlags);
    HRESULT GetState([out] LPSMDATA psmd);
    HRESULT SetMenuToolbar([in] IUnknown* punk, DWORD dwFlags);
};


// ragged array of properties (indexed by fmtid and the the propid)

typedef struct tagSERIALIZEDPROPVALUE
{
    UINT cbNext;
    union
    {
        UINT pid;
        UINT cbName;       // if FMTID_UserDefinedProperties, this is the cb of the name, including the \0
    };
} SERIALIZEDPROPVALUE;
// Layout of a SERIALIZEDPROPVALUE (if fmtid != FMTID_UserDefinedProperties
//    ---cbNext
//    |  pid
//    |  <serialized PROPVARIANT>
//    |->cbNext (next property)
//       ...

// Layout of a SERIALIZEDPROPVALUE (if fmtid == FMTID_UserDefinedProperties)
//    ---cbNext
//    |  cbName
//    |  wszName[cbName / sizeof (WCHAR)]
//    |  <serialized PROPVARIANT>
//    |->cbNext (next property)
//       ...

typedef struct tagSERIALIZEDPROPSTORAGE
{
    UINT cbNext;
    GUID fmtid;
} SERIALIZEDPROPSTORAGE;

typedef SERIALIZEDPROPVALUE __unaligned *PUSERIALIZEDPROPVALUE;
typedef const SERIALIZEDPROPVALUE __unaligned *PCUSERIALIZEDPROPVALUE;

typedef SERIALIZEDPROPSTORAGE __unaligned *PUSERIALIZEDPROPSTORAGE;
typedef const SERIALIZEDPROPSTORAGE __unaligned *PCUSERIALIZEDPROPSTORAGE;

[v1_enum] enum tagPERSIST_SPROPSTORE_FLAGS
{
    FPSPS_READONLY  = 0x00000001,
};
typedef DWORD PERSIST_SPROPSTORE_FLAGS;

[
    uuid(88c82d8f-5705-4db1-ab41-55cebe9ac320),
    helpstring("Initialization from SERIALIZEDPROPSTORAGE"),
    object,
    pointer_default(unique)
]
interface IPersistSerializedPropStorage : IUnknown
{
    HRESULT SetFlags([in] PERSIST_SPROPSTORE_FLAGS flags);
    HRESULT SetPropertyStorage([in] PCUSERIALIZEDPROPSTORAGE psps);
    HRESULT GetPropertyStorage([out] SERIALIZEDPROPSTORAGE **ppsps, [out] UINT *pcb);
}

[v1_enum] enum tagPLEINFOFLAGS
{
    PLEIF_SHOWPICKER = 0x00000001,
    PLEIF_CREATENEW  = 0x00000002,
};

typedef DWORD PLEINFOFLAGS;

[v1_enum] enum tagPLEINFOMODE
{
    PLEIM_PHOTO = 0,
    PLEIM_MUSIC = 1,
};

typedef DWORD PLEINFOMODE;

typedef struct tagPLEINFO
{
    PLEINFOFLAGS pleifFlags;
    PLEINFOMODE pleimMode;
    PIDLIST_ABSOLUTE pidlBrowser;
    PIDLIST_ABSOLUTE pidlPlaylist;
    IDataObject *pdo;
    LPWSTR pszTitle;
} PLEINFO;

[
    uuid(ACD6797F-40FD-4E6F-BEC0-04503C7D4F72),
    helpstring("for invoking playlist editor"),
    object,
    pointer_default(unique)
]
interface IPlaylistEditor : IModalWindow
{
    [helpstring("Initializes the editor.")]
    HRESULT Initialize([in] PLEINFO *pInfo);
    [helpstring("Returns the filename as typed by the user, may be empty.")]
    HRESULT GetTitle([in] int cchTitle, [out, size_is(cchTitle)] LPWSTR pszTitle);
}


[v1_enum] enum tagFOLDERINFO_FLAGS
{
    FINFO_DEFAULT        = 0x00000000,
    FINFO_MOVECONTENTS   = 0x00000001,    // Move the contents of the old folder to the location of the new folder
    FINFO_UNPIN          = 0x00000002,    // unpin the old folder
};
typedef DWORD FOLDERINFO_FLAGS;

[v1_enum] enum tagFOLDERPERMISSION_FLAGS
{
    FPERM_NONE           = 0x00000000,
    FPERM_SETPATH        = 0x00000001,    // User is permited to set the folder path
};
typedef DWORD FOLDERPERMISSION_FLAGS;

// the IFolderInformation interface will make it posible to get folder information
// from a local and an other computer on the network. You must have access to the
// computer you are getting the information from
[
    uuid(355f57b4-8946-4982-bda6-d1928a5b2043),
    helpstring("Remotable folder information"),
    object,
    version(1.0)
]
interface IFolderInformation : IUnknown
{
    // remotable
    HRESULT GetFolderPath([in] UINT csidl, [out, string] LPWSTR *ppszPath);
    HRESULT SetFolderPath([in] UINT csidl, [in] DWORD dwFlags, [in, string] LPCWSTR pszPath);
    HRESULT GetPermissions([in] UINT csidl, [out] DWORD *pdwFlags);
    HRESULT IsValidFolderPath([in] UINT csidl, [in, string] LPCWSTR pszPath);

    // local machine only
    [local] HRESULT UISetFolderPath([in] HWND hwnd, [in] UINT csidl, [in] DWORD dwFlags, [in, string] LPCWSTR pszPath);
}




// Share Manager stuff

// Forward Declarations
interface IShareProgress;
interface IShareManager;
interface IEnumShareInformation;


typedef enum _tagSHAREMANAGER_SHARE_ATTRIBUTES
{
    SM_SHARE_ATTRIBUTE_NORMAL           = 0x00000001,
    SM_SHARE_ATTRIBUTE_HIDDEN           = 0x00000002,
    SM_SHARE_ATTRIBUTE_DRIVE            = 0x00000004,
    SM_SHARE_ATTRIBUTE_ADMIN            = 0x00000008,
    SM_SHARE_ATTRIBUTE_READONLY         = 0x00000100,
    SM_SHARE_ATTRIBUTE_READWRITE        = 0x00000200,
}
SHAREMANAGER_SHARE_ATTRIBUTES;
typedef DWORD SM_SHARE_ATTRIBUTES;


cpp_quote("#ifdef MIDL_PASS")
typedef byte * PSECURITY_DESCRIPTOR;
typedef ULONG  ACCESS_MASK;
cpp_quote("#endif")

typedef enum _tagSHAREMANAGER_CONTROL_FLAGS
{
    SM_CONTROL_FLAG_CREATENEWSHAREIFONEEXISTS           = 0x00000001,
    SM_CONTROL_FLAG_UPDATEEXISTINGSHAREPERMS            = 0x00000002,
    SM_CONTROL_FLAG_UPDATEEXISTINGSHAREPERMSTODEFAULT   = 0x00000004,
    SM_CONTROL_FLAG_ENABLEFIREWALLSUBNET                = 0x00000100,
    SM_CONTROL_FLAG_ENABLEFIREWALLGLOBAL                = 0x00000200,
    SM_CONTROL_FLAG_DONTCHANGEFIREWALLPORTS             = 0x00000400,
    SM_CONTROL_FLAG_PROTECTEDSCOPE                      = 0x00001000,
    SM_CONTROL_FLAG_ABORTONFIRSTERROR                   = 0x01000000,
}
SHAREMANAGER_CONTROL_FLAGS;
typedef DWORD SM_CONTROL_FLAGS;
#define SM_CONTROL_FLAG_VALIDMASK     ( SM_CONTROL_FLAG_CREATENEWSHAREIFONEEXISTS           \
                                        | SM_CONTROL_FLAG_UPDATEEXISTINGSHAREPERMS          \
                                        | SM_CONTROL_FLAG_UPDATEEXISTINGSHAREPERMSTODEFAULT \
                                        | SM_CONTROL_FLAG_ENABLEFIREWALLSUBNET              \
                                        | SM_CONTROL_FLAG_ENABLEFIREWALLGLOBAL              \
                                        | SM_CONTROL_FLAG_DONTCHANGEFIREWALLPORTS           \
                                        | SM_CONTROL_FLAG_PROTECTEDSCOPE                    \
                                        | SM_CONTROL_FLAG_ABORTONFIRSTERROR )

typedef [v1_enum] enum _tagSHAREMANAGER_ENUMSHARES_FLAGS
{
    SM_ENUMSHARES_FLAG_INCLUDEALL          = 0x00000001,  // Enumerate all shares
    SM_ENUMSHARES_FLAG_INCLUDEADMIN        = 0x00000002,  // Include special-purpose admin shares (ADMIN$, IPC$)
    SM_ENUMSHARES_FLAG_INCLUDEDRIVES       = 0x00000004,  // Include drive shares (C$, D$, etc.)
    SM_ENUMSHARES_FLAG_INCLUDEOTHERHIDDEN  = 0x00000008,  // Ignore hidden shares (Other $ shares)
}
SHAREMANAGER_ENUMSHARES_FLAGS;
typedef DWORD SM_ENUMSHARES_FLAGS;

[
    object, helpstring("Share Manager"), uuid(a78b7a2b-f90d-4195-b269-2a7c7fbb4dd0), version(1.0)
]
interface IShareManager : IUnknown
{
    HRESULT GenerateUniqueShareName([in, string] LPCWSTR pszFolderPath, [out, string] LPWSTR * ppszShareName);
    HRESULT Share([in, string] LPCWSTR pszShareName, [in, pointer_default(unique)] IDataObject * pDataObject,
                [in] SM_CONTROL_FLAGS grfControlFlags, [in, string] LPCWSTR pszRemark,
                [in, pointer_default(unique)] IShareProgress * pShareProgress,
                [in, pointer_default(unique)] PSECURITY_DESCRIPTOR pSD);
    HRESULT Unshare([in, string] LPCWSTR pszShareName, [in, pointer_default(unique)] IDataObject * pDataObject,
                [in] SM_CONTROL_FLAGS grfControlFlags, [in] IShareProgress * pShareProgress);
    HRESULT GetAggregateSecurity([in, pointer_default(unique)] IDataObject * pDataObject, [out] LPDWORD pcbSDSize,
                [out, size_is(,*pcbSDSize)] PSECURITY_DESCRIPTOR * ppSD);
    HRESULT GetShareInfo([in, string] LPCWSTR pszShareName, [in, pointer_default(unique)] IDataObject * pDataObject,
                [out] IEnumShareInformation ** ppEnumShareInformation);
    HRESULT CanShare([in, pointer_default(unique)] IDataObject * pDataObject, [out] BOOL * pbCanShare);
    HRESULT EnumSharedItems([in, string] LPCWSTR pszSidSharedBy, [in, string] LPCWSTR pszSidSharedTo,
                [in, pointer_default(unique)] ACCESS_MASK * pAccessMask, [in] SM_ENUMSHARES_FLAGS grfFlags,
                [out] IShellItemArray ** ppShellItemArray);
    HRESULT GetScopingShare([in, string] LPCWSTR pszFolderPath, [in, string] LPCWSTR pszUserSid, [in] ACCESS_MASK * pAccessMask,
				[in] SM_ENUMSHARES_FLAGS grfFlags, [out, string] LPWSTR * ppszUNCSharePath);

};      // IShareManager

typedef struct SHAREINFORMATION
{
    LPWSTR                      pszUNCSharePath;    // (\\MACHINENAME\SHARENAME) for a UNC share
    LPWSTR						pszItemPath;
    LPWSTR                      pszRemark;
    SM_SHARE_ATTRIBUTES         spAttributes;
    DWORD                       cbSDSize;
    [size_is(cbSDSize)]BYTE     pSD[];
}
SHAREINFORMATION;


// Generic enumeration interface to enumerate through the shares on a machine.
//
// Semantics :
//
// It is not dynamic. The Enum doesnt reflect the "current" share state of the machine,
//      only a snapshot of the shares at a particular instant.
//

[
    object, helpstring("Folder Shares Enumerator"), uuid(edd27709-b533-4c9c-8c19-4bfcd62e4c49), pointer_default(unique)
]
interface IEnumShareInformation : IUnknown
{
    HRESULT Next([in] ULONG celt, [out, size_is(celt), length_is(*pceltFetched)] SHAREINFORMATION **rgelt, [out] ULONG *pceltFetched);
    HRESULT Skip([in] ULONG celt);
    HRESULT Reset();
    HRESULT Clone([out] IEnumShareInformation **ppEnumShareInformation);
};

typedef [v1_enum] enum _tagSHAREPROGRESS_OP
{
    SHAREPROGRESS_OP_CONTAINERSETACL = 1,
    SHAREPROGRESS_OP_OBJECTSETACL,
    SHAREPROGRESS_OP_SHARESETACL,
    SHAREPROGRESS_OP_SHAREDELETE,
}
SHAREPROGRESS_OP;

typedef [v1_enum] enum _tagSHAREPROGRESS_FLAG
{
    SHAREPROGRESS_FLAG_CONTINUE                     = 1,    // Continue processing as usual and invoke callback
    SHAREPROGRESS_FLAG_CALLBACKONERROR,                     // Continue and invoke callback only on error
    SHAREPROGRESS_FLAG_NOCALLBACK,                          // Continue and dont invoke callback
    SHAREPROGRESS_FLAG_CANCEL                               // Cancel processing
}
SHAREPROGRESS_FLAG;

[
    object, helpstring("Progress Indicator for Sharing"), uuid(b36a41a2-6e5c-47e4-813d-0bfce8bad090), pointer_default(unique)
]
interface IShareProgress : IUnknown
{
    HRESULT PreOp([in, string] LPCWSTR pszObjectName, [in] SHAREPROGRESS_OP shareProgressOp, [in] DWORD dwStatus, [out] SHAREPROGRESS_FLAG * pProgressFlag);
    HRESULT PostOp([in, string] LPCWSTR pszObjectName, [in] SHAREPROGRESS_OP shareProgressOp, [in] DWORD dwStatus, [out] SHAREPROGRESS_FLAG * pProgressFlag);
}



//
//
// IPreviousVersionsInfo
//
// private interface used by the Timewarp client UI
//
[
    object,
    uuid(76e54780-ad74-48e3-a695-3ba9a0aff10d),
    pointer_default(unique),
    local
]
interface IPreviousVersionsInfo : IUnknown
{
    HRESULT AreSnapshotsAvailable(
        [in, string] LPCWSTR pszPath,
        [in] BOOL fOkToBeSlow,
        [out, retval] BOOL *pfAvailable);
};


cpp_quote("")
cpp_quote("//===================================================================")
cpp_quote("//DESCRIPTION: IComposeWindow")
cpp_quote("//")
cpp_quote("//   This interface is implemented by clients that have compose windows")
cpp_quote("//(E-mail applications, Newsgroup clients, Fax software, Calendar Invites, etc.).")
cpp_quote("//This interface will allow an application to launch a compose window and have")
cpp_quote("//the compose window appear partially or fully filled out.")
cpp_quote("//")
cpp_quote("// Callers wanting to launch the compose window can create CLSID_LaunchComposeWindow")
cpp_quote("// in order to create this interface.  Callers should create this object with CLSCTX_ANY.")
cpp_quote("//")
cpp_quote("// The registry entry HKLM, \\Software\\Clients\\ contains the list of client applications.")
cpp_quote("// Examples of Client values: Mail, Calendar, Contacts, IM, News, etc.")
cpp_quote("//")
cpp_quote("// For E-mail, the API MAPISendMail() will launch a compose window and fill out a few fields.  ")
cpp_quote("// The goal of the IComposeWindow API is to fill out much more of the compose window.  This is accomplished")
cpp_quote("// by the caller passing a stream containing rich data needed to fill out the compose window.")
cpp_quote("// The format of the stream that fills out the compose window will be documented here for each client type.")
cpp_quote("//")
cpp_quote("// Applications calling LaunchComposeWindow() should expect that the call may not return until")
cpp_quote("// the user closes the Compose Window.  Some implementations of LaunchComposeWindow will")
cpp_quote("// move the user interface to a different thread (recommended).  However, some legacy")
cpp_quote("// implementers of MAPISendMail() will not return until the UI is dismissed.")
cpp_quote("")
cpp_quote("// CLIENT: Mail")
cpp_quote("// The content type for a Mail compose window is message/rfc822. ")
cpp_quote("// The caller creates a MIME or RFC 822 compatible stream containing the message that they")
cpp_quote("// want to appear in the compose window.  This stream is then passed in the")
cpp_quote("// pStream parameter.  IMimeMessage can be used to create this stream from strings for the header")
cpp_quote("// values, text version of the body, and html version of the body.")
cpp_quote("")
cpp_quote("// The MIME or RFC 822 stream allows a wide range of attributes to be specified, from custom headers")
cpp_quote("// to digital signatures.  The email client is recommended to carry forward as many attributes")
cpp_quote("// as is possible and appropriate.  Digital Signatures and Encrypted email messages are examples of")
cpp_quote("// attributes that will not be respected.")
cpp_quote("")
cpp_quote("// WARNING: This method will always launch the compose window.  For security reasons, it will not")
cpp_quote("//          send the message without user interaction.")
cpp_quote("")
cpp_quote("// The Mail client supports a special flag SMEX_ALLOWFALLBACK.  If this value is specified and the")
cpp_quote("// current E-mail application does not support this interface, it will fallback to MAPISendMail().")
cpp_quote("// attributes that will not be respected.")
cpp_quote("")
cpp_quote("// Applications register their compose window under the following registry entry:")
cpp_quote("// HKLM/HKCU, Software\\Clients\\<ClientType>\\<ApplicationName>\\Compose,  CLSID [REG_SZ] == {<CLSID>}")
cpp_quote("")
cpp_quote("")
cpp_quote("// Flags for dwFlags")
cpp_quote("#define SMEX_DEFAULT              0x00000000      // Normal behavior")
cpp_quote("#define SMEX_ALLOWFALLBACK        0x00000001      // If the current email application doesn't support this API, then fallback to MAPISendMail().")
cpp_quote("                                                  // This will result in the Email message not containing an HTML body or othe extended properties.")
cpp_quote("//")
cpp_quote("// PARAMETERS:")
cpp_quote("//   pszClientType:      The client to launch. Examples: Mail, Calendar, News, etc.")
cpp_quote("//   hwndParent:         The HWND to the general location to Compose window should appear.  OPTIONAL")
cpp_quote("//   pStream:            The stream of the content for the compose window.")
cpp_quote("//   dwFlags:            Same as flFlags for MAPISendMail().  MAPI_DIALOG is required to be set.")
cpp_quote("//   return values:")
cpp_quote("//                       S_OK: The compose window was successfully launched.")
cpp_quote("//                       E_NOTIMPL: If the currently selected application for this client type doesn't implement")
cpp_quote("//                           IComposeWindow, this error value will be returned.")
cpp_quote("//                       HRESULT_FROM_WIN32(ERROR_SERVICE_DOES_NOT_EXIST): This will be returned if the current application doesn't")
cpp_quote("//                           implement this client type.")
cpp_quote("//                       HRESULT_FROM_WIN32(ERROR_SERVICE_NOT_IN_EXE): This will be returned if the currently selected Mail program doesn't")
cpp_quote("//                           implement IComposeWindow or the fallback function MAPISendMail().")
cpp_quote("//                       HRESULT_FROM_WIN32(ERROR_NO_MATCH): This will be returned if the current application for")
cpp_quote("//                           this client type supports IComposeWindow, but does not support this ContentType.")
cpp_quote("//===================================================================")
[
    object,
    uuid(11E5990F-752A-4876-A422-19B477CF7052),  // IID_IComposeWindow
    pointer_default(unique),
]
interface IComposeWindow : IUnknown
{
    HRESULT LaunchComposeWindow([in] LPCWSTR pszClientType, [in] HWND hwndParent, [in] IStream * pStream, [in] DWORD dwFlags);
};



[v1_enum] enum tagBASKETCONTROLFLAGS
{
    BCF_HIDENAVIGATION      = 0x00000001, // hide navigation commands, even if folder supports hierarchy
    BCF_HIDEORDER           = 0x00000002, // hide ordering commands, even if folder supports ordering
    BCF_WIDELAYOUT          = 0x00000008, // use a wide layout, with room for additional controls in toolbar and on status bar
    BCF_WATERMARKTEXT       = 0x00000020, // szWatermark is valid
    BCF_STATUS_NOTVIEWBASED = 0x00000040, // don't restart status computation when view changes.
    BCF_NOHEADER            = 0x00000100, // do not create the nav bar
};

typedef struct tagBASKETCONTROLINFO
{
    DWORD cbSize;           // size, used for versioning
    DWORD bcf;              // flags, combination of BCF_*
    PCIDLIST_ABSOLUTE pidl; // item path to work against. If NULL, the control creates a temporary file.
    UINT  cpkey;            // count of items in apk
    const PROPERTYKEY *apkey; // array of property keys to display in status bar
    WCHAR szWatermark[100]; // text to display when view is empty
} BASKETCONTROLINFO;

[
    uuid(7424EEBF-BC33-4601-B8DC-3C7620C4C1E6),
    helpstring("SimpleBrowser UI with header, toolbar, and status bar, designed to be hosted on static list folders."),
    object,
    pointer_default(unique)
]
interface IBasketControl : IUnknown
{
    [helpstring("Initialize the control.")]
    HRESULT Initialize([in] HWND hwndParent, [in] const BASKETCONTROLINFO *pbci);
    [helpstring("Destroys the view window and releases COM references to the site.")]
    HRESULT DestroyViewWindow();
    [helpstring("Returns the contained browser.")]
    HRESULT GetBrowser([in] REFIID riid, [out, iid_is(riid)] void **ppv);
    [helpstring("Sets the status bar text (replacing the property display) or reverts to the property display (if pszStatus is NULL).")]
    HRESULT SetStatusText([in] LPCWSTR pszStatus);
    [helpstring("Turns gauge functionality for the given property on (varMaximum must be same type as property passed in Initialize) or off (varMaximum is VT_EMPTY).")]
    HRESULT SetPropertyGauge([in] REFPROPERTYKEY key, [in] const PROPVARIANT varMaximum);
    [helpstring("Replaces the display string for a property in the status bar, where %1 is the formatted current value and %2 the formatted maximum value.")]
    HRESULT SetPropertyText([in] REFPROPERTYKEY key, [in] LPCWSTR pszFormat);
    [helpstring("Sets the current value of the given property.")]
    HRESULT UpdateStatusInfo([in] REFPROPERTYKEY key, [in] const PROPVARIANT varCurrent);
};

[
    uuid(E1874FD2-7A1D-476b-9CF9-83A7EB121D88),
    helpstring("Composite control with shell view and breadcrumb bar on one side and basket control on the other."),
    local,
    pointer_default(unique)
]
interface IListMakerControl : IUnknown
{
    [helpstring("Initialize the control's view window with the given parent window, browser folder, and basket settings.")]
    HRESULT Initialize([in] HWND hwndParent, [in] PCIDLIST_ABSOLUTE pidlBrowser, [in] const BASKETCONTROLINFO *pbci);
    [helpstring("Destroys the view window and releases COM references to the site.")]
    HRESULT DestroyViewWindow();
    [helpstring("Returns the requested interface from the contained Basket.")]
    HRESULT GetBasketInterface([in] REFIID riid, [out, iid_is(riid)] void **ppv);
    [helpstring("Returns the requested interface from the contained SimpleBrowser.")]
    HRESULT GetBrowserInterface([in] REFIID riid, [out, iid_is(riid)] void **ppv);
    [helpstring("Sets the width of the basket control, in pixels.")]
    HRESULT SetWidth([in] UINT cxBasket);
    [helpstring("Gets the width of the basket control, in pixels.")]
    HRESULT GetWidth([out] UINT *pcxBasket);
};

[
    uuid(C7F47D96-41AD-43EB-A3CB-FC6AB1C6E64E),
    helpstring("Optional callback interface for IListMakerControl hosts."),
    local,
    pointer_default(unique)
]
interface IListMakerControlSite : IUnknown
{
    [helpstring("Called when the view is enumerating objects. Return S_OK to include the object in the view, S_FALSE to hide it.")]
    HRESULT IncludeItem([in] IShellItem *psi);
};

cpp_quote("#define SID_SListMakerControlSite IID_IListMakerControlSite")

typedef [v1_enum] enum _tagSYNCENGACTION {
    SYNCENG_COPYATOB         =   0x1,
    SYNCENG_COPYBTOA         =   0x2,
    SYNCENG_DELETEA          =   0x3,
    SYNCENG_DELETEB          =   0x4,
    SYNCENG_MERGE            =   0x5,
    SYNCENG_SKIP             =   0x6,
} SYNCENGACTION;

[
    object,
    uuid(f7da33a5-fd27-4ff1-b8e9-05c7535be52b)  // IID_ISyncReconciliationAction
]
interface ISyncReconciliationAction : IUnknown
{
    HRESULT GetAction(
        [out] IShellItem** ppsiA,
        [out] IShellItem** ppsiB,
        [out] SYNCENGACTION* paction
        );
    HRESULT SetAction(
        [in] SYNCENGACTION action
        );
    HRESULT Execute([in, optional] IFileOperationProgressSink * pfnSyncCallback);
};

[
    object,
    uuid(b40a9a34-cdef-43a7-9eeb-9a0abad0c48d)  // IID_ISyncReconciliationList
]
interface ISyncReconciliationList : IUnknown
{
    HRESULT Next(
        [in] ULONG celt,
        [out, size_is(celt), length_is(*pceltFetched)] ISyncReconciliationAction** rgelt,
        [out] ULONG *pceltFetched);

    HRESULT Skip([in] ULONG celt);
    HRESULT Reset();
    HRESULT Clone([out] ISyncReconciliationList **ppenum);

    HRESULT ExecuteAll([in, optional] ITransferAdviseSink* pfnSyncCallback);
};


[
    object,
    uuid(650be65d-df09-4028-97a0-40b74c150a50)  // IID_ISyncRelationship
]
interface ISyncRelationship : IEnumShellItems
{
};

[
    object,
    uuid(a7254510-9427-4d22-9ebe-0e88c2cbc800)  // IID_IEnumSyncRelationship
]
interface IEnumSyncRelationship : IUnknown
{
    HRESULT Next(
        [in] ULONG celt,
        [out, size_is(celt), length_is(*pceltFetched)] ISyncRelationship ** rgelt,
        [out] ULONG *pceltFetched);

    HRESULT Skip([in] ULONG celt);
    HRESULT Reset();
    HRESULT Clone([out] IEnumSyncRelationship **ppenum);
};

[
    object,
    uuid(5ff4de38-0de2-45f5-b6ee-8223caf82347),
]
interface ISyncDatabaseGenerateActionsCB : IUnknown
{
    HRESULT Begin();
    HRESULT End();
    HRESULT FoundItem([in] IShellItem* psi);
};

typedef enum _tagSYNCENGFLAGS {
    SYNCENG_NORMAL           = 0x00000000,
    SYNCENG_ONEWAYSYNC       = 0x00000001,
    SYNCENG_ONECOPYPERVOLUME = 0x00000002,
    SYNCENG_OFFLINE          = 0x00000004,
    SYNCENG_ENABLE_REMAP     = 0x00000008,
} SYNCENGFLAGS;

typedef enum _tagSYNCENGADDRELATIONSHIPFLAGS {
    SYNCENG_ADDREL_NORMAL    = 0x00000000,
    SYNCENG_ADDREL_RECURSIVE = 0x00000001,
    SYNCENG_ADDREL_REMAPDEST = 0x00000002,
} SYNCENGADDRELATIONSHIPFLAGS;

[
    object,
    uuid(32a86a13-5a3d-49e6-8fac-46512adc339a)  // IID_ISyncDatabase
]
interface ISyncDatabase : IUnknown
{
    HRESULT Initialize([in] IShellItem* psiDB,
                       [in] DWORD dwFlags);

    HRESULT Commit();

    HRESULT AddRelationship(
        [in] IShellItem* psi1,
        [in] IShellItem* psi2,
        [in] DWORD dwFlags,
        [out, optional] ISyncRelationship** pprel
        );

    HRESULT DeleteRelationship(
        [in] ISyncRelationship* prel
        );

    HRESULT EnumRelationships(
        [out, retval] IEnumSyncRelationship** pprelEnum
        );

    HRESULT GenerateSyncActions(
        [in, optional] ISyncDatabaseGenerateActionsCB* pfnCallback,
        [out, retval] ISyncReconciliationList** ppreclist
        );
}



// Base interface from which to derive "related items"
// with specific relationships, and identical method signatures.
//
// Use with
// IShellItem::BindToHandler, BHID_SFObject
// IShellFolder::BindToObject
[
    uuid(a73ce67a-8ab1-44f1-8d43-d2fcbf6b1cd0), object, pointer_default(unique)
]
interface IRelatedItem : IUnknown
{
    HRESULT GetItemIDList(PIDLIST_ABSOLUTE *ppidl);
    HRESULT GetItem(IShellItem **ppsi);
}

// Used to obtain the true identity of the item, so it can be
// determined if two items actually represent the same item.
[
    uuid(7d903fca-d6f9-4810-8332-946c0177e247), object, pointer_default(unique)
]
interface IIdentityName : IRelatedItem
{
}

// If an item represents a snapshot of an item taken at a previous time,
// ICurrentItem will let you obtain the current version of the item.
[
    uuid(240a7174-d653-4a1d-a6d3-d4943cfbfe3d), object, pointer_default(unique)
]
interface ICurrentItem : IRelatedItem
{
}

// used to find the storage location of an item. that is the place where it really lives
// useful for displaying the "in folder" column or "open containing folder" feature
[
    uuid(e5e4077b-39cd-497a-b570-17464059f119), object, pointer_default(unique)
]
interface IStorageItem : IRelatedItem
{
}

// and many more to come "related items"...
//
//  "public partner" - like to SharedPics from MyPics
//  "private partner" - link to MyPics from SharedPics
//  "recyle bin root" - where (and if) recycle bin is supported
//  "machine root" - for "open containing machine"



[
    uuid(64aa0878-44d1-47f2-a460-f24d946f1d7e),
    object,
    pointer_default(unique)
]
interface IInitializeWithStream : IUnknown
{
    HRESULT Initialize([in] IStream *pstm, [in] DWORD grfMode);
}

[
    uuid(9A3028C8-B830-4f02-8C97-8390B134E1BD),
    object,
    pointer_default(unique)
]
interface ISafeCommit : IUnknown
{
    HRESULT GetStream([out] IStream **ppstm);
    HRESULT Commit([in, unique] LPCWSTR pszBackup);
}

[
    uuid(B9075C7C-D48E-403f-AB99-D6C77A1084AC),
    object,
    pointer_default(unique)
]
interface IBandHost: IUnknown
{
    HRESULT CreateBand([in] REFCLSID rclsidBand, [in] BOOL fAvailable, [in] BOOL fVisible, [in] REFIID riid, [out, iid_is(riid)]void **ppv);
    HRESULT SetBandAvailability([in] REFCLSID rclsidBand, [in] BOOL fAvailable);
    HRESULT DestroyBand([in] REFCLSID rclsidBand);
};

cpp_quote("#define SID_SBandHost IID_IBandHost")

// Popup manager interface for WebOC hosts and Trident.
[
    uuid(CCC802F2-6027-4524-8FD1-47522F98D2E7), object,
    pointer_default(unique)
]
interface INewWindowManager : IUnknown
{
    enum tagNWMF
    {
        NWMF_UNLOADING        = 0x0001,
        NWMF_USERINITED       = 0x0002,
        NWMF_FIRST_USERINITED = 0x0004,
        NWMF_OVERRIDEKEY      = 0x0008,
        NWMF_SHOWHELP         = 0x0010,
    };

    HRESULT EvaluateNewWindow([in] LPCWSTR pszUrl, [in] LPCWSTR pszName, [in] LPCWSTR pszUrlContext, [in] LPCWSTR pszFeatures, [in] BOOL fReplace, [in] DWORD dwFlags);
}

// INavBar interface for modifying the navbar
[
    uuid(C339211E-E4B5-4a2c-AD84-4042F8956AE9), object,
    pointer_default(unique)
]
interface INavBar : IUnknown
{
    typedef DWORD NAVBARSIZING;
    [v1_enum] enum tagNAVBARSIZING
    {
        NAVBAR_SMALL        = 0x0001,
        NAVBAR_MEDIUM       = 0x0002,
        NAVBAR_LARGE        = 0x0003,
        NAVBAR_XLARGE       = 0x0004,
        NAVBAR_DEFAULT      = 0x0005,
        NAVBAR_CUSTOM       = 0x0006
    };

    HRESULT SetNavbarSize([in] DWORD dwSize);
}

//
//  NOTE - this typelib is never registered anywhere
//  objects that want their typelibs to be registered
//  in shell32 should add their coclass to shldisp.idl
//
[
    uuid(50a7e9b1-70ef-11d1-b75a-00a0c90564fe), // LIBID_ShellObjects
    helpstring("Microsoft Shell Objects"),
    lcid(0x0000),
    version(1.0)
]
library ShellObjects
{
    // CLSID_QueryCancelAutoPlay
    [ uuid(331F1768-05A9-4ddd-B86E-DAE34DDC998A) ] coclass QueryCancelAutoPlay { interface IQueryCancelAutoPlay; }

    // CLSID_ImageProperties
    [ uuid(7ab770c7-0e23-4d7a-8aa2-19bfad479829) ] coclass ImageProperties { interface IPersistFile; }

    // CLSID_PropertiesUI
    [ uuid(d912f8cf-0396-4915-884e-fb425d32943b) ] coclass PropertiesUI { interface IPropertyUI; }

    // CLSID_UserNotification
    [ uuid(0010890e-8789-413c-adbc-48f5b511b3af) ] coclass UserNotification { interface IUserNotification; }

    // CLSID_CDBurn
    [ uuid(fbeb8a05-beee-4442-804e-409d6c4515e9) ] coclass CDBurn { interface ICDBurn; }

    // CLSID_TaskbarList
    [ uuid(56FDF344-FD6D-11d0-958A-006097C9A090) ] coclass TaskbarList { interface ITaskbarList2; }

    // For supporting HTML wizard extensions we provide this object, it implements the IWizardExtenion
    // and allows the site to specific via an IPropertyBag an URL which should be displayed.  The property
    // bag is requested from the SID_WebWizardHost, and it used inturn to return parameter information
    // back to the site (eg. any information that the displayed HTML would like to communicate).

    // CLSID_WebWizardHost
    [ uuid(c827f149-55c1-4d28-935e-57e47caed973) ] coclass WebWizardHost { interface IWebWizardExtension; }

    // CLSID_PublishDropTarget
    [ uuid(CC6EEFFB-43F6-46c5-9619-51D571967F7D) ] coclass PublishDropTarget { interface IDropTarget; }

    // CLSID_PublishingWizard
    [ uuid(6b33163c-76a5-4b6c-bf21-45de9cd503a1) ] coclass PublishingWizard { interface IPublishingWizard2; }
    cpp_quote("#define SID_PublishingWizard CLSID_PublishingWizard")

    // CLSID_InternetPrintOrdering
    [ uuid(add36aa8-751a-4579-a266-d66f5202ccbb) ] coclass InternetPrintOrdering { interface IDropTarget; }

    // CLSID_FolderViewHost
    [ uuid(20b1cb23-6968-4eb9-b7d4-a66d00d07cee) ] coclass FolderViewHost { interface IFolderViewHost; }

    // CLSID_ImageRecompress
    [ uuid(6e33091c-d2f8-4740-b55e-2e11d1477a2c) ] coclass ImageRecompress { interface IImageRecompress; }

    // CLSID_TrayBandSiteService
    [ uuid(F60AD0A0-E5E1-45cb-B51A-E15B9F8B2934) ] coclass TrayBandSiteService { interface IBandSite; }

    // CLSID_PassportWizard
    [ uuid(58f1f272-9240-4f51-b6d4-fd63d1618591) ] coclass PassportWizard { interface IPassportWizard; }

    // CLSID_DocPropShellExtension
    [ uuid(883373C3-BF89-11D1-BE35-080036B11A03) ] coclass DocPropShellExtension { interface IShellExtInit; }

    // CLSID_DocPropEditBoxControl
    [ uuid(A9CF0EAE-901A-4739-A481-E35B73E47F6D) ] coclass DocPropEditBoxControl { interface IEditVariantInPlace; }

    // CLSID_DocPropMLEditBoxControl
    [ uuid(8EE97210-FD1F-4b19-91DA-67914005F020) ] coclass DocPropMLEditBoxControl { interface IEditVariantInPlace; }

    // CLSID_DocPropDropListComboControl
    [ uuid(0EEA25CC-4362-4a12-850B-86EE61B0D3EB) ] coclass DocPropDropListComboControl { interface IEditVariantInPlace; }

    // CLSID_DocPropCalendarControl
    [ uuid(6A205B57-2567-4a2c-B881-F787FAB579A3) ] coclass DocPropCalendarControl { interface IEditVariantInPlace; }

    // CLSID_DocPropDrawRatingControl
    [ uuid(4AB4E1C2-A928-4d32-BD4D-B4159D33917E) ] coclass DocPropDrawRatingControl { interface IDrawPropVariant; }

    // CLSID_DocPropEditRatingControl
    [ uuid(033DB6C8-EEFE-4852-A080-5BCBFA6759DA) ] coclass DocPropEditRatingControl { interface IEditVariantInPlace; }

    // CLSID_DocPropDrawPercentFullControl
    [ uuid(AB517586-73CF-489c-8D8C-5AE0EAD0613A) ] coclass DocPropDrawPercentFullControl { interface IDrawPropVariant; }

    // CLSID_DocPropMultiValuePropertyControl
    [ uuid(f444b20e-58ec-4b65-88c3-78fa9395b5a2) ] coclass DocPropMultiValuePropertyControl { interface IEditVariantInPlace; }

    // CLSID_StickyNoteDisplayControl
    [ uuid(2BE90585-29CE-41d1-A042-DE8F40B63DA5) ] coclass StickyNoteDisplayControl { interface IUnknown; }

    // CLSID_ShellItem
    [ uuid(9ac9fbe1-e0a2-4ad6-b4ee-e212013ea917) ] coclass ShellItem { interface IShellItem2; }

    // CLSID_NamespaceWalker
    [ uuid(72eb61e0-8672-4303-9175-f2e4c68b2e7c) ] coclass NamespaceWalker { interface INamespaceWalk; }

    // CLSID_KeywordList
    [ uuid(EFDCF468-B5DD-4c7e-97F5-0B53DC064BA5) ] coclass KeywordList { interface IKeywordList; }

    // CLSID_ModalKeywordEditor
    [ uuid(126455EE-AA1B-476c-B74B-5AECB535BBAD) ] coclass ModalKeywordEditor { interface IModalKeywordEditor; }

    // CLSID_FileOperation
    [ uuid(3ad05575-8857-4850-9277-11b85bdb8e09) ] coclass FileOperation { interface IFileOperation; }

    // CLSID_FileOpenDialog
    [ uuid(DC1C5A9C-E88A-4dde-A5A1-60F82A20AEF7) ] coclass FileOpenDialog { interface IFileOpenDialog; }

    // CLSID_FileSaveDialog
    [ uuid(C0B4E2F3-BA21-4773-8DBA-335EC946EB8B) ] coclass FileSaveDialog { interface IFileSaveDialog; }

    // CLSID_PropertyStore
    [ uuid(61559f58-a1b1-4e0c-8887-e3d5d60d4ced) ] coclass PropertyStore { interface IPropertyStore; }

    // CLSID_PlaylistEditor
    [ uuid(8014DF66-DBF0-4f32-9C15-63AA96DBF668) ] coclass PlaylistEditor { interface IPlaylistEditor; }

    // CLSID_FolderInformation
    [ uuid(6ad381f2-d036-4a49-8f29-7e9b6812b3e4) ] coclass FolderInformation { interface IFolderInformation; }

    // CLSID_FSCopyHandler
    [ uuid(D197380A-0A79-4dc8-A033-ED882C2FA14B) ] coclass FSCopyHandler { interface IUnknown; }

    // CLSID_ShareManager
    [ uuid(edb5f444-cb8d-445a-a523-ec5ab6ea33c7) ] coclass ShareManager { interface IShareManager; }

    // CLSID_PreviousVersions
    [ uuid(596AB062-B4D2-4215-9F74-E9109B0A8153) ] coclass PreviousVersions { interface IPreviousVersionsInfo; }

    // CLSID_LaunchComposeWindow
    [ uuid(C1669D05-2CB2-4e32-8E46-5E1BEAD0FDF1) ] coclass LaunchComposeWindow { interface IComposeWindow; }

    // CLSID_BasketControl
    [ uuid(CF698731-C297-45CB-BE29-CA256AA8EFC3) ] coclass BasketControl { interface IBasketControl; }

    // CLSID_ListMakerControl
    [ uuid(9E0D5252-7BC9-407A-B69E-446CF891ABD4) ] coclass ListMakerControl { interface IListMakerControl; }

    // CLSID_SyncDatabase
    [ uuid(9d161572-d3c1-4022-a2ee-e4480f0c3aca) ] coclass SyncDatabase { interface ISyncDatabase; }

    // CLSID_DevicePickerDialog
    [ uuid(9ba04337-a946-4113-9b9b-ea17717da288) ] coclass DevicePickerDialog { interface IFileOpenDialog; }

    // CLSID_DevicePickerFolderViewHost
    [ uuid(89acdf59-3d16-4f13-a576-9254971b1ce4) ] coclass DevicePickerFolderViewHost { interface IDevicePickerFolderViewHost; }

    // CLSID_NetworkConnections
    [ uuid(7007ACC7-3202-11D1-AAD2-00805FC1270E) ] coclass NetworkConnections { interface IShellFolder2; }

    // CLSID_ScheduledTasks
    [ uuid(D6277990-4C6A-11CF-8D87-00AA0060F5BF) ] coclass ScheduledTasks { interface IShellFolder2; }
};

cpp_quote("SHSTDAPI SHGetTemporaryPropertyForItem(IShellItem *psi, REFPROPERTYKEY pk, PROPVARIANT * pvInk);")
cpp_quote("SHSTDAPI SHSetTemporaryPropertyForItem(IShellItem *psi, REFPROPERTYKEY pk, const PROPVARIANT * pvInk);")

